<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><title>Python: module _asyncio</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
</head><body bgcolor="#f0f0f8">

<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="heading">
<tr bgcolor="#7799ee">
<td valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial">&nbsp;<br><big><big><strong>_asyncio</strong></big></big></font></td
><td align=right valign=bottom
><font color="#ffffff" face="helvetica, arial"><a href=".">index</a><br><a href="file:c%3A%5Cpython38%5Cdlls%5C_asyncio.pyd">c:\python38\dlls\_asyncio.pyd</a></font></td></tr></table>
    <p><tt>Accelerator&nbsp;module&nbsp;for&nbsp;asyncio</tt></p>
<p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ee77aa">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial"><big><strong>Classes</strong></big></font></td></tr>
    
<tr><td bgcolor="#ee77aa"><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>
<td width="100%"><dl>
<dt><font face="helvetica, arial"><a href="builtins.html#object">builtins.object</a>
</font></dt><dd>
<dl>
<dt><font face="helvetica, arial"><a href="_asyncio.html#Future">Future</a>
</font></dt><dd>
<dl>
<dt><font face="helvetica, arial"><a href="_asyncio.html#Task">Task</a>
</font></dt></dl>
</dd>
</dl>
</dd>
</dl>
 <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="Future">class <strong>Future</strong></a>(<a href="builtins.html#object">builtins.object</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#Future">Future</a>(*,&nbsp;loop=None)<br>
&nbsp;<br>
This&nbsp;class&nbsp;is&nbsp;*almost*&nbsp;compatible&nbsp;with&nbsp;concurrent.futures.<a href="#Future">Future</a>.<br>
&nbsp;<br>
Differences:<br>
&nbsp;<br>
-&nbsp;<a href="#Future-result">result</a>()&nbsp;and&nbsp;<a href="#Future-exception">exception</a>()&nbsp;do&nbsp;not&nbsp;take&nbsp;a&nbsp;timeout&nbsp;argument&nbsp;and<br>
&nbsp;&nbsp;raise&nbsp;an&nbsp;exception&nbsp;when&nbsp;the&nbsp;future&nbsp;isn't&nbsp;done&nbsp;yet.<br>
&nbsp;<br>
-&nbsp;Callbacks&nbsp;registered&nbsp;with&nbsp;<a href="#Future-add_done_callback">add_done_callback</a>()&nbsp;are&nbsp;always&nbsp;called<br>
&nbsp;&nbsp;via&nbsp;the&nbsp;event&nbsp;loop's&nbsp;call_soon_threadsafe().<br>
&nbsp;<br>
-&nbsp;This&nbsp;class&nbsp;is&nbsp;not&nbsp;compatible&nbsp;with&nbsp;the&nbsp;wait()&nbsp;and&nbsp;as_completed()<br>
&nbsp;&nbsp;methods&nbsp;in&nbsp;the&nbsp;concurrent.futures&nbsp;package.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%">Methods defined here:<br>
<dl><dt><a name="Future-__await__"><strong>__await__</strong></a>(self, /)</dt><dd><tt>Return&nbsp;an&nbsp;iterator&nbsp;to&nbsp;be&nbsp;used&nbsp;in&nbsp;await&nbsp;expression.</tt></dd></dl>

<dl><dt><a name="Future-__del__"><strong>__del__</strong></a>(...)</dt></dl>

<dl><dt><a name="Future-__init__"><strong>__init__</strong></a>(self, /, *args, **kwargs)</dt><dd><tt>Initialize&nbsp;self.&nbsp;&nbsp;See&nbsp;help(type(self))&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<dl><dt><a name="Future-__iter__"><strong>__iter__</strong></a>(self, /)</dt><dd><tt>Implement&nbsp;iter(self).</tt></dd></dl>

<dl><dt><a name="Future-__repr__"><strong>__repr__</strong></a>(self, /)</dt><dd><tt>Return&nbsp;repr(self).</tt></dd></dl>

<dl><dt><a name="Future-add_done_callback"><strong>add_done_callback</strong></a>(...)</dt><dd><tt>Add&nbsp;a&nbsp;callback&nbsp;to&nbsp;be&nbsp;run&nbsp;when&nbsp;the&nbsp;future&nbsp;becomes&nbsp;done.<br>
&nbsp;<br>
The&nbsp;callback&nbsp;is&nbsp;called&nbsp;with&nbsp;a&nbsp;single&nbsp;argument&nbsp;-&nbsp;the&nbsp;future&nbsp;<a href="builtins.html#object">object</a>.&nbsp;If<br>
the&nbsp;future&nbsp;is&nbsp;already&nbsp;done&nbsp;when&nbsp;this&nbsp;is&nbsp;called,&nbsp;the&nbsp;callback&nbsp;is<br>
scheduled&nbsp;with&nbsp;call_soon.</tt></dd></dl>

<dl><dt><a name="Future-cancel"><strong>cancel</strong></a>(self, /)</dt><dd><tt>Cancel&nbsp;the&nbsp;future&nbsp;and&nbsp;schedule&nbsp;callbacks.<br>
&nbsp;<br>
If&nbsp;the&nbsp;future&nbsp;is&nbsp;already&nbsp;done&nbsp;or&nbsp;cancelled,&nbsp;return&nbsp;False.&nbsp;&nbsp;Otherwise,<br>
change&nbsp;the&nbsp;future's&nbsp;state&nbsp;to&nbsp;cancelled,&nbsp;schedule&nbsp;the&nbsp;callbacks&nbsp;and<br>
return&nbsp;True.</tt></dd></dl>

<dl><dt><a name="Future-cancelled"><strong>cancelled</strong></a>(self, /)</dt><dd><tt>Return&nbsp;True&nbsp;if&nbsp;the&nbsp;future&nbsp;was&nbsp;cancelled.</tt></dd></dl>

<dl><dt><a name="Future-done"><strong>done</strong></a>(self, /)</dt><dd><tt>Return&nbsp;True&nbsp;if&nbsp;the&nbsp;future&nbsp;is&nbsp;done.<br>
&nbsp;<br>
Done&nbsp;means&nbsp;either&nbsp;that&nbsp;a&nbsp;result&nbsp;/&nbsp;exception&nbsp;are&nbsp;available,&nbsp;or&nbsp;that&nbsp;the<br>
future&nbsp;was&nbsp;cancelled.</tt></dd></dl>

<dl><dt><a name="Future-exception"><strong>exception</strong></a>(self, /)</dt><dd><tt>Return&nbsp;the&nbsp;exception&nbsp;that&nbsp;was&nbsp;set&nbsp;on&nbsp;this&nbsp;future.<br>
&nbsp;<br>
The&nbsp;exception&nbsp;(or&nbsp;None&nbsp;if&nbsp;no&nbsp;exception&nbsp;was&nbsp;set)&nbsp;is&nbsp;returned&nbsp;only&nbsp;if<br>
the&nbsp;future&nbsp;is&nbsp;done.&nbsp;&nbsp;If&nbsp;the&nbsp;future&nbsp;has&nbsp;been&nbsp;cancelled,&nbsp;raises<br>
CancelledError.&nbsp;&nbsp;If&nbsp;the&nbsp;future&nbsp;isn't&nbsp;done&nbsp;yet,&nbsp;raises<br>
InvalidStateError.</tt></dd></dl>

<dl><dt><a name="Future-get_loop"><strong>get_loop</strong></a>(self, /)</dt><dd><tt>Return&nbsp;the&nbsp;event&nbsp;loop&nbsp;the&nbsp;<a href="#Future">Future</a>&nbsp;is&nbsp;bound&nbsp;to.</tt></dd></dl>

<dl><dt><a name="Future-remove_done_callback"><strong>remove_done_callback</strong></a>(self, fn, /)</dt><dd><tt>Remove&nbsp;all&nbsp;instances&nbsp;of&nbsp;a&nbsp;callback&nbsp;from&nbsp;the&nbsp;"call&nbsp;when&nbsp;done"&nbsp;list.<br>
&nbsp;<br>
Returns&nbsp;the&nbsp;number&nbsp;of&nbsp;callbacks&nbsp;removed.</tt></dd></dl>

<dl><dt><a name="Future-result"><strong>result</strong></a>(self, /)</dt><dd><tt>Return&nbsp;the&nbsp;result&nbsp;this&nbsp;future&nbsp;represents.<br>
&nbsp;<br>
If&nbsp;the&nbsp;future&nbsp;has&nbsp;been&nbsp;cancelled,&nbsp;raises&nbsp;CancelledError.&nbsp;&nbsp;If&nbsp;the<br>
future's&nbsp;result&nbsp;isn't&nbsp;yet&nbsp;available,&nbsp;raises&nbsp;InvalidStateError.&nbsp;&nbsp;If<br>
the&nbsp;future&nbsp;is&nbsp;done&nbsp;and&nbsp;has&nbsp;an&nbsp;exception&nbsp;set,&nbsp;this&nbsp;exception&nbsp;is&nbsp;raised.</tt></dd></dl>

<dl><dt><a name="Future-set_exception"><strong>set_exception</strong></a>(self, exception, /)</dt><dd><tt>Mark&nbsp;the&nbsp;future&nbsp;done&nbsp;and&nbsp;set&nbsp;an&nbsp;exception.<br>
&nbsp;<br>
If&nbsp;the&nbsp;future&nbsp;is&nbsp;already&nbsp;done&nbsp;when&nbsp;this&nbsp;method&nbsp;is&nbsp;called,&nbsp;raises<br>
InvalidStateError.</tt></dd></dl>

<dl><dt><a name="Future-set_result"><strong>set_result</strong></a>(self, result, /)</dt><dd><tt>Mark&nbsp;the&nbsp;future&nbsp;done&nbsp;and&nbsp;set&nbsp;its&nbsp;result.<br>
&nbsp;<br>
If&nbsp;the&nbsp;future&nbsp;is&nbsp;already&nbsp;done&nbsp;when&nbsp;this&nbsp;method&nbsp;is&nbsp;called,&nbsp;raises<br>
InvalidStateError.</tt></dd></dl>

<hr>
Static methods defined here:<br>
<dl><dt><a name="Future-__new__"><strong>__new__</strong></a>(*args, **kwargs)<font color="#909090"><font face="helvetica, arial"> from <a href="builtins.html#type">builtins.type</a></font></font></dt><dd><tt>Create&nbsp;and&nbsp;return&nbsp;a&nbsp;new&nbsp;<a href="builtins.html#object">object</a>.&nbsp;&nbsp;See&nbsp;help(type)&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="Task">class <strong>Task</strong></a>(<a href="_asyncio.html#Future">Future</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#Task">Task</a>(coro,&nbsp;*,&nbsp;loop=None,&nbsp;name=None)<br>
&nbsp;<br>
A&nbsp;coroutine&nbsp;wrapped&nbsp;in&nbsp;a&nbsp;<a href="#Future">Future</a>.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="_asyncio.html#Task">Task</a></dd>
<dd><a href="_asyncio.html#Future">Future</a></dd>
<dd><a href="builtins.html#object">builtins.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="Task-__await__"><strong>__await__</strong></a>(self, /)</dt><dd><tt>Return&nbsp;an&nbsp;iterator&nbsp;to&nbsp;be&nbsp;used&nbsp;in&nbsp;await&nbsp;expression.</tt></dd></dl>

<dl><dt><a name="Task-__del__"><strong>__del__</strong></a>(...)</dt></dl>

<dl><dt><a name="Task-__init__"><strong>__init__</strong></a>(self, /, *args, **kwargs)</dt><dd><tt>Initialize&nbsp;self.&nbsp;&nbsp;See&nbsp;help(type(self))&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<dl><dt><a name="Task-__iter__"><strong>__iter__</strong></a>(self, /)</dt><dd><tt>Implement&nbsp;iter(self).</tt></dd></dl>

<dl><dt><a name="Task-__repr__"><strong>__repr__</strong></a>(self, /)</dt><dd><tt>Return&nbsp;repr(self).</tt></dd></dl>

<dl><dt><a name="Task-add_done_callback"><strong>add_done_callback</strong></a>(...)</dt><dd><tt>Add&nbsp;a&nbsp;callback&nbsp;to&nbsp;be&nbsp;run&nbsp;when&nbsp;the&nbsp;future&nbsp;becomes&nbsp;done.<br>
&nbsp;<br>
The&nbsp;callback&nbsp;is&nbsp;called&nbsp;with&nbsp;a&nbsp;single&nbsp;argument&nbsp;-&nbsp;the&nbsp;future&nbsp;<a href="builtins.html#object">object</a>.&nbsp;If<br>
the&nbsp;future&nbsp;is&nbsp;already&nbsp;done&nbsp;when&nbsp;this&nbsp;is&nbsp;called,&nbsp;the&nbsp;callback&nbsp;is<br>
scheduled&nbsp;with&nbsp;call_soon.</tt></dd></dl>

<dl><dt><a name="Task-cancel"><strong>cancel</strong></a>(self, /)</dt><dd><tt>Request&nbsp;that&nbsp;this&nbsp;task&nbsp;cancel&nbsp;itself.<br>
&nbsp;<br>
This&nbsp;arranges&nbsp;for&nbsp;a&nbsp;CancelledError&nbsp;to&nbsp;be&nbsp;thrown&nbsp;into&nbsp;the<br>
wrapped&nbsp;coroutine&nbsp;on&nbsp;the&nbsp;next&nbsp;cycle&nbsp;through&nbsp;the&nbsp;event&nbsp;loop.<br>
The&nbsp;coroutine&nbsp;then&nbsp;has&nbsp;a&nbsp;chance&nbsp;to&nbsp;clean&nbsp;up&nbsp;or&nbsp;even&nbsp;deny<br>
the&nbsp;request&nbsp;using&nbsp;try/except/finally.<br>
&nbsp;<br>
Unlike&nbsp;<a href="#Future">Future</a>.cancel,&nbsp;this&nbsp;does&nbsp;not&nbsp;guarantee&nbsp;that&nbsp;the<br>
task&nbsp;will&nbsp;be&nbsp;cancelled:&nbsp;the&nbsp;exception&nbsp;might&nbsp;be&nbsp;caught&nbsp;and<br>
acted&nbsp;upon,&nbsp;delaying&nbsp;cancellation&nbsp;of&nbsp;the&nbsp;task&nbsp;or&nbsp;preventing<br>
cancellation&nbsp;completely.&nbsp;&nbsp;The&nbsp;task&nbsp;may&nbsp;also&nbsp;return&nbsp;a&nbsp;value&nbsp;or<br>
raise&nbsp;a&nbsp;different&nbsp;exception.<br>
&nbsp;<br>
Immediately&nbsp;after&nbsp;this&nbsp;method&nbsp;is&nbsp;called,&nbsp;<a href="#Task">Task</a>.<a href="#Task-cancelled">cancelled</a>()&nbsp;will<br>
not&nbsp;return&nbsp;True&nbsp;(unless&nbsp;the&nbsp;task&nbsp;was&nbsp;already&nbsp;cancelled).&nbsp;&nbsp;A<br>
task&nbsp;will&nbsp;be&nbsp;marked&nbsp;as&nbsp;cancelled&nbsp;when&nbsp;the&nbsp;wrapped&nbsp;coroutine<br>
terminates&nbsp;with&nbsp;a&nbsp;CancelledError&nbsp;exception&nbsp;(even&nbsp;if&nbsp;<a href="#Task-cancel">cancel</a>()<br>
was&nbsp;not&nbsp;called).</tt></dd></dl>

<dl><dt><a name="Task-cancelled"><strong>cancelled</strong></a>(self, /)</dt><dd><tt>Return&nbsp;True&nbsp;if&nbsp;the&nbsp;future&nbsp;was&nbsp;cancelled.</tt></dd></dl>

<dl><dt><a name="Task-done"><strong>done</strong></a>(self, /)</dt><dd><tt>Return&nbsp;True&nbsp;if&nbsp;the&nbsp;future&nbsp;is&nbsp;done.<br>
&nbsp;<br>
Done&nbsp;means&nbsp;either&nbsp;that&nbsp;a&nbsp;result&nbsp;/&nbsp;exception&nbsp;are&nbsp;available,&nbsp;or&nbsp;that&nbsp;the<br>
future&nbsp;was&nbsp;cancelled.</tt></dd></dl>

<dl><dt><a name="Task-exception"><strong>exception</strong></a>(self, /)</dt><dd><tt>Return&nbsp;the&nbsp;exception&nbsp;that&nbsp;was&nbsp;set&nbsp;on&nbsp;this&nbsp;future.<br>
&nbsp;<br>
The&nbsp;exception&nbsp;(or&nbsp;None&nbsp;if&nbsp;no&nbsp;exception&nbsp;was&nbsp;set)&nbsp;is&nbsp;returned&nbsp;only&nbsp;if<br>
the&nbsp;future&nbsp;is&nbsp;done.&nbsp;&nbsp;If&nbsp;the&nbsp;future&nbsp;has&nbsp;been&nbsp;cancelled,&nbsp;raises<br>
CancelledError.&nbsp;&nbsp;If&nbsp;the&nbsp;future&nbsp;isn't&nbsp;done&nbsp;yet,&nbsp;raises<br>
InvalidStateError.</tt></dd></dl>

<dl><dt><a name="Task-get_coro"><strong>get_coro</strong></a>(self, /)</dt></dl>

<dl><dt><a name="Task-get_name"><strong>get_name</strong></a>(self, /)</dt></dl>

<dl><dt><a name="Task-get_stack"><strong>get_stack</strong></a>(self, /, *, limit=None)</dt><dd><tt>Return&nbsp;the&nbsp;list&nbsp;of&nbsp;stack&nbsp;frames&nbsp;for&nbsp;this&nbsp;task's&nbsp;coroutine.<br>
&nbsp;<br>
If&nbsp;the&nbsp;coroutine&nbsp;is&nbsp;not&nbsp;done,&nbsp;this&nbsp;returns&nbsp;the&nbsp;stack&nbsp;where&nbsp;it&nbsp;is<br>
suspended.&nbsp;&nbsp;If&nbsp;the&nbsp;coroutine&nbsp;has&nbsp;completed&nbsp;successfully&nbsp;or&nbsp;was<br>
cancelled,&nbsp;this&nbsp;returns&nbsp;an&nbsp;empty&nbsp;list.&nbsp;&nbsp;If&nbsp;the&nbsp;coroutine&nbsp;was<br>
terminated&nbsp;by&nbsp;an&nbsp;exception,&nbsp;this&nbsp;returns&nbsp;the&nbsp;list&nbsp;of&nbsp;traceback<br>
frames.<br>
&nbsp;<br>
The&nbsp;frames&nbsp;are&nbsp;always&nbsp;ordered&nbsp;from&nbsp;oldest&nbsp;to&nbsp;newest.<br>
&nbsp;<br>
The&nbsp;optional&nbsp;limit&nbsp;gives&nbsp;the&nbsp;maximum&nbsp;number&nbsp;of&nbsp;frames&nbsp;to<br>
return;&nbsp;by&nbsp;default&nbsp;all&nbsp;available&nbsp;frames&nbsp;are&nbsp;returned.&nbsp;&nbsp;Its<br>
meaning&nbsp;differs&nbsp;depending&nbsp;on&nbsp;whether&nbsp;a&nbsp;stack&nbsp;or&nbsp;a&nbsp;traceback&nbsp;is<br>
returned:&nbsp;the&nbsp;newest&nbsp;frames&nbsp;of&nbsp;a&nbsp;stack&nbsp;are&nbsp;returned,&nbsp;but&nbsp;the<br>
oldest&nbsp;frames&nbsp;of&nbsp;a&nbsp;traceback&nbsp;are&nbsp;returned.&nbsp;&nbsp;(This&nbsp;matches&nbsp;the<br>
behavior&nbsp;of&nbsp;the&nbsp;traceback&nbsp;module.)<br>
&nbsp;<br>
For&nbsp;reasons&nbsp;beyond&nbsp;our&nbsp;control,&nbsp;only&nbsp;one&nbsp;stack&nbsp;frame&nbsp;is<br>
returned&nbsp;for&nbsp;a&nbsp;suspended&nbsp;coroutine.</tt></dd></dl>

<dl><dt><a name="Task-print_stack"><strong>print_stack</strong></a>(self, /, *, limit=None, file=None)</dt><dd><tt>Print&nbsp;the&nbsp;stack&nbsp;or&nbsp;traceback&nbsp;for&nbsp;this&nbsp;task's&nbsp;coroutine.<br>
&nbsp;<br>
This&nbsp;produces&nbsp;output&nbsp;similar&nbsp;to&nbsp;that&nbsp;of&nbsp;the&nbsp;traceback&nbsp;module,<br>
for&nbsp;the&nbsp;frames&nbsp;retrieved&nbsp;by&nbsp;<a href="#Task-get_stack">get_stack</a>().&nbsp;&nbsp;The&nbsp;limit&nbsp;argument<br>
is&nbsp;passed&nbsp;to&nbsp;<a href="#Task-get_stack">get_stack</a>().&nbsp;&nbsp;The&nbsp;file&nbsp;argument&nbsp;is&nbsp;an&nbsp;I/O&nbsp;stream<br>
to&nbsp;which&nbsp;the&nbsp;output&nbsp;is&nbsp;written;&nbsp;by&nbsp;default&nbsp;output&nbsp;is&nbsp;written<br>
to&nbsp;sys.stderr.</tt></dd></dl>

<dl><dt><a name="Task-remove_done_callback"><strong>remove_done_callback</strong></a>(self, fn, /)</dt><dd><tt>Remove&nbsp;all&nbsp;instances&nbsp;of&nbsp;a&nbsp;callback&nbsp;from&nbsp;the&nbsp;"call&nbsp;when&nbsp;done"&nbsp;list.<br>
&nbsp;<br>
Returns&nbsp;the&nbsp;number&nbsp;of&nbsp;callbacks&nbsp;removed.</tt></dd></dl>

<dl><dt><a name="Task-result"><strong>result</strong></a>(self, /)</dt><dd><tt>Return&nbsp;the&nbsp;result&nbsp;this&nbsp;future&nbsp;represents.<br>
&nbsp;<br>
If&nbsp;the&nbsp;future&nbsp;has&nbsp;been&nbsp;cancelled,&nbsp;raises&nbsp;CancelledError.&nbsp;&nbsp;If&nbsp;the<br>
future's&nbsp;result&nbsp;isn't&nbsp;yet&nbsp;available,&nbsp;raises&nbsp;InvalidStateError.&nbsp;&nbsp;If<br>
the&nbsp;future&nbsp;is&nbsp;done&nbsp;and&nbsp;has&nbsp;an&nbsp;exception&nbsp;set,&nbsp;this&nbsp;exception&nbsp;is&nbsp;raised.</tt></dd></dl>

<dl><dt><a name="Task-set_exception"><strong>set_exception</strong></a>(self, exception, /)</dt><dd><tt>Mark&nbsp;the&nbsp;future&nbsp;done&nbsp;and&nbsp;set&nbsp;an&nbsp;exception.<br>
&nbsp;<br>
If&nbsp;the&nbsp;future&nbsp;is&nbsp;already&nbsp;done&nbsp;when&nbsp;this&nbsp;method&nbsp;is&nbsp;called,&nbsp;raises<br>
InvalidStateError.</tt></dd></dl>

<dl><dt><a name="Task-set_name"><strong>set_name</strong></a>(self, value, /)</dt></dl>

<dl><dt><a name="Task-set_result"><strong>set_result</strong></a>(self, result, /)</dt><dd><tt>Mark&nbsp;the&nbsp;future&nbsp;done&nbsp;and&nbsp;set&nbsp;its&nbsp;result.<br>
&nbsp;<br>
If&nbsp;the&nbsp;future&nbsp;is&nbsp;already&nbsp;done&nbsp;when&nbsp;this&nbsp;method&nbsp;is&nbsp;called,&nbsp;raises<br>
InvalidStateError.</tt></dd></dl>

<hr>
Class methods defined here:<br>
<dl><dt><a name="Task-all_tasks"><strong>all_tasks</strong></a>(loop=None)<font color="#909090"><font face="helvetica, arial"> from <a href="builtins.html#type">builtins.type</a></font></font></dt><dd><tt>Return&nbsp;a&nbsp;set&nbsp;of&nbsp;all&nbsp;tasks&nbsp;for&nbsp;an&nbsp;event&nbsp;loop.<br>
&nbsp;<br>
By&nbsp;default&nbsp;all&nbsp;tasks&nbsp;for&nbsp;the&nbsp;current&nbsp;event&nbsp;loop&nbsp;are&nbsp;returned.</tt></dd></dl>

<dl><dt><a name="Task-current_task"><strong>current_task</strong></a>(loop=None)<font color="#909090"><font face="helvetica, arial"> from <a href="builtins.html#type">builtins.type</a></font></font></dt><dd><tt>Return&nbsp;the&nbsp;currently&nbsp;running&nbsp;task&nbsp;in&nbsp;an&nbsp;event&nbsp;loop&nbsp;or&nbsp;None.<br>
&nbsp;<br>
By&nbsp;default&nbsp;the&nbsp;current&nbsp;task&nbsp;for&nbsp;the&nbsp;current&nbsp;event&nbsp;loop&nbsp;is&nbsp;returned.<br>
&nbsp;<br>
None&nbsp;is&nbsp;returned&nbsp;when&nbsp;called&nbsp;not&nbsp;in&nbsp;the&nbsp;context&nbsp;of&nbsp;a&nbsp;<a href="#Task">Task</a>.</tt></dd></dl>

<hr>
Static methods defined here:<br>
<dl><dt><a name="Task-__new__"><strong>__new__</strong></a>(*args, **kwargs)<font color="#909090"><font face="helvetica, arial"> from <a href="builtins.html#type">builtins.type</a></font></font></dt><dd><tt>Create&nbsp;and&nbsp;return&nbsp;a&nbsp;new&nbsp;<a href="builtins.html#object">object</a>.&nbsp;&nbsp;See&nbsp;help(type)&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<hr>
Methods inherited from <a href="_asyncio.html#Future">Future</a>:<br>
<dl><dt><a name="Task-get_loop"><strong>get_loop</strong></a>(self, /)</dt><dd><tt>Return&nbsp;the&nbsp;event&nbsp;loop&nbsp;the&nbsp;<a href="#Future">Future</a>&nbsp;is&nbsp;bound&nbsp;to.</tt></dd></dl>

</td></tr></table></td></tr></table><p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#eeaa77">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial"><big><strong>Functions</strong></big></font></td></tr>
    
<tr><td bgcolor="#eeaa77"><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>
<td width="100%"><dl><dt><a name="-get_event_loop"><strong>get_event_loop</strong></a>()</dt><dd><tt>Return&nbsp;an&nbsp;asyncio&nbsp;event&nbsp;loop.<br>
&nbsp;<br>
When&nbsp;called&nbsp;from&nbsp;a&nbsp;coroutine&nbsp;or&nbsp;a&nbsp;callback&nbsp;(e.g.&nbsp;scheduled&nbsp;with<br>
call_soon&nbsp;or&nbsp;similar&nbsp;API),&nbsp;this&nbsp;function&nbsp;will&nbsp;always&nbsp;return&nbsp;the<br>
running&nbsp;event&nbsp;loop.<br>
&nbsp;<br>
If&nbsp;there&nbsp;is&nbsp;no&nbsp;running&nbsp;event&nbsp;loop&nbsp;set,&nbsp;the&nbsp;function&nbsp;will&nbsp;return<br>
the&nbsp;result&nbsp;of&nbsp;`get_event_loop_policy().<a href="#-get_event_loop">get_event_loop</a>()`&nbsp;call.</tt></dd></dl>
 <dl><dt><a name="-get_running_loop"><strong>get_running_loop</strong></a>()</dt><dd><tt>Return&nbsp;the&nbsp;running&nbsp;event&nbsp;loop.&nbsp;&nbsp;Raise&nbsp;a&nbsp;RuntimeError&nbsp;if&nbsp;there&nbsp;is&nbsp;none.<br>
&nbsp;<br>
This&nbsp;function&nbsp;is&nbsp;thread-specific.</tt></dd></dl>
</td></tr></table>
</body></html>