<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><title>Python: package asyncio</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
</head><body bgcolor="#f0f0f8">

<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="heading">
<tr bgcolor="#7799ee">
<td valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial">&nbsp;<br><big><big><strong>asyncio</strong></big></big></font></td
><td align=right valign=bottom
><font color="#ffffff" face="helvetica, arial"><a href=".">index</a><br><a href="file:c%3A%5Cpython38%5Clib%5Casyncio%5C__init__.py">c:\python38\lib\asyncio\__init__.py</a><br><a href="https://docs.python.org/3.8/library/asyncio">Module Reference</a></font></td></tr></table>
    <p><tt>The&nbsp;asyncio&nbsp;package,&nbsp;tracking&nbsp;<a href="http://www.python.org/dev/peps/pep-3156/">PEP&nbsp;3156</a>.</tt></p>
<p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ee77aa">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial"><big><strong>Classes</strong></big></font></td></tr>
    
<tr><td bgcolor="#ee77aa"><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>
<td width="100%"><dl>
<dt><font face="helvetica, arial"><a href="asyncio.events.html#BaseDefaultEventLoopPolicy">asyncio.events.BaseDefaultEventLoopPolicy</a>(<a href="asyncio.events.html#AbstractEventLoopPolicy">asyncio.events.AbstractEventLoopPolicy</a>)
</font></dt><dd>
<dl>
<dt><font face="helvetica, arial"><a href="asyncio.windows_events.html#WindowsProactorEventLoopPolicy">asyncio.windows_events.WindowsProactorEventLoopPolicy</a>
</font></dt><dt><font face="helvetica, arial"><a href="asyncio.windows_events.html#WindowsSelectorEventLoopPolicy">asyncio.windows_events.WindowsSelectorEventLoopPolicy</a>
</font></dt></dl>
</dd>
<dt><font face="helvetica, arial"><a href="asyncio.locks.html#_ContextManagerMixin">asyncio.locks._ContextManagerMixin</a>(<a href="builtins.html#object">builtins.object</a>)
</font></dt><dd>
<dl>
<dt><font face="helvetica, arial"><a href="asyncio.locks.html#Condition">asyncio.locks.Condition</a>
</font></dt><dt><font face="helvetica, arial"><a href="asyncio.locks.html#Lock">asyncio.locks.Lock</a>
</font></dt><dt><font face="helvetica, arial"><a href="asyncio.locks.html#Semaphore">asyncio.locks.Semaphore</a>
</font></dt><dd>
<dl>
<dt><font face="helvetica, arial"><a href="asyncio.locks.html#BoundedSemaphore">asyncio.locks.BoundedSemaphore</a>
</font></dt></dl>
</dd>
</dl>
</dd>
<dt><font face="helvetica, arial"><a href="asyncio.proactor_events.html#BaseProactorEventLoop">asyncio.proactor_events.BaseProactorEventLoop</a>(<a href="asyncio.base_events.html#BaseEventLoop">asyncio.base_events.BaseEventLoop</a>)
</font></dt><dd>
<dl>
<dt><font face="helvetica, arial"><a href="asyncio.windows_events.html#ProactorEventLoop">asyncio.windows_events.ProactorEventLoop</a>
</font></dt></dl>
</dd>
<dt><font face="helvetica, arial"><a href="asyncio.selector_events.html#BaseSelectorEventLoop">asyncio.selector_events.BaseSelectorEventLoop</a>(<a href="asyncio.base_events.html#BaseEventLoop">asyncio.base_events.BaseEventLoop</a>)
</font></dt><dd>
<dl>
<dt><font face="helvetica, arial"><a href="asyncio.windows_events.html#_WindowsSelectorEventLoop">asyncio.windows_events._WindowsSelectorEventLoop</a>
</font></dt></dl>
</dd>
<dt><font face="helvetica, arial"><a href="asyncio.streams.html#FlowControlMixin">asyncio.streams.FlowControlMixin</a>(<a href="asyncio.protocols.html#Protocol">asyncio.protocols.Protocol</a>)
</font></dt><dd>
<dl>
<dt><font face="helvetica, arial"><a href="asyncio.streams.html#StreamReaderProtocol">asyncio.streams.StreamReaderProtocol</a>(<a href="asyncio.streams.html#FlowControlMixin">asyncio.streams.FlowControlMixin</a>, <a href="asyncio.protocols.html#Protocol">asyncio.protocols.Protocol</a>)
</font></dt></dl>
</dd>
<dt><font face="helvetica, arial"><a href="builtins.html#BaseException">builtins.BaseException</a>(<a href="builtins.html#object">builtins.object</a>)
</font></dt><dd>
<dl>
<dt><font face="helvetica, arial"><a href="asyncio.exceptions.html#CancelledError">asyncio.exceptions.CancelledError</a>
</font></dt></dl>
</dd>
<dt><font face="helvetica, arial"><a href="builtins.html#EOFError">builtins.EOFError</a>(<a href="builtins.html#Exception">builtins.Exception</a>)
</font></dt><dd>
<dl>
<dt><font face="helvetica, arial"><a href="asyncio.exceptions.html#IncompleteReadError">asyncio.exceptions.IncompleteReadError</a>
</font></dt></dl>
</dd>
<dt><font face="helvetica, arial"><a href="builtins.html#Exception">builtins.Exception</a>(<a href="builtins.html#BaseException">builtins.BaseException</a>)
</font></dt><dd>
<dl>
<dt><font face="helvetica, arial"><a href="asyncio.exceptions.html#InvalidStateError">asyncio.exceptions.InvalidStateError</a>
</font></dt><dt><font face="helvetica, arial"><a href="asyncio.exceptions.html#LimitOverrunError">asyncio.exceptions.LimitOverrunError</a>
</font></dt><dt><font face="helvetica, arial"><a href="asyncio.exceptions.html#TimeoutError">asyncio.exceptions.TimeoutError</a>
</font></dt><dt><font face="helvetica, arial"><a href="asyncio.queues.html#QueueEmpty">asyncio.queues.QueueEmpty</a>
</font></dt><dt><font face="helvetica, arial"><a href="asyncio.queues.html#QueueFull">asyncio.queues.QueueFull</a>
</font></dt></dl>
</dd>
<dt><font face="helvetica, arial"><a href="builtins.html#RuntimeError">builtins.RuntimeError</a>(<a href="builtins.html#Exception">builtins.Exception</a>)
</font></dt><dd>
<dl>
<dt><font face="helvetica, arial"><a href="asyncio.exceptions.html#SendfileNotAvailableError">asyncio.exceptions.SendfileNotAvailableError</a>
</font></dt></dl>
</dd>
<dt><font face="helvetica, arial"><a href="builtins.html#object">builtins.object</a>
</font></dt><dd>
<dl>
<dt><font face="helvetica, arial"><a href="_asyncio.html#Future">_asyncio.Future</a>
</font></dt><dd>
<dl>
<dt><font face="helvetica, arial"><a href="_asyncio.html#Task">_asyncio.Task</a>
</font></dt></dl>
</dd>
<dt><font face="helvetica, arial"><a href="asyncio.events.html#AbstractEventLoop">asyncio.events.AbstractEventLoop</a>
</font></dt><dd>
<dl>
<dt><font face="helvetica, arial"><a href="asyncio.base_events.html#BaseEventLoop">asyncio.base_events.BaseEventLoop</a>
</font></dt></dl>
</dd>
<dt><font face="helvetica, arial"><a href="asyncio.events.html#AbstractEventLoopPolicy">asyncio.events.AbstractEventLoopPolicy</a>
</font></dt><dt><font face="helvetica, arial"><a href="asyncio.events.html#AbstractServer">asyncio.events.AbstractServer</a>
</font></dt><dt><font face="helvetica, arial"><a href="asyncio.events.html#Handle">asyncio.events.Handle</a>
</font></dt><dd>
<dl>
<dt><font face="helvetica, arial"><a href="asyncio.events.html#TimerHandle">asyncio.events.TimerHandle</a>
</font></dt></dl>
</dd>
<dt><font face="helvetica, arial"><a href="asyncio.locks.html#Event">asyncio.locks.Event</a>
</font></dt><dt><font face="helvetica, arial"><a href="asyncio.protocols.html#BaseProtocol">asyncio.protocols.BaseProtocol</a>
</font></dt><dd>
<dl>
<dt><font face="helvetica, arial"><a href="asyncio.protocols.html#BufferedProtocol">asyncio.protocols.BufferedProtocol</a>
</font></dt><dt><font face="helvetica, arial"><a href="asyncio.protocols.html#DatagramProtocol">asyncio.protocols.DatagramProtocol</a>
</font></dt><dt><font face="helvetica, arial"><a href="asyncio.protocols.html#Protocol">asyncio.protocols.Protocol</a>
</font></dt><dd>
<dl>
<dt><font face="helvetica, arial"><a href="asyncio.streams.html#StreamReaderProtocol">asyncio.streams.StreamReaderProtocol</a>(<a href="asyncio.streams.html#FlowControlMixin">asyncio.streams.FlowControlMixin</a>, <a href="asyncio.protocols.html#Protocol">asyncio.protocols.Protocol</a>)
</font></dt></dl>
</dd>
<dt><font face="helvetica, arial"><a href="asyncio.protocols.html#SubprocessProtocol">asyncio.protocols.SubprocessProtocol</a>
</font></dt></dl>
</dd>
<dt><font face="helvetica, arial"><a href="asyncio.queues.html#Queue">asyncio.queues.Queue</a>
</font></dt><dd>
<dl>
<dt><font face="helvetica, arial"><a href="asyncio.queues.html#LifoQueue">asyncio.queues.LifoQueue</a>
</font></dt><dt><font face="helvetica, arial"><a href="asyncio.queues.html#PriorityQueue">asyncio.queues.PriorityQueue</a>
</font></dt></dl>
</dd>
<dt><font face="helvetica, arial"><a href="asyncio.streams.html#StreamReader">asyncio.streams.StreamReader</a>
</font></dt><dt><font face="helvetica, arial"><a href="asyncio.streams.html#StreamWriter">asyncio.streams.StreamWriter</a>
</font></dt><dt><font face="helvetica, arial"><a href="asyncio.transports.html#BaseTransport">asyncio.transports.BaseTransport</a>
</font></dt><dd>
<dl>
<dt><font face="helvetica, arial"><a href="asyncio.transports.html#DatagramTransport">asyncio.transports.DatagramTransport</a>
</font></dt><dt><font face="helvetica, arial"><a href="asyncio.transports.html#ReadTransport">asyncio.transports.ReadTransport</a>
</font></dt><dd>
<dl>
<dt><font face="helvetica, arial"><a href="asyncio.transports.html#Transport">asyncio.transports.Transport</a>(<a href="asyncio.transports.html#ReadTransport">asyncio.transports.ReadTransport</a>, <a href="asyncio.transports.html#WriteTransport">asyncio.transports.WriteTransport</a>)
</font></dt></dl>
</dd>
<dt><font face="helvetica, arial"><a href="asyncio.transports.html#SubprocessTransport">asyncio.transports.SubprocessTransport</a>
</font></dt><dt><font face="helvetica, arial"><a href="asyncio.transports.html#WriteTransport">asyncio.transports.WriteTransport</a>
</font></dt></dl>
</dd>
<dt><font face="helvetica, arial"><a href="asyncio.windows_events.html#IocpProactor">asyncio.windows_events.IocpProactor</a>
</font></dt></dl>
</dd>
</dl>
 <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="AbstractEventLoop">class <strong>AbstractEventLoop</strong></a>(<a href="builtins.html#object">builtins.object</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt>Abstract&nbsp;event&nbsp;loop.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%">Methods defined here:<br>
<dl><dt><a name="AbstractEventLoop-add_reader"><strong>add_reader</strong></a>(self, fd, callback, *args)</dt></dl>

<dl><dt><a name="AbstractEventLoop-add_signal_handler"><strong>add_signal_handler</strong></a>(self, sig, callback, *args)</dt></dl>

<dl><dt><a name="AbstractEventLoop-add_writer"><strong>add_writer</strong></a>(self, fd, callback, *args)</dt></dl>

<dl><dt><a name="AbstractEventLoop-call_at"><strong>call_at</strong></a>(self, when, callback, *args)</dt></dl>

<dl><dt><a name="AbstractEventLoop-call_exception_handler"><strong>call_exception_handler</strong></a>(self, context)</dt></dl>

<dl><dt><a name="AbstractEventLoop-call_later"><strong>call_later</strong></a>(self, delay, callback, *args)</dt></dl>

<dl><dt><a name="AbstractEventLoop-call_soon"><strong>call_soon</strong></a>(self, callback, *args)</dt></dl>

<dl><dt><a name="AbstractEventLoop-call_soon_threadsafe"><strong>call_soon_threadsafe</strong></a>(self, callback, *args)</dt></dl>

<dl><dt><a name="AbstractEventLoop-close"><strong>close</strong></a>(self)</dt><dd><tt>Close&nbsp;the&nbsp;loop.<br>
&nbsp;<br>
The&nbsp;loop&nbsp;should&nbsp;not&nbsp;be&nbsp;running.<br>
&nbsp;<br>
This&nbsp;is&nbsp;idempotent&nbsp;and&nbsp;irreversible.<br>
&nbsp;<br>
No&nbsp;other&nbsp;methods&nbsp;should&nbsp;be&nbsp;called&nbsp;after&nbsp;this&nbsp;one.</tt></dd></dl>

<dl><dt>async <a name="AbstractEventLoop-connect_read_pipe"><strong>connect_read_pipe</strong></a>(self, protocol_factory, pipe)</dt><dd><tt>Register&nbsp;read&nbsp;pipe&nbsp;in&nbsp;event&nbsp;loop.&nbsp;Set&nbsp;the&nbsp;pipe&nbsp;to&nbsp;non-blocking&nbsp;mode.<br>
&nbsp;<br>
protocol_factory&nbsp;should&nbsp;instantiate&nbsp;<a href="builtins.html#object">object</a>&nbsp;with&nbsp;<a href="#Protocol">Protocol</a>&nbsp;interface.<br>
pipe&nbsp;is&nbsp;a&nbsp;file-like&nbsp;<a href="builtins.html#object">object</a>.<br>
Return&nbsp;pair&nbsp;(transport,&nbsp;protocol),&nbsp;where&nbsp;transport&nbsp;supports&nbsp;the<br>
<a href="#ReadTransport">ReadTransport</a>&nbsp;interface.</tt></dd></dl>

<dl><dt>async <a name="AbstractEventLoop-connect_write_pipe"><strong>connect_write_pipe</strong></a>(self, protocol_factory, pipe)</dt><dd><tt>Register&nbsp;write&nbsp;pipe&nbsp;in&nbsp;event&nbsp;loop.<br>
&nbsp;<br>
protocol_factory&nbsp;should&nbsp;instantiate&nbsp;<a href="builtins.html#object">object</a>&nbsp;with&nbsp;<a href="#BaseProtocol">BaseProtocol</a>&nbsp;interface.<br>
Pipe&nbsp;is&nbsp;file-like&nbsp;<a href="builtins.html#object">object</a>&nbsp;already&nbsp;switched&nbsp;to&nbsp;nonblocking.<br>
Return&nbsp;pair&nbsp;(transport,&nbsp;protocol),&nbsp;where&nbsp;transport&nbsp;support<br>
<a href="#WriteTransport">WriteTransport</a>&nbsp;interface.</tt></dd></dl>

<dl><dt>async <a name="AbstractEventLoop-create_connection"><strong>create_connection</strong></a>(self, protocol_factory, host=None, port=None, *, ssl=None, family=0, proto=0, flags=0, sock=None, local_addr=None, server_hostname=None, ssl_handshake_timeout=None, happy_eyeballs_delay=None, interleave=None)</dt></dl>

<dl><dt>async <a name="AbstractEventLoop-create_datagram_endpoint"><strong>create_datagram_endpoint</strong></a>(self, protocol_factory, local_addr=None, remote_addr=None, *, family=0, proto=0, flags=0, reuse_address=None, reuse_port=None, allow_broadcast=None, sock=None)</dt><dd><tt>A&nbsp;coroutine&nbsp;which&nbsp;creates&nbsp;a&nbsp;datagram&nbsp;endpoint.<br>
&nbsp;<br>
This&nbsp;method&nbsp;will&nbsp;try&nbsp;to&nbsp;establish&nbsp;the&nbsp;endpoint&nbsp;in&nbsp;the&nbsp;background.<br>
When&nbsp;successful,&nbsp;the&nbsp;coroutine&nbsp;returns&nbsp;a&nbsp;(transport,&nbsp;protocol)&nbsp;pair.<br>
&nbsp;<br>
protocol_factory&nbsp;must&nbsp;be&nbsp;a&nbsp;callable&nbsp;returning&nbsp;a&nbsp;protocol&nbsp;instance.<br>
&nbsp;<br>
socket&nbsp;family&nbsp;AF_INET,&nbsp;socket.AF_INET6&nbsp;or&nbsp;socket.AF_UNIX&nbsp;depending&nbsp;on<br>
host&nbsp;(or&nbsp;family&nbsp;if&nbsp;specified),&nbsp;socket&nbsp;type&nbsp;SOCK_DGRAM.<br>
&nbsp;<br>
reuse_address&nbsp;tells&nbsp;the&nbsp;kernel&nbsp;to&nbsp;reuse&nbsp;a&nbsp;local&nbsp;socket&nbsp;in<br>
TIME_WAIT&nbsp;state,&nbsp;without&nbsp;waiting&nbsp;for&nbsp;its&nbsp;natural&nbsp;timeout&nbsp;to<br>
expire.&nbsp;If&nbsp;not&nbsp;specified&nbsp;it&nbsp;will&nbsp;automatically&nbsp;be&nbsp;set&nbsp;to&nbsp;True&nbsp;on<br>
UNIX.<br>
&nbsp;<br>
reuse_port&nbsp;tells&nbsp;the&nbsp;kernel&nbsp;to&nbsp;allow&nbsp;this&nbsp;endpoint&nbsp;to&nbsp;be&nbsp;bound&nbsp;to<br>
the&nbsp;same&nbsp;port&nbsp;as&nbsp;other&nbsp;existing&nbsp;endpoints&nbsp;are&nbsp;bound&nbsp;to,&nbsp;so&nbsp;long&nbsp;as<br>
they&nbsp;all&nbsp;set&nbsp;this&nbsp;flag&nbsp;when&nbsp;being&nbsp;created.&nbsp;This&nbsp;option&nbsp;is&nbsp;not<br>
supported&nbsp;on&nbsp;Windows&nbsp;and&nbsp;some&nbsp;UNIX's.&nbsp;If&nbsp;the<br>
:py:data:`~socket.SO_REUSEPORT`&nbsp;constant&nbsp;is&nbsp;not&nbsp;defined&nbsp;then&nbsp;this<br>
capability&nbsp;is&nbsp;unsupported.<br>
&nbsp;<br>
allow_broadcast&nbsp;tells&nbsp;the&nbsp;kernel&nbsp;to&nbsp;allow&nbsp;this&nbsp;endpoint&nbsp;to&nbsp;send<br>
messages&nbsp;to&nbsp;the&nbsp;broadcast&nbsp;address.<br>
&nbsp;<br>
sock&nbsp;can&nbsp;optionally&nbsp;be&nbsp;specified&nbsp;in&nbsp;order&nbsp;to&nbsp;use&nbsp;a&nbsp;preexisting<br>
socket&nbsp;<a href="builtins.html#object">object</a>.</tt></dd></dl>

<dl><dt><a name="AbstractEventLoop-create_future"><strong>create_future</strong></a>(self)</dt></dl>

<dl><dt>async <a name="AbstractEventLoop-create_server"><strong>create_server</strong></a>(self, protocol_factory, host=None, port=None, *, family=&lt;AddressFamily.AF_UNSPEC: 0&gt;, flags=&lt;AddressInfo.AI_PASSIVE: 1&gt;, sock=None, backlog=100, ssl=None, reuse_address=None, reuse_port=None, ssl_handshake_timeout=None, start_serving=True)</dt><dd><tt>A&nbsp;coroutine&nbsp;which&nbsp;creates&nbsp;a&nbsp;TCP&nbsp;server&nbsp;bound&nbsp;to&nbsp;host&nbsp;and&nbsp;port.<br>
&nbsp;<br>
The&nbsp;return&nbsp;value&nbsp;is&nbsp;a&nbsp;Server&nbsp;<a href="builtins.html#object">object</a>&nbsp;which&nbsp;can&nbsp;be&nbsp;used&nbsp;to&nbsp;stop<br>
the&nbsp;service.<br>
&nbsp;<br>
If&nbsp;host&nbsp;is&nbsp;an&nbsp;empty&nbsp;string&nbsp;or&nbsp;None&nbsp;all&nbsp;interfaces&nbsp;are&nbsp;assumed<br>
and&nbsp;a&nbsp;list&nbsp;of&nbsp;multiple&nbsp;sockets&nbsp;will&nbsp;be&nbsp;returned&nbsp;(most&nbsp;likely<br>
one&nbsp;for&nbsp;IPv4&nbsp;and&nbsp;another&nbsp;one&nbsp;for&nbsp;IPv6).&nbsp;The&nbsp;host&nbsp;parameter&nbsp;can&nbsp;also&nbsp;be<br>
a&nbsp;sequence&nbsp;(e.g.&nbsp;list)&nbsp;of&nbsp;hosts&nbsp;to&nbsp;bind&nbsp;to.<br>
&nbsp;<br>
family&nbsp;can&nbsp;be&nbsp;set&nbsp;to&nbsp;either&nbsp;AF_INET&nbsp;or&nbsp;AF_INET6&nbsp;to&nbsp;force&nbsp;the<br>
socket&nbsp;to&nbsp;use&nbsp;IPv4&nbsp;or&nbsp;IPv6.&nbsp;If&nbsp;not&nbsp;set&nbsp;it&nbsp;will&nbsp;be&nbsp;determined<br>
from&nbsp;host&nbsp;(defaults&nbsp;to&nbsp;AF_UNSPEC).<br>
&nbsp;<br>
flags&nbsp;is&nbsp;a&nbsp;bitmask&nbsp;for&nbsp;<a href="#AbstractEventLoop-getaddrinfo">getaddrinfo</a>().<br>
&nbsp;<br>
sock&nbsp;can&nbsp;optionally&nbsp;be&nbsp;specified&nbsp;in&nbsp;order&nbsp;to&nbsp;use&nbsp;a&nbsp;preexisting<br>
socket&nbsp;<a href="builtins.html#object">object</a>.<br>
&nbsp;<br>
backlog&nbsp;is&nbsp;the&nbsp;maximum&nbsp;number&nbsp;of&nbsp;queued&nbsp;connections&nbsp;passed&nbsp;to<br>
listen()&nbsp;(defaults&nbsp;to&nbsp;100).<br>
&nbsp;<br>
ssl&nbsp;can&nbsp;be&nbsp;set&nbsp;to&nbsp;an&nbsp;SSLContext&nbsp;to&nbsp;enable&nbsp;SSL&nbsp;over&nbsp;the<br>
accepted&nbsp;connections.<br>
&nbsp;<br>
reuse_address&nbsp;tells&nbsp;the&nbsp;kernel&nbsp;to&nbsp;reuse&nbsp;a&nbsp;local&nbsp;socket&nbsp;in<br>
TIME_WAIT&nbsp;state,&nbsp;without&nbsp;waiting&nbsp;for&nbsp;its&nbsp;natural&nbsp;timeout&nbsp;to<br>
expire.&nbsp;If&nbsp;not&nbsp;specified&nbsp;will&nbsp;automatically&nbsp;be&nbsp;set&nbsp;to&nbsp;True&nbsp;on<br>
UNIX.<br>
&nbsp;<br>
reuse_port&nbsp;tells&nbsp;the&nbsp;kernel&nbsp;to&nbsp;allow&nbsp;this&nbsp;endpoint&nbsp;to&nbsp;be&nbsp;bound&nbsp;to<br>
the&nbsp;same&nbsp;port&nbsp;as&nbsp;other&nbsp;existing&nbsp;endpoints&nbsp;are&nbsp;bound&nbsp;to,&nbsp;so&nbsp;long&nbsp;as<br>
they&nbsp;all&nbsp;set&nbsp;this&nbsp;flag&nbsp;when&nbsp;being&nbsp;created.&nbsp;This&nbsp;option&nbsp;is&nbsp;not<br>
supported&nbsp;on&nbsp;Windows.<br>
&nbsp;<br>
ssl_handshake_timeout&nbsp;is&nbsp;the&nbsp;time&nbsp;in&nbsp;seconds&nbsp;that&nbsp;an&nbsp;SSL&nbsp;server<br>
will&nbsp;wait&nbsp;for&nbsp;completion&nbsp;of&nbsp;the&nbsp;SSL&nbsp;handshake&nbsp;before&nbsp;aborting&nbsp;the<br>
connection.&nbsp;Default&nbsp;is&nbsp;60s.<br>
&nbsp;<br>
start_serving&nbsp;set&nbsp;to&nbsp;True&nbsp;(default)&nbsp;causes&nbsp;the&nbsp;created&nbsp;server<br>
to&nbsp;start&nbsp;accepting&nbsp;connections&nbsp;immediately.&nbsp;&nbsp;When&nbsp;set&nbsp;to&nbsp;False,<br>
the&nbsp;user&nbsp;should&nbsp;await&nbsp;Server.start_serving()&nbsp;or&nbsp;Server.serve_forever()<br>
to&nbsp;make&nbsp;the&nbsp;server&nbsp;to&nbsp;start&nbsp;accepting&nbsp;connections.</tt></dd></dl>

<dl><dt><a name="AbstractEventLoop-create_task"><strong>create_task</strong></a>(self, coro, *, name=None)</dt></dl>

<dl><dt>async <a name="AbstractEventLoop-create_unix_connection"><strong>create_unix_connection</strong></a>(self, protocol_factory, path=None, *, ssl=None, sock=None, server_hostname=None, ssl_handshake_timeout=None)</dt></dl>

<dl><dt>async <a name="AbstractEventLoop-create_unix_server"><strong>create_unix_server</strong></a>(self, protocol_factory, path=None, *, sock=None, backlog=100, ssl=None, ssl_handshake_timeout=None, start_serving=True)</dt><dd><tt>A&nbsp;coroutine&nbsp;which&nbsp;creates&nbsp;a&nbsp;UNIX&nbsp;Domain&nbsp;Socket&nbsp;server.<br>
&nbsp;<br>
The&nbsp;return&nbsp;value&nbsp;is&nbsp;a&nbsp;Server&nbsp;<a href="builtins.html#object">object</a>,&nbsp;which&nbsp;can&nbsp;be&nbsp;used&nbsp;to&nbsp;stop<br>
the&nbsp;service.<br>
&nbsp;<br>
path&nbsp;is&nbsp;a&nbsp;str,&nbsp;representing&nbsp;a&nbsp;file&nbsp;systsem&nbsp;path&nbsp;to&nbsp;bind&nbsp;the<br>
server&nbsp;socket&nbsp;to.<br>
&nbsp;<br>
sock&nbsp;can&nbsp;optionally&nbsp;be&nbsp;specified&nbsp;in&nbsp;order&nbsp;to&nbsp;use&nbsp;a&nbsp;preexisting<br>
socket&nbsp;<a href="builtins.html#object">object</a>.<br>
&nbsp;<br>
backlog&nbsp;is&nbsp;the&nbsp;maximum&nbsp;number&nbsp;of&nbsp;queued&nbsp;connections&nbsp;passed&nbsp;to<br>
listen()&nbsp;(defaults&nbsp;to&nbsp;100).<br>
&nbsp;<br>
ssl&nbsp;can&nbsp;be&nbsp;set&nbsp;to&nbsp;an&nbsp;SSLContext&nbsp;to&nbsp;enable&nbsp;SSL&nbsp;over&nbsp;the<br>
accepted&nbsp;connections.<br>
&nbsp;<br>
ssl_handshake_timeout&nbsp;is&nbsp;the&nbsp;time&nbsp;in&nbsp;seconds&nbsp;that&nbsp;an&nbsp;SSL&nbsp;server<br>
will&nbsp;wait&nbsp;for&nbsp;the&nbsp;SSL&nbsp;handshake&nbsp;to&nbsp;complete&nbsp;(defaults&nbsp;to&nbsp;60s).<br>
&nbsp;<br>
start_serving&nbsp;set&nbsp;to&nbsp;True&nbsp;(default)&nbsp;causes&nbsp;the&nbsp;created&nbsp;server<br>
to&nbsp;start&nbsp;accepting&nbsp;connections&nbsp;immediately.&nbsp;&nbsp;When&nbsp;set&nbsp;to&nbsp;False,<br>
the&nbsp;user&nbsp;should&nbsp;await&nbsp;Server.start_serving()&nbsp;or&nbsp;Server.serve_forever()<br>
to&nbsp;make&nbsp;the&nbsp;server&nbsp;to&nbsp;start&nbsp;accepting&nbsp;connections.</tt></dd></dl>

<dl><dt><a name="AbstractEventLoop-default_exception_handler"><strong>default_exception_handler</strong></a>(self, context)</dt></dl>

<dl><dt><a name="AbstractEventLoop-get_debug"><strong>get_debug</strong></a>(self)</dt></dl>

<dl><dt><a name="AbstractEventLoop-get_exception_handler"><strong>get_exception_handler</strong></a>(self)</dt></dl>

<dl><dt><a name="AbstractEventLoop-get_task_factory"><strong>get_task_factory</strong></a>(self)</dt></dl>

<dl><dt>async <a name="AbstractEventLoop-getaddrinfo"><strong>getaddrinfo</strong></a>(self, host, port, *, family=0, type=0, proto=0, flags=0)</dt></dl>

<dl><dt>async <a name="AbstractEventLoop-getnameinfo"><strong>getnameinfo</strong></a>(self, sockaddr, flags=0)</dt></dl>

<dl><dt><a name="AbstractEventLoop-is_closed"><strong>is_closed</strong></a>(self)</dt><dd><tt>Returns&nbsp;True&nbsp;if&nbsp;the&nbsp;event&nbsp;loop&nbsp;was&nbsp;closed.</tt></dd></dl>

<dl><dt><a name="AbstractEventLoop-is_running"><strong>is_running</strong></a>(self)</dt><dd><tt>Return&nbsp;whether&nbsp;the&nbsp;event&nbsp;loop&nbsp;is&nbsp;currently&nbsp;running.</tt></dd></dl>

<dl><dt><a name="AbstractEventLoop-remove_reader"><strong>remove_reader</strong></a>(self, fd)</dt></dl>

<dl><dt><a name="AbstractEventLoop-remove_signal_handler"><strong>remove_signal_handler</strong></a>(self, sig)</dt></dl>

<dl><dt><a name="AbstractEventLoop-remove_writer"><strong>remove_writer</strong></a>(self, fd)</dt></dl>

<dl><dt><a name="AbstractEventLoop-run_forever"><strong>run_forever</strong></a>(self)</dt><dd><tt>Run&nbsp;the&nbsp;event&nbsp;loop&nbsp;until&nbsp;<a href="#AbstractEventLoop-stop">stop</a>()&nbsp;is&nbsp;called.</tt></dd></dl>

<dl><dt><a name="AbstractEventLoop-run_in_executor"><strong>run_in_executor</strong></a>(self, executor, func, *args)</dt></dl>

<dl><dt><a name="AbstractEventLoop-run_until_complete"><strong>run_until_complete</strong></a>(self, future)</dt><dd><tt>Run&nbsp;the&nbsp;event&nbsp;loop&nbsp;until&nbsp;a&nbsp;<a href="#Future">Future</a>&nbsp;is&nbsp;done.<br>
&nbsp;<br>
Return&nbsp;the&nbsp;<a href="#Future">Future</a>'s&nbsp;result,&nbsp;or&nbsp;raise&nbsp;its&nbsp;exception.</tt></dd></dl>

<dl><dt>async <a name="AbstractEventLoop-sendfile"><strong>sendfile</strong></a>(self, transport, file, offset=0, count=None, *, fallback=True)</dt><dd><tt>Send&nbsp;a&nbsp;file&nbsp;through&nbsp;a&nbsp;transport.<br>
&nbsp;<br>
Return&nbsp;an&nbsp;amount&nbsp;of&nbsp;sent&nbsp;bytes.</tt></dd></dl>

<dl><dt><a name="AbstractEventLoop-set_debug"><strong>set_debug</strong></a>(self, enabled)</dt></dl>

<dl><dt><a name="AbstractEventLoop-set_default_executor"><strong>set_default_executor</strong></a>(self, executor)</dt></dl>

<dl><dt><a name="AbstractEventLoop-set_exception_handler"><strong>set_exception_handler</strong></a>(self, handler)</dt></dl>

<dl><dt><a name="AbstractEventLoop-set_task_factory"><strong>set_task_factory</strong></a>(self, factory)</dt></dl>

<dl><dt>async <a name="AbstractEventLoop-shutdown_asyncgens"><strong>shutdown_asyncgens</strong></a>(self)</dt><dd><tt>Shutdown&nbsp;all&nbsp;active&nbsp;asynchronous&nbsp;generators.</tt></dd></dl>

<dl><dt>async <a name="AbstractEventLoop-sock_accept"><strong>sock_accept</strong></a>(self, sock)</dt></dl>

<dl><dt>async <a name="AbstractEventLoop-sock_connect"><strong>sock_connect</strong></a>(self, sock, address)</dt></dl>

<dl><dt>async <a name="AbstractEventLoop-sock_recv"><strong>sock_recv</strong></a>(self, sock, nbytes)</dt></dl>

<dl><dt>async <a name="AbstractEventLoop-sock_recv_into"><strong>sock_recv_into</strong></a>(self, sock, buf)</dt></dl>

<dl><dt>async <a name="AbstractEventLoop-sock_sendall"><strong>sock_sendall</strong></a>(self, sock, data)</dt></dl>

<dl><dt>async <a name="AbstractEventLoop-sock_sendfile"><strong>sock_sendfile</strong></a>(self, sock, file, offset=0, count=None, *, fallback=None)</dt></dl>

<dl><dt>async <a name="AbstractEventLoop-start_tls"><strong>start_tls</strong></a>(self, transport, protocol, sslcontext, *, server_side=False, server_hostname=None, ssl_handshake_timeout=None)</dt><dd><tt>Upgrade&nbsp;a&nbsp;transport&nbsp;to&nbsp;TLS.<br>
&nbsp;<br>
Return&nbsp;a&nbsp;new&nbsp;transport&nbsp;that&nbsp;*protocol*&nbsp;should&nbsp;start&nbsp;using<br>
immediately.</tt></dd></dl>

<dl><dt><a name="AbstractEventLoop-stop"><strong>stop</strong></a>(self)</dt><dd><tt>Stop&nbsp;the&nbsp;event&nbsp;loop&nbsp;as&nbsp;soon&nbsp;as&nbsp;reasonable.<br>
&nbsp;<br>
Exactly&nbsp;how&nbsp;soon&nbsp;that&nbsp;is&nbsp;may&nbsp;depend&nbsp;on&nbsp;the&nbsp;implementation,&nbsp;but<br>
no&nbsp;more&nbsp;I/O&nbsp;callbacks&nbsp;should&nbsp;be&nbsp;scheduled.</tt></dd></dl>

<dl><dt>async <a name="AbstractEventLoop-subprocess_exec"><strong>subprocess_exec</strong></a>(self, protocol_factory, *args, stdin=-1, stdout=-1, stderr=-1, **kwargs)</dt></dl>

<dl><dt>async <a name="AbstractEventLoop-subprocess_shell"><strong>subprocess_shell</strong></a>(self, protocol_factory, cmd, *, stdin=-1, stdout=-1, stderr=-1, **kwargs)</dt></dl>

<dl><dt><a name="AbstractEventLoop-time"><strong>time</strong></a>(self)</dt></dl>

<hr>
Data descriptors defined here:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="AbstractEventLoopPolicy">class <strong>AbstractEventLoopPolicy</strong></a>(<a href="builtins.html#object">builtins.object</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt>Abstract&nbsp;policy&nbsp;for&nbsp;accessing&nbsp;the&nbsp;event&nbsp;loop.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%">Methods defined here:<br>
<dl><dt><a name="AbstractEventLoopPolicy-get_child_watcher"><strong>get_child_watcher</strong></a>(self)</dt><dd><tt>Get&nbsp;the&nbsp;watcher&nbsp;for&nbsp;child&nbsp;processes.</tt></dd></dl>

<dl><dt><a name="AbstractEventLoopPolicy-get_event_loop"><strong>get_event_loop</strong></a>(self)</dt><dd><tt>Get&nbsp;the&nbsp;event&nbsp;loop&nbsp;for&nbsp;the&nbsp;current&nbsp;context.<br>
&nbsp;<br>
Returns&nbsp;an&nbsp;event&nbsp;loop&nbsp;<a href="builtins.html#object">object</a>&nbsp;implementing&nbsp;the&nbsp;<a href="#BaseEventLoop">BaseEventLoop</a>&nbsp;interface,<br>
or&nbsp;raises&nbsp;an&nbsp;exception&nbsp;in&nbsp;case&nbsp;no&nbsp;event&nbsp;loop&nbsp;has&nbsp;been&nbsp;set&nbsp;for&nbsp;the<br>
current&nbsp;context&nbsp;and&nbsp;the&nbsp;current&nbsp;policy&nbsp;does&nbsp;not&nbsp;specify&nbsp;to&nbsp;create&nbsp;one.<br>
&nbsp;<br>
It&nbsp;should&nbsp;never&nbsp;return&nbsp;None.</tt></dd></dl>

<dl><dt><a name="AbstractEventLoopPolicy-new_event_loop"><strong>new_event_loop</strong></a>(self)</dt><dd><tt>Create&nbsp;and&nbsp;return&nbsp;a&nbsp;new&nbsp;event&nbsp;loop&nbsp;<a href="builtins.html#object">object</a>&nbsp;according&nbsp;to&nbsp;this<br>
policy's&nbsp;rules.&nbsp;If&nbsp;there's&nbsp;need&nbsp;to&nbsp;set&nbsp;this&nbsp;loop&nbsp;as&nbsp;the&nbsp;event&nbsp;loop&nbsp;for<br>
the&nbsp;current&nbsp;context,&nbsp;set_event_loop&nbsp;must&nbsp;be&nbsp;called&nbsp;explicitly.</tt></dd></dl>

<dl><dt><a name="AbstractEventLoopPolicy-set_child_watcher"><strong>set_child_watcher</strong></a>(self, watcher)</dt><dd><tt>Set&nbsp;the&nbsp;watcher&nbsp;for&nbsp;child&nbsp;processes.</tt></dd></dl>

<dl><dt><a name="AbstractEventLoopPolicy-set_event_loop"><strong>set_event_loop</strong></a>(self, loop)</dt><dd><tt>Set&nbsp;the&nbsp;event&nbsp;loop&nbsp;for&nbsp;the&nbsp;current&nbsp;context&nbsp;to&nbsp;loop.</tt></dd></dl>

<hr>
Data descriptors defined here:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="AbstractServer">class <strong>AbstractServer</strong></a>(<a href="builtins.html#object">builtins.object</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt>Abstract&nbsp;server&nbsp;returned&nbsp;by&nbsp;create_server().<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%">Methods defined here:<br>
<dl><dt>async <a name="AbstractServer-__aenter__"><strong>__aenter__</strong></a>(self)</dt></dl>

<dl><dt>async <a name="AbstractServer-__aexit__"><strong>__aexit__</strong></a>(self, *exc)</dt></dl>

<dl><dt><a name="AbstractServer-close"><strong>close</strong></a>(self)</dt><dd><tt>Stop&nbsp;serving.&nbsp;&nbsp;This&nbsp;leaves&nbsp;existing&nbsp;connections&nbsp;open.</tt></dd></dl>

<dl><dt><a name="AbstractServer-get_loop"><strong>get_loop</strong></a>(self)</dt><dd><tt>Get&nbsp;the&nbsp;event&nbsp;loop&nbsp;the&nbsp;Server&nbsp;<a href="builtins.html#object">object</a>&nbsp;is&nbsp;attached&nbsp;to.</tt></dd></dl>

<dl><dt><a name="AbstractServer-is_serving"><strong>is_serving</strong></a>(self)</dt><dd><tt>Return&nbsp;True&nbsp;if&nbsp;the&nbsp;server&nbsp;is&nbsp;accepting&nbsp;connections.</tt></dd></dl>

<dl><dt>async <a name="AbstractServer-serve_forever"><strong>serve_forever</strong></a>(self)</dt><dd><tt>Start&nbsp;accepting&nbsp;connections&nbsp;until&nbsp;the&nbsp;coroutine&nbsp;is&nbsp;cancelled.<br>
&nbsp;<br>
The&nbsp;server&nbsp;is&nbsp;closed&nbsp;when&nbsp;the&nbsp;coroutine&nbsp;is&nbsp;cancelled.</tt></dd></dl>

<dl><dt>async <a name="AbstractServer-start_serving"><strong>start_serving</strong></a>(self)</dt><dd><tt>Start&nbsp;accepting&nbsp;connections.<br>
&nbsp;<br>
This&nbsp;method&nbsp;is&nbsp;idempotent,&nbsp;so&nbsp;it&nbsp;can&nbsp;be&nbsp;called&nbsp;when<br>
the&nbsp;server&nbsp;is&nbsp;already&nbsp;being&nbsp;serving.</tt></dd></dl>

<dl><dt>async <a name="AbstractServer-wait_closed"><strong>wait_closed</strong></a>(self)</dt><dd><tt>Coroutine&nbsp;to&nbsp;wait&nbsp;until&nbsp;service&nbsp;is&nbsp;closed.</tt></dd></dl>

<hr>
Data descriptors defined here:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="BaseEventLoop">class <strong>BaseEventLoop</strong></a>(<a href="asyncio.events.html#AbstractEventLoop">asyncio.events.AbstractEventLoop</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt>Abstract&nbsp;event&nbsp;loop.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="asyncio.base_events.html#BaseEventLoop">BaseEventLoop</a></dd>
<dd><a href="asyncio.events.html#AbstractEventLoop">asyncio.events.AbstractEventLoop</a></dd>
<dd><a href="builtins.html#object">builtins.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="BaseEventLoop-__del__"><strong>__del__</strong></a>(self, _warn=&lt;built-in function warn&gt;)</dt></dl>

<dl><dt><a name="BaseEventLoop-__init__"><strong>__init__</strong></a>(self)</dt><dd><tt>Initialize&nbsp;self.&nbsp;&nbsp;See&nbsp;help(type(self))&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<dl><dt><a name="BaseEventLoop-__repr__"><strong>__repr__</strong></a>(self)</dt><dd><tt>Return&nbsp;repr(self).</tt></dd></dl>

<dl><dt><a name="BaseEventLoop-call_at"><strong>call_at</strong></a>(self, when, callback, *args, context=None)</dt><dd><tt>Like&nbsp;<a href="#BaseEventLoop-call_later">call_later</a>(),&nbsp;but&nbsp;uses&nbsp;an&nbsp;absolute&nbsp;time.<br>
&nbsp;<br>
Absolute&nbsp;time&nbsp;corresponds&nbsp;to&nbsp;the&nbsp;event&nbsp;loop's&nbsp;<a href="#BaseEventLoop-time">time</a>()&nbsp;method.</tt></dd></dl>

<dl><dt><a name="BaseEventLoop-call_exception_handler"><strong>call_exception_handler</strong></a>(self, context)</dt><dd><tt>Call&nbsp;the&nbsp;current&nbsp;event&nbsp;loop's&nbsp;exception&nbsp;handler.<br>
&nbsp;<br>
The&nbsp;context&nbsp;argument&nbsp;is&nbsp;a&nbsp;dict&nbsp;containing&nbsp;the&nbsp;following&nbsp;keys:<br>
&nbsp;<br>
-&nbsp;'message':&nbsp;Error&nbsp;message;<br>
-&nbsp;'exception'&nbsp;(optional):&nbsp;<a href="builtins.html#Exception">Exception</a>&nbsp;<a href="builtins.html#object">object</a>;<br>
-&nbsp;'future'&nbsp;(optional):&nbsp;<a href="#Future">Future</a>&nbsp;instance;<br>
-&nbsp;'task'&nbsp;(optional):&nbsp;<a href="#Task">Task</a>&nbsp;instance;<br>
-&nbsp;'handle'&nbsp;(optional):&nbsp;<a href="#Handle">Handle</a>&nbsp;instance;<br>
-&nbsp;'protocol'&nbsp;(optional):&nbsp;<a href="#Protocol">Protocol</a>&nbsp;instance;<br>
-&nbsp;'transport'&nbsp;(optional):&nbsp;<a href="#Transport">Transport</a>&nbsp;instance;<br>
-&nbsp;'socket'&nbsp;(optional):&nbsp;Socket&nbsp;instance;<br>
-&nbsp;'asyncgen'&nbsp;(optional):&nbsp;Asynchronous&nbsp;generator&nbsp;that&nbsp;caused<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;exception.<br>
&nbsp;<br>
New&nbsp;keys&nbsp;maybe&nbsp;introduced&nbsp;in&nbsp;the&nbsp;future.<br>
&nbsp;<br>
Note:&nbsp;do&nbsp;not&nbsp;overload&nbsp;this&nbsp;method&nbsp;in&nbsp;an&nbsp;event&nbsp;loop&nbsp;subclass.<br>
For&nbsp;custom&nbsp;exception&nbsp;handling,&nbsp;use&nbsp;the<br>
`<a href="#BaseEventLoop-set_exception_handler">set_exception_handler</a>()`&nbsp;method.</tt></dd></dl>

<dl><dt><a name="BaseEventLoop-call_later"><strong>call_later</strong></a>(self, delay, callback, *args, context=None)</dt><dd><tt>Arrange&nbsp;for&nbsp;a&nbsp;callback&nbsp;to&nbsp;be&nbsp;called&nbsp;at&nbsp;a&nbsp;given&nbsp;time.<br>
&nbsp;<br>
Return&nbsp;a&nbsp;<a href="#Handle">Handle</a>:&nbsp;an&nbsp;opaque&nbsp;<a href="builtins.html#object">object</a>&nbsp;with&nbsp;a&nbsp;cancel()&nbsp;method&nbsp;that<br>
can&nbsp;be&nbsp;used&nbsp;to&nbsp;cancel&nbsp;the&nbsp;call.<br>
&nbsp;<br>
The&nbsp;delay&nbsp;can&nbsp;be&nbsp;an&nbsp;int&nbsp;or&nbsp;float,&nbsp;expressed&nbsp;in&nbsp;seconds.&nbsp;&nbsp;It&nbsp;is<br>
always&nbsp;relative&nbsp;to&nbsp;the&nbsp;current&nbsp;time.<br>
&nbsp;<br>
Each&nbsp;callback&nbsp;will&nbsp;be&nbsp;called&nbsp;exactly&nbsp;once.&nbsp;&nbsp;If&nbsp;two&nbsp;callbacks<br>
are&nbsp;scheduled&nbsp;for&nbsp;exactly&nbsp;the&nbsp;same&nbsp;time,&nbsp;it&nbsp;undefined&nbsp;which<br>
will&nbsp;be&nbsp;called&nbsp;first.<br>
&nbsp;<br>
Any&nbsp;positional&nbsp;arguments&nbsp;after&nbsp;the&nbsp;callback&nbsp;will&nbsp;be&nbsp;passed&nbsp;to<br>
the&nbsp;callback&nbsp;when&nbsp;it&nbsp;is&nbsp;called.</tt></dd></dl>

<dl><dt><a name="BaseEventLoop-call_soon"><strong>call_soon</strong></a>(self, callback, *args, context=None)</dt><dd><tt>Arrange&nbsp;for&nbsp;a&nbsp;callback&nbsp;to&nbsp;be&nbsp;called&nbsp;as&nbsp;soon&nbsp;as&nbsp;possible.<br>
&nbsp;<br>
This&nbsp;operates&nbsp;as&nbsp;a&nbsp;FIFO&nbsp;queue:&nbsp;callbacks&nbsp;are&nbsp;called&nbsp;in&nbsp;the<br>
order&nbsp;in&nbsp;which&nbsp;they&nbsp;are&nbsp;registered.&nbsp;&nbsp;Each&nbsp;callback&nbsp;will&nbsp;be<br>
called&nbsp;exactly&nbsp;once.<br>
&nbsp;<br>
Any&nbsp;positional&nbsp;arguments&nbsp;after&nbsp;the&nbsp;callback&nbsp;will&nbsp;be&nbsp;passed&nbsp;to<br>
the&nbsp;callback&nbsp;when&nbsp;it&nbsp;is&nbsp;called.</tt></dd></dl>

<dl><dt><a name="BaseEventLoop-call_soon_threadsafe"><strong>call_soon_threadsafe</strong></a>(self, callback, *args, context=None)</dt><dd><tt>Like&nbsp;<a href="#BaseEventLoop-call_soon">call_soon</a>(),&nbsp;but&nbsp;thread-safe.</tt></dd></dl>

<dl><dt><a name="BaseEventLoop-close"><strong>close</strong></a>(self)</dt><dd><tt>Close&nbsp;the&nbsp;event&nbsp;loop.<br>
&nbsp;<br>
This&nbsp;clears&nbsp;the&nbsp;queues&nbsp;and&nbsp;shuts&nbsp;down&nbsp;the&nbsp;executor,<br>
but&nbsp;does&nbsp;not&nbsp;wait&nbsp;for&nbsp;the&nbsp;executor&nbsp;to&nbsp;finish.<br>
&nbsp;<br>
The&nbsp;event&nbsp;loop&nbsp;must&nbsp;not&nbsp;be&nbsp;running.</tt></dd></dl>

<dl><dt>async <a name="BaseEventLoop-connect_accepted_socket"><strong>connect_accepted_socket</strong></a>(self, protocol_factory, sock, *, ssl=None, ssl_handshake_timeout=None)</dt><dd><tt><a href="#Handle">Handle</a>&nbsp;an&nbsp;accepted&nbsp;connection.<br>
&nbsp;<br>
This&nbsp;is&nbsp;used&nbsp;by&nbsp;servers&nbsp;that&nbsp;accept&nbsp;connections&nbsp;outside&nbsp;of<br>
asyncio&nbsp;but&nbsp;that&nbsp;use&nbsp;asyncio&nbsp;to&nbsp;handle&nbsp;connections.<br>
&nbsp;<br>
This&nbsp;method&nbsp;is&nbsp;a&nbsp;coroutine.&nbsp;&nbsp;When&nbsp;completed,&nbsp;the&nbsp;coroutine<br>
returns&nbsp;a&nbsp;(transport,&nbsp;protocol)&nbsp;pair.</tt></dd></dl>

<dl><dt>async <a name="BaseEventLoop-connect_read_pipe"><strong>connect_read_pipe</strong></a>(self, protocol_factory, pipe)</dt><dd><tt>Register&nbsp;read&nbsp;pipe&nbsp;in&nbsp;event&nbsp;loop.&nbsp;Set&nbsp;the&nbsp;pipe&nbsp;to&nbsp;non-blocking&nbsp;mode.<br>
&nbsp;<br>
protocol_factory&nbsp;should&nbsp;instantiate&nbsp;<a href="builtins.html#object">object</a>&nbsp;with&nbsp;<a href="#Protocol">Protocol</a>&nbsp;interface.<br>
pipe&nbsp;is&nbsp;a&nbsp;file-like&nbsp;<a href="builtins.html#object">object</a>.<br>
Return&nbsp;pair&nbsp;(transport,&nbsp;protocol),&nbsp;where&nbsp;transport&nbsp;supports&nbsp;the<br>
<a href="#ReadTransport">ReadTransport</a>&nbsp;interface.</tt></dd></dl>

<dl><dt>async <a name="BaseEventLoop-connect_write_pipe"><strong>connect_write_pipe</strong></a>(self, protocol_factory, pipe)</dt><dd><tt>Register&nbsp;write&nbsp;pipe&nbsp;in&nbsp;event&nbsp;loop.<br>
&nbsp;<br>
protocol_factory&nbsp;should&nbsp;instantiate&nbsp;<a href="builtins.html#object">object</a>&nbsp;with&nbsp;<a href="#BaseProtocol">BaseProtocol</a>&nbsp;interface.<br>
Pipe&nbsp;is&nbsp;file-like&nbsp;<a href="builtins.html#object">object</a>&nbsp;already&nbsp;switched&nbsp;to&nbsp;nonblocking.<br>
Return&nbsp;pair&nbsp;(transport,&nbsp;protocol),&nbsp;where&nbsp;transport&nbsp;support<br>
<a href="#WriteTransport">WriteTransport</a>&nbsp;interface.</tt></dd></dl>

<dl><dt>async <a name="BaseEventLoop-create_connection"><strong>create_connection</strong></a>(self, protocol_factory, host=None, port=None, *, ssl=None, family=0, proto=0, flags=0, sock=None, local_addr=None, server_hostname=None, ssl_handshake_timeout=None, happy_eyeballs_delay=None, interleave=None)</dt><dd><tt>Connect&nbsp;to&nbsp;a&nbsp;TCP&nbsp;server.<br>
&nbsp;<br>
Create&nbsp;a&nbsp;streaming&nbsp;transport&nbsp;connection&nbsp;to&nbsp;a&nbsp;given&nbsp;Internet&nbsp;host&nbsp;and<br>
port:&nbsp;socket&nbsp;family&nbsp;AF_INET&nbsp;or&nbsp;socket.AF_INET6&nbsp;depending&nbsp;on&nbsp;host&nbsp;(or<br>
family&nbsp;if&nbsp;specified),&nbsp;socket&nbsp;type&nbsp;SOCK_STREAM.&nbsp;protocol_factory&nbsp;must&nbsp;be<br>
a&nbsp;callable&nbsp;returning&nbsp;a&nbsp;protocol&nbsp;instance.<br>
&nbsp;<br>
This&nbsp;method&nbsp;is&nbsp;a&nbsp;coroutine&nbsp;which&nbsp;will&nbsp;try&nbsp;to&nbsp;establish&nbsp;the&nbsp;connection<br>
in&nbsp;the&nbsp;background.&nbsp;&nbsp;When&nbsp;successful,&nbsp;the&nbsp;coroutine&nbsp;returns&nbsp;a<br>
(transport,&nbsp;protocol)&nbsp;pair.</tt></dd></dl>

<dl><dt>async <a name="BaseEventLoop-create_datagram_endpoint"><strong>create_datagram_endpoint</strong></a>(self, protocol_factory, local_addr=None, remote_addr=None, *, family=0, proto=0, flags=0, reuse_address=&lt;object object at 0x000001ED9C15F660&gt;, reuse_port=None, allow_broadcast=None, sock=None)</dt><dd><tt>Create&nbsp;datagram&nbsp;connection.</tt></dd></dl>

<dl><dt><a name="BaseEventLoop-create_future"><strong>create_future</strong></a>(self)</dt><dd><tt>Create&nbsp;a&nbsp;<a href="#Future">Future</a>&nbsp;<a href="builtins.html#object">object</a>&nbsp;attached&nbsp;to&nbsp;the&nbsp;loop.</tt></dd></dl>

<dl><dt>async <a name="BaseEventLoop-create_server"><strong>create_server</strong></a>(self, protocol_factory, host=None, port=None, *, family=&lt;AddressFamily.AF_UNSPEC: 0&gt;, flags=&lt;AddressInfo.AI_PASSIVE: 1&gt;, sock=None, backlog=100, ssl=None, reuse_address=None, reuse_port=None, ssl_handshake_timeout=None, start_serving=True)</dt><dd><tt>Create&nbsp;a&nbsp;TCP&nbsp;server.<br>
&nbsp;<br>
The&nbsp;host&nbsp;parameter&nbsp;can&nbsp;be&nbsp;a&nbsp;string,&nbsp;in&nbsp;that&nbsp;case&nbsp;the&nbsp;TCP&nbsp;server&nbsp;is<br>
bound&nbsp;to&nbsp;host&nbsp;and&nbsp;port.<br>
&nbsp;<br>
The&nbsp;host&nbsp;parameter&nbsp;can&nbsp;also&nbsp;be&nbsp;a&nbsp;sequence&nbsp;of&nbsp;strings&nbsp;and&nbsp;in&nbsp;that&nbsp;case<br>
the&nbsp;TCP&nbsp;server&nbsp;is&nbsp;bound&nbsp;to&nbsp;all&nbsp;hosts&nbsp;of&nbsp;the&nbsp;sequence.&nbsp;If&nbsp;a&nbsp;host<br>
appears&nbsp;multiple&nbsp;times&nbsp;(possibly&nbsp;indirectly&nbsp;e.g.&nbsp;when&nbsp;hostnames<br>
resolve&nbsp;to&nbsp;the&nbsp;same&nbsp;IP&nbsp;address),&nbsp;the&nbsp;server&nbsp;is&nbsp;only&nbsp;bound&nbsp;once&nbsp;to&nbsp;that<br>
host.<br>
&nbsp;<br>
Return&nbsp;a&nbsp;Server&nbsp;<a href="builtins.html#object">object</a>&nbsp;which&nbsp;can&nbsp;be&nbsp;used&nbsp;to&nbsp;stop&nbsp;the&nbsp;service.<br>
&nbsp;<br>
This&nbsp;method&nbsp;is&nbsp;a&nbsp;coroutine.</tt></dd></dl>

<dl><dt><a name="BaseEventLoop-create_task"><strong>create_task</strong></a>(self, coro, *, name=None)</dt><dd><tt>Schedule&nbsp;a&nbsp;coroutine&nbsp;<a href="builtins.html#object">object</a>.<br>
&nbsp;<br>
Return&nbsp;a&nbsp;task&nbsp;<a href="builtins.html#object">object</a>.</tt></dd></dl>

<dl><dt><a name="BaseEventLoop-default_exception_handler"><strong>default_exception_handler</strong></a>(self, context)</dt><dd><tt>Default&nbsp;exception&nbsp;handler.<br>
&nbsp;<br>
This&nbsp;is&nbsp;called&nbsp;when&nbsp;an&nbsp;exception&nbsp;occurs&nbsp;and&nbsp;no&nbsp;exception<br>
handler&nbsp;is&nbsp;set,&nbsp;and&nbsp;can&nbsp;be&nbsp;called&nbsp;by&nbsp;a&nbsp;custom&nbsp;exception<br>
handler&nbsp;that&nbsp;wants&nbsp;to&nbsp;defer&nbsp;to&nbsp;the&nbsp;default&nbsp;behavior.<br>
&nbsp;<br>
This&nbsp;default&nbsp;handler&nbsp;logs&nbsp;the&nbsp;error&nbsp;message&nbsp;and&nbsp;other<br>
context-dependent&nbsp;information.&nbsp;&nbsp;In&nbsp;debug&nbsp;mode,&nbsp;a&nbsp;truncated<br>
stack&nbsp;trace&nbsp;is&nbsp;also&nbsp;appended&nbsp;showing&nbsp;where&nbsp;the&nbsp;given&nbsp;<a href="builtins.html#object">object</a><br>
(e.g.&nbsp;a&nbsp;handle&nbsp;or&nbsp;future&nbsp;or&nbsp;task)&nbsp;was&nbsp;created,&nbsp;if&nbsp;any.<br>
&nbsp;<br>
The&nbsp;context&nbsp;parameter&nbsp;has&nbsp;the&nbsp;same&nbsp;meaning&nbsp;as&nbsp;in<br>
`<a href="#BaseEventLoop-call_exception_handler">call_exception_handler</a>()`.</tt></dd></dl>

<dl><dt><a name="BaseEventLoop-get_debug"><strong>get_debug</strong></a>(self)</dt></dl>

<dl><dt><a name="BaseEventLoop-get_exception_handler"><strong>get_exception_handler</strong></a>(self)</dt><dd><tt>Return&nbsp;an&nbsp;exception&nbsp;handler,&nbsp;or&nbsp;None&nbsp;if&nbsp;the&nbsp;default&nbsp;one&nbsp;is&nbsp;in&nbsp;use.</tt></dd></dl>

<dl><dt><a name="BaseEventLoop-get_task_factory"><strong>get_task_factory</strong></a>(self)</dt><dd><tt>Return&nbsp;a&nbsp;task&nbsp;factory,&nbsp;or&nbsp;None&nbsp;if&nbsp;the&nbsp;default&nbsp;one&nbsp;is&nbsp;in&nbsp;use.</tt></dd></dl>

<dl><dt>async <a name="BaseEventLoop-getaddrinfo"><strong>getaddrinfo</strong></a>(self, host, port, *, family=0, type=0, proto=0, flags=0)</dt></dl>

<dl><dt>async <a name="BaseEventLoop-getnameinfo"><strong>getnameinfo</strong></a>(self, sockaddr, flags=0)</dt></dl>

<dl><dt><a name="BaseEventLoop-is_closed"><strong>is_closed</strong></a>(self)</dt><dd><tt>Returns&nbsp;True&nbsp;if&nbsp;the&nbsp;event&nbsp;loop&nbsp;was&nbsp;closed.</tt></dd></dl>

<dl><dt><a name="BaseEventLoop-is_running"><strong>is_running</strong></a>(self)</dt><dd><tt>Returns&nbsp;True&nbsp;if&nbsp;the&nbsp;event&nbsp;loop&nbsp;is&nbsp;running.</tt></dd></dl>

<dl><dt><a name="BaseEventLoop-run_forever"><strong>run_forever</strong></a>(self)</dt><dd><tt>Run&nbsp;until&nbsp;<a href="#BaseEventLoop-stop">stop</a>()&nbsp;is&nbsp;called.</tt></dd></dl>

<dl><dt><a name="BaseEventLoop-run_in_executor"><strong>run_in_executor</strong></a>(self, executor, func, *args)</dt></dl>

<dl><dt><a name="BaseEventLoop-run_until_complete"><strong>run_until_complete</strong></a>(self, future)</dt><dd><tt>Run&nbsp;until&nbsp;the&nbsp;<a href="#Future">Future</a>&nbsp;is&nbsp;done.<br>
&nbsp;<br>
If&nbsp;the&nbsp;argument&nbsp;is&nbsp;a&nbsp;coroutine,&nbsp;it&nbsp;is&nbsp;wrapped&nbsp;in&nbsp;a&nbsp;<a href="#Task">Task</a>.<br>
&nbsp;<br>
WARNING:&nbsp;It&nbsp;would&nbsp;be&nbsp;disastrous&nbsp;to&nbsp;call&nbsp;<a href="#BaseEventLoop-run_until_complete">run_until_complete</a>()<br>
with&nbsp;the&nbsp;same&nbsp;coroutine&nbsp;twice&nbsp;--&nbsp;it&nbsp;would&nbsp;wrap&nbsp;it&nbsp;in&nbsp;two<br>
different&nbsp;Tasks&nbsp;and&nbsp;that&nbsp;can't&nbsp;be&nbsp;good.<br>
&nbsp;<br>
Return&nbsp;the&nbsp;<a href="#Future">Future</a>'s&nbsp;result,&nbsp;or&nbsp;raise&nbsp;its&nbsp;exception.</tt></dd></dl>

<dl><dt>async <a name="BaseEventLoop-sendfile"><strong>sendfile</strong></a>(self, transport, file, offset=0, count=None, *, fallback=True)</dt><dd><tt>Send&nbsp;a&nbsp;file&nbsp;to&nbsp;transport.<br>
&nbsp;<br>
Return&nbsp;the&nbsp;total&nbsp;number&nbsp;of&nbsp;bytes&nbsp;which&nbsp;were&nbsp;sent.<br>
&nbsp;<br>
The&nbsp;method&nbsp;uses&nbsp;high-performance&nbsp;os.sendfile&nbsp;if&nbsp;available.<br>
&nbsp;<br>
file&nbsp;must&nbsp;be&nbsp;a&nbsp;regular&nbsp;file&nbsp;<a href="builtins.html#object">object</a>&nbsp;opened&nbsp;in&nbsp;binary&nbsp;mode.<br>
&nbsp;<br>
offset&nbsp;tells&nbsp;from&nbsp;where&nbsp;to&nbsp;start&nbsp;reading&nbsp;the&nbsp;file.&nbsp;If&nbsp;specified,<br>
count&nbsp;is&nbsp;the&nbsp;total&nbsp;number&nbsp;of&nbsp;bytes&nbsp;to&nbsp;transmit&nbsp;as&nbsp;opposed&nbsp;to<br>
sending&nbsp;the&nbsp;file&nbsp;until&nbsp;EOF&nbsp;is&nbsp;reached.&nbsp;File&nbsp;position&nbsp;is&nbsp;updated&nbsp;on<br>
return&nbsp;or&nbsp;also&nbsp;in&nbsp;case&nbsp;of&nbsp;error&nbsp;in&nbsp;which&nbsp;case&nbsp;file.tell()<br>
can&nbsp;be&nbsp;used&nbsp;to&nbsp;figure&nbsp;out&nbsp;the&nbsp;number&nbsp;of&nbsp;bytes<br>
which&nbsp;were&nbsp;sent.<br>
&nbsp;<br>
fallback&nbsp;set&nbsp;to&nbsp;True&nbsp;makes&nbsp;asyncio&nbsp;to&nbsp;manually&nbsp;read&nbsp;and&nbsp;send<br>
the&nbsp;file&nbsp;when&nbsp;the&nbsp;platform&nbsp;does&nbsp;not&nbsp;support&nbsp;the&nbsp;sendfile&nbsp;syscall<br>
(e.g.&nbsp;Windows&nbsp;or&nbsp;SSL&nbsp;socket&nbsp;on&nbsp;Unix).<br>
&nbsp;<br>
Raise&nbsp;<a href="#SendfileNotAvailableError">SendfileNotAvailableError</a>&nbsp;if&nbsp;the&nbsp;system&nbsp;does&nbsp;not&nbsp;support<br>
sendfile&nbsp;syscall&nbsp;and&nbsp;fallback&nbsp;is&nbsp;False.</tt></dd></dl>

<dl><dt><a name="BaseEventLoop-set_debug"><strong>set_debug</strong></a>(self, enabled)</dt></dl>

<dl><dt><a name="BaseEventLoop-set_default_executor"><strong>set_default_executor</strong></a>(self, executor)</dt></dl>

<dl><dt><a name="BaseEventLoop-set_exception_handler"><strong>set_exception_handler</strong></a>(self, handler)</dt><dd><tt>Set&nbsp;handler&nbsp;as&nbsp;the&nbsp;new&nbsp;event&nbsp;loop&nbsp;exception&nbsp;handler.<br>
&nbsp;<br>
If&nbsp;handler&nbsp;is&nbsp;None,&nbsp;the&nbsp;default&nbsp;exception&nbsp;handler&nbsp;will<br>
be&nbsp;set.<br>
&nbsp;<br>
If&nbsp;handler&nbsp;is&nbsp;a&nbsp;callable&nbsp;<a href="builtins.html#object">object</a>,&nbsp;it&nbsp;should&nbsp;have&nbsp;a<br>
signature&nbsp;matching&nbsp;'(loop,&nbsp;context)',&nbsp;where&nbsp;'loop'<br>
will&nbsp;be&nbsp;a&nbsp;reference&nbsp;to&nbsp;the&nbsp;active&nbsp;event&nbsp;loop,&nbsp;'context'<br>
will&nbsp;be&nbsp;a&nbsp;dict&nbsp;<a href="builtins.html#object">object</a>&nbsp;(see&nbsp;`<a href="#BaseEventLoop-call_exception_handler">call_exception_handler</a>()`<br>
documentation&nbsp;for&nbsp;details&nbsp;about&nbsp;context).</tt></dd></dl>

<dl><dt><a name="BaseEventLoop-set_task_factory"><strong>set_task_factory</strong></a>(self, factory)</dt><dd><tt>Set&nbsp;a&nbsp;task&nbsp;factory&nbsp;that&nbsp;will&nbsp;be&nbsp;used&nbsp;by&nbsp;loop.<a href="#BaseEventLoop-create_task">create_task</a>().<br>
&nbsp;<br>
If&nbsp;factory&nbsp;is&nbsp;None&nbsp;the&nbsp;default&nbsp;task&nbsp;factory&nbsp;will&nbsp;be&nbsp;set.<br>
&nbsp;<br>
If&nbsp;factory&nbsp;is&nbsp;a&nbsp;callable,&nbsp;it&nbsp;should&nbsp;have&nbsp;a&nbsp;signature&nbsp;matching<br>
'(loop,&nbsp;coro)',&nbsp;where&nbsp;'loop'&nbsp;will&nbsp;be&nbsp;a&nbsp;reference&nbsp;to&nbsp;the&nbsp;active<br>
event&nbsp;loop,&nbsp;'coro'&nbsp;will&nbsp;be&nbsp;a&nbsp;coroutine&nbsp;<a href="builtins.html#object">object</a>.&nbsp;&nbsp;The&nbsp;callable<br>
must&nbsp;return&nbsp;a&nbsp;<a href="#Future">Future</a>.</tt></dd></dl>

<dl><dt>async <a name="BaseEventLoop-shutdown_asyncgens"><strong>shutdown_asyncgens</strong></a>(self)</dt><dd><tt>Shutdown&nbsp;all&nbsp;active&nbsp;asynchronous&nbsp;generators.</tt></dd></dl>

<dl><dt>async <a name="BaseEventLoop-sock_sendfile"><strong>sock_sendfile</strong></a>(self, sock, file, offset=0, count=None, *, fallback=True)</dt></dl>

<dl><dt>async <a name="BaseEventLoop-start_tls"><strong>start_tls</strong></a>(self, transport, protocol, sslcontext, *, server_side=False, server_hostname=None, ssl_handshake_timeout=None)</dt><dd><tt>Upgrade&nbsp;transport&nbsp;to&nbsp;TLS.<br>
&nbsp;<br>
Return&nbsp;a&nbsp;new&nbsp;transport&nbsp;that&nbsp;*protocol*&nbsp;should&nbsp;start&nbsp;using<br>
immediately.</tt></dd></dl>

<dl><dt><a name="BaseEventLoop-stop"><strong>stop</strong></a>(self)</dt><dd><tt>Stop&nbsp;running&nbsp;the&nbsp;event&nbsp;loop.<br>
&nbsp;<br>
Every&nbsp;callback&nbsp;already&nbsp;scheduled&nbsp;will&nbsp;still&nbsp;run.&nbsp;&nbsp;This&nbsp;simply&nbsp;informs<br>
run_forever&nbsp;to&nbsp;stop&nbsp;looping&nbsp;after&nbsp;a&nbsp;complete&nbsp;iteration.</tt></dd></dl>

<dl><dt>async <a name="BaseEventLoop-subprocess_exec"><strong>subprocess_exec</strong></a>(self, protocol_factory, program, *args, stdin=-1, stdout=-1, stderr=-1, universal_newlines=False, shell=False, bufsize=0, encoding=None, errors=None, text=None, **kwargs)</dt></dl>

<dl><dt>async <a name="BaseEventLoop-subprocess_shell"><strong>subprocess_shell</strong></a>(self, protocol_factory, cmd, *, stdin=-1, stdout=-1, stderr=-1, universal_newlines=False, shell=True, bufsize=0, encoding=None, errors=None, text=None, **kwargs)</dt></dl>

<dl><dt><a name="BaseEventLoop-time"><strong>time</strong></a>(self)</dt><dd><tt>Return&nbsp;the&nbsp;time&nbsp;according&nbsp;to&nbsp;the&nbsp;event&nbsp;loop's&nbsp;clock.<br>
&nbsp;<br>
This&nbsp;is&nbsp;a&nbsp;float&nbsp;expressed&nbsp;in&nbsp;seconds&nbsp;since&nbsp;an&nbsp;epoch,&nbsp;but&nbsp;the<br>
epoch,&nbsp;precision,&nbsp;accuracy&nbsp;and&nbsp;drift&nbsp;are&nbsp;unspecified&nbsp;and&nbsp;may<br>
differ&nbsp;per&nbsp;event&nbsp;loop.</tt></dd></dl>

<hr>
Methods inherited from <a href="asyncio.events.html#AbstractEventLoop">asyncio.events.AbstractEventLoop</a>:<br>
<dl><dt><a name="BaseEventLoop-add_reader"><strong>add_reader</strong></a>(self, fd, callback, *args)</dt></dl>

<dl><dt><a name="BaseEventLoop-add_signal_handler"><strong>add_signal_handler</strong></a>(self, sig, callback, *args)</dt></dl>

<dl><dt><a name="BaseEventLoop-add_writer"><strong>add_writer</strong></a>(self, fd, callback, *args)</dt></dl>

<dl><dt>async <a name="BaseEventLoop-create_unix_connection"><strong>create_unix_connection</strong></a>(self, protocol_factory, path=None, *, ssl=None, sock=None, server_hostname=None, ssl_handshake_timeout=None)</dt></dl>

<dl><dt>async <a name="BaseEventLoop-create_unix_server"><strong>create_unix_server</strong></a>(self, protocol_factory, path=None, *, sock=None, backlog=100, ssl=None, ssl_handshake_timeout=None, start_serving=True)</dt><dd><tt>A&nbsp;coroutine&nbsp;which&nbsp;creates&nbsp;a&nbsp;UNIX&nbsp;Domain&nbsp;Socket&nbsp;server.<br>
&nbsp;<br>
The&nbsp;return&nbsp;value&nbsp;is&nbsp;a&nbsp;Server&nbsp;<a href="builtins.html#object">object</a>,&nbsp;which&nbsp;can&nbsp;be&nbsp;used&nbsp;to&nbsp;stop<br>
the&nbsp;service.<br>
&nbsp;<br>
path&nbsp;is&nbsp;a&nbsp;str,&nbsp;representing&nbsp;a&nbsp;file&nbsp;systsem&nbsp;path&nbsp;to&nbsp;bind&nbsp;the<br>
server&nbsp;socket&nbsp;to.<br>
&nbsp;<br>
sock&nbsp;can&nbsp;optionally&nbsp;be&nbsp;specified&nbsp;in&nbsp;order&nbsp;to&nbsp;use&nbsp;a&nbsp;preexisting<br>
socket&nbsp;<a href="builtins.html#object">object</a>.<br>
&nbsp;<br>
backlog&nbsp;is&nbsp;the&nbsp;maximum&nbsp;number&nbsp;of&nbsp;queued&nbsp;connections&nbsp;passed&nbsp;to<br>
listen()&nbsp;(defaults&nbsp;to&nbsp;100).<br>
&nbsp;<br>
ssl&nbsp;can&nbsp;be&nbsp;set&nbsp;to&nbsp;an&nbsp;SSLContext&nbsp;to&nbsp;enable&nbsp;SSL&nbsp;over&nbsp;the<br>
accepted&nbsp;connections.<br>
&nbsp;<br>
ssl_handshake_timeout&nbsp;is&nbsp;the&nbsp;time&nbsp;in&nbsp;seconds&nbsp;that&nbsp;an&nbsp;SSL&nbsp;server<br>
will&nbsp;wait&nbsp;for&nbsp;the&nbsp;SSL&nbsp;handshake&nbsp;to&nbsp;complete&nbsp;(defaults&nbsp;to&nbsp;60s).<br>
&nbsp;<br>
start_serving&nbsp;set&nbsp;to&nbsp;True&nbsp;(default)&nbsp;causes&nbsp;the&nbsp;created&nbsp;server<br>
to&nbsp;start&nbsp;accepting&nbsp;connections&nbsp;immediately.&nbsp;&nbsp;When&nbsp;set&nbsp;to&nbsp;False,<br>
the&nbsp;user&nbsp;should&nbsp;await&nbsp;Server.start_serving()&nbsp;or&nbsp;Server.serve_forever()<br>
to&nbsp;make&nbsp;the&nbsp;server&nbsp;to&nbsp;start&nbsp;accepting&nbsp;connections.</tt></dd></dl>

<dl><dt><a name="BaseEventLoop-remove_reader"><strong>remove_reader</strong></a>(self, fd)</dt></dl>

<dl><dt><a name="BaseEventLoop-remove_signal_handler"><strong>remove_signal_handler</strong></a>(self, sig)</dt></dl>

<dl><dt><a name="BaseEventLoop-remove_writer"><strong>remove_writer</strong></a>(self, fd)</dt></dl>

<dl><dt>async <a name="BaseEventLoop-sock_accept"><strong>sock_accept</strong></a>(self, sock)</dt></dl>

<dl><dt>async <a name="BaseEventLoop-sock_connect"><strong>sock_connect</strong></a>(self, sock, address)</dt></dl>

<dl><dt>async <a name="BaseEventLoop-sock_recv"><strong>sock_recv</strong></a>(self, sock, nbytes)</dt></dl>

<dl><dt>async <a name="BaseEventLoop-sock_recv_into"><strong>sock_recv_into</strong></a>(self, sock, buf)</dt></dl>

<dl><dt>async <a name="BaseEventLoop-sock_sendall"><strong>sock_sendall</strong></a>(self, sock, data)</dt></dl>

<hr>
Data descriptors inherited from <a href="asyncio.events.html#AbstractEventLoop">asyncio.events.AbstractEventLoop</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="BaseProtocol">class <strong>BaseProtocol</strong></a>(<a href="builtins.html#object">builtins.object</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt>Common&nbsp;base&nbsp;class&nbsp;for&nbsp;protocol&nbsp;interfaces.<br>
&nbsp;<br>
Usually&nbsp;user&nbsp;implements&nbsp;protocols&nbsp;that&nbsp;derived&nbsp;from&nbsp;<a href="#BaseProtocol">BaseProtocol</a><br>
like&nbsp;<a href="#Protocol">Protocol</a>&nbsp;or&nbsp;ProcessProtocol.<br>
&nbsp;<br>
The&nbsp;only&nbsp;case&nbsp;when&nbsp;<a href="#BaseProtocol">BaseProtocol</a>&nbsp;should&nbsp;be&nbsp;implemented&nbsp;directly&nbsp;is<br>
write-only&nbsp;transport&nbsp;like&nbsp;write&nbsp;pipe<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%">Methods defined here:<br>
<dl><dt><a name="BaseProtocol-connection_lost"><strong>connection_lost</strong></a>(self, exc)</dt><dd><tt>Called&nbsp;when&nbsp;the&nbsp;connection&nbsp;is&nbsp;lost&nbsp;or&nbsp;closed.<br>
&nbsp;<br>
The&nbsp;argument&nbsp;is&nbsp;an&nbsp;exception&nbsp;<a href="builtins.html#object">object</a>&nbsp;or&nbsp;None&nbsp;(the&nbsp;latter<br>
meaning&nbsp;a&nbsp;regular&nbsp;EOF&nbsp;is&nbsp;received&nbsp;or&nbsp;the&nbsp;connection&nbsp;was<br>
aborted&nbsp;or&nbsp;closed).</tt></dd></dl>

<dl><dt><a name="BaseProtocol-connection_made"><strong>connection_made</strong></a>(self, transport)</dt><dd><tt>Called&nbsp;when&nbsp;a&nbsp;connection&nbsp;is&nbsp;made.<br>
&nbsp;<br>
The&nbsp;argument&nbsp;is&nbsp;the&nbsp;transport&nbsp;representing&nbsp;the&nbsp;pipe&nbsp;connection.<br>
To&nbsp;receive&nbsp;data,&nbsp;wait&nbsp;for&nbsp;data_received()&nbsp;calls.<br>
When&nbsp;the&nbsp;connection&nbsp;is&nbsp;closed,&nbsp;<a href="#BaseProtocol-connection_lost">connection_lost</a>()&nbsp;is&nbsp;called.</tt></dd></dl>

<dl><dt><a name="BaseProtocol-pause_writing"><strong>pause_writing</strong></a>(self)</dt><dd><tt>Called&nbsp;when&nbsp;the&nbsp;transport's&nbsp;buffer&nbsp;goes&nbsp;over&nbsp;the&nbsp;high-water&nbsp;mark.<br>
&nbsp;<br>
Pause&nbsp;and&nbsp;resume&nbsp;calls&nbsp;are&nbsp;paired&nbsp;--&nbsp;<a href="#BaseProtocol-pause_writing">pause_writing</a>()&nbsp;is&nbsp;called<br>
once&nbsp;when&nbsp;the&nbsp;buffer&nbsp;goes&nbsp;strictly&nbsp;over&nbsp;the&nbsp;high-water&nbsp;mark<br>
(even&nbsp;if&nbsp;subsequent&nbsp;writes&nbsp;increases&nbsp;the&nbsp;buffer&nbsp;size&nbsp;even<br>
more),&nbsp;and&nbsp;eventually&nbsp;<a href="#BaseProtocol-resume_writing">resume_writing</a>()&nbsp;is&nbsp;called&nbsp;once&nbsp;when&nbsp;the<br>
buffer&nbsp;size&nbsp;reaches&nbsp;the&nbsp;low-water&nbsp;mark.<br>
&nbsp;<br>
Note&nbsp;that&nbsp;if&nbsp;the&nbsp;buffer&nbsp;size&nbsp;equals&nbsp;the&nbsp;high-water&nbsp;mark,<br>
<a href="#BaseProtocol-pause_writing">pause_writing</a>()&nbsp;is&nbsp;not&nbsp;called&nbsp;--&nbsp;it&nbsp;must&nbsp;go&nbsp;strictly&nbsp;over.<br>
Conversely,&nbsp;<a href="#BaseProtocol-resume_writing">resume_writing</a>()&nbsp;is&nbsp;called&nbsp;when&nbsp;the&nbsp;buffer&nbsp;size&nbsp;is<br>
equal&nbsp;or&nbsp;lower&nbsp;than&nbsp;the&nbsp;low-water&nbsp;mark.&nbsp;&nbsp;These&nbsp;end&nbsp;conditions<br>
are&nbsp;important&nbsp;to&nbsp;ensure&nbsp;that&nbsp;things&nbsp;go&nbsp;as&nbsp;expected&nbsp;when&nbsp;either<br>
mark&nbsp;is&nbsp;zero.<br>
&nbsp;<br>
NOTE:&nbsp;This&nbsp;is&nbsp;the&nbsp;only&nbsp;<a href="#Protocol">Protocol</a>&nbsp;callback&nbsp;that&nbsp;is&nbsp;not&nbsp;called<br>
through&nbsp;EventLoop.call_soon()&nbsp;--&nbsp;if&nbsp;it&nbsp;were,&nbsp;it&nbsp;would&nbsp;have&nbsp;no<br>
effect&nbsp;when&nbsp;it's&nbsp;most&nbsp;needed&nbsp;(when&nbsp;the&nbsp;app&nbsp;keeps&nbsp;writing<br>
without&nbsp;yielding&nbsp;until&nbsp;<a href="#BaseProtocol-pause_writing">pause_writing</a>()&nbsp;is&nbsp;called).</tt></dd></dl>

<dl><dt><a name="BaseProtocol-resume_writing"><strong>resume_writing</strong></a>(self)</dt><dd><tt>Called&nbsp;when&nbsp;the&nbsp;transport's&nbsp;buffer&nbsp;drains&nbsp;below&nbsp;the&nbsp;low-water&nbsp;mark.<br>
&nbsp;<br>
See&nbsp;<a href="#BaseProtocol-pause_writing">pause_writing</a>()&nbsp;for&nbsp;details.</tt></dd></dl>

</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="BaseTransport">class <strong>BaseTransport</strong></a>(<a href="builtins.html#object">builtins.object</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#BaseTransport">BaseTransport</a>(extra=None)<br>
&nbsp;<br>
Base&nbsp;class&nbsp;for&nbsp;transports.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%">Methods defined here:<br>
<dl><dt><a name="BaseTransport-__init__"><strong>__init__</strong></a>(self, extra=None)</dt><dd><tt>Initialize&nbsp;self.&nbsp;&nbsp;See&nbsp;help(type(self))&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<dl><dt><a name="BaseTransport-close"><strong>close</strong></a>(self)</dt><dd><tt>Close&nbsp;the&nbsp;transport.<br>
&nbsp;<br>
Buffered&nbsp;data&nbsp;will&nbsp;be&nbsp;flushed&nbsp;asynchronously.&nbsp;&nbsp;No&nbsp;more&nbsp;data<br>
will&nbsp;be&nbsp;received.&nbsp;&nbsp;After&nbsp;all&nbsp;buffered&nbsp;data&nbsp;is&nbsp;flushed,&nbsp;the<br>
protocol's&nbsp;connection_lost()&nbsp;method&nbsp;will&nbsp;(eventually)&nbsp;be<br>
called&nbsp;with&nbsp;None&nbsp;as&nbsp;its&nbsp;argument.</tt></dd></dl>

<dl><dt><a name="BaseTransport-get_extra_info"><strong>get_extra_info</strong></a>(self, name, default=None)</dt><dd><tt>Get&nbsp;optional&nbsp;transport&nbsp;information.</tt></dd></dl>

<dl><dt><a name="BaseTransport-get_protocol"><strong>get_protocol</strong></a>(self)</dt><dd><tt>Return&nbsp;the&nbsp;current&nbsp;protocol.</tt></dd></dl>

<dl><dt><a name="BaseTransport-is_closing"><strong>is_closing</strong></a>(self)</dt><dd><tt>Return&nbsp;True&nbsp;if&nbsp;the&nbsp;transport&nbsp;is&nbsp;closing&nbsp;or&nbsp;closed.</tt></dd></dl>

<dl><dt><a name="BaseTransport-set_protocol"><strong>set_protocol</strong></a>(self, protocol)</dt><dd><tt>Set&nbsp;a&nbsp;new&nbsp;protocol.</tt></dd></dl>

</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="BoundedSemaphore">class <strong>BoundedSemaphore</strong></a>(<a href="asyncio.locks.html#Semaphore">Semaphore</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#BoundedSemaphore">BoundedSemaphore</a>(value=1,&nbsp;*,&nbsp;loop=None)<br>
&nbsp;<br>
A&nbsp;bounded&nbsp;semaphore&nbsp;implementation.<br>
&nbsp;<br>
This&nbsp;raises&nbsp;ValueError&nbsp;in&nbsp;<a href="#BoundedSemaphore-release">release</a>()&nbsp;if&nbsp;it&nbsp;would&nbsp;increase&nbsp;the&nbsp;value<br>
above&nbsp;the&nbsp;initial&nbsp;value.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="asyncio.locks.html#BoundedSemaphore">BoundedSemaphore</a></dd>
<dd><a href="asyncio.locks.html#Semaphore">Semaphore</a></dd>
<dd><a href="asyncio.locks.html#_ContextManagerMixin">_ContextManagerMixin</a></dd>
<dd><a href="builtins.html#object">builtins.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="BoundedSemaphore-__init__"><strong>__init__</strong></a>(self, value=1, *, loop=None)</dt><dd><tt>Initialize&nbsp;self.&nbsp;&nbsp;See&nbsp;help(type(self))&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<dl><dt><a name="BoundedSemaphore-release"><strong>release</strong></a>(self)</dt><dd><tt>Release&nbsp;a&nbsp;semaphore,&nbsp;incrementing&nbsp;the&nbsp;internal&nbsp;counter&nbsp;by&nbsp;one.<br>
When&nbsp;it&nbsp;was&nbsp;zero&nbsp;on&nbsp;entry&nbsp;and&nbsp;another&nbsp;coroutine&nbsp;is&nbsp;waiting&nbsp;for&nbsp;it&nbsp;to<br>
become&nbsp;larger&nbsp;than&nbsp;zero&nbsp;again,&nbsp;wake&nbsp;up&nbsp;that&nbsp;coroutine.</tt></dd></dl>

<hr>
Methods inherited from <a href="asyncio.locks.html#Semaphore">Semaphore</a>:<br>
<dl><dt><a name="BoundedSemaphore-__repr__"><strong>__repr__</strong></a>(self)</dt><dd><tt>Return&nbsp;repr(self).</tt></dd></dl>

<dl><dt>async <a name="BoundedSemaphore-acquire"><strong>acquire</strong></a>(self)</dt><dd><tt>Acquire&nbsp;a&nbsp;semaphore.<br>
&nbsp;<br>
If&nbsp;the&nbsp;internal&nbsp;counter&nbsp;is&nbsp;larger&nbsp;than&nbsp;zero&nbsp;on&nbsp;entry,<br>
decrement&nbsp;it&nbsp;by&nbsp;one&nbsp;and&nbsp;return&nbsp;True&nbsp;immediately.&nbsp;&nbsp;If&nbsp;it&nbsp;is<br>
zero&nbsp;on&nbsp;entry,&nbsp;block,&nbsp;waiting&nbsp;until&nbsp;some&nbsp;other&nbsp;coroutine&nbsp;has<br>
called&nbsp;<a href="#BoundedSemaphore-release">release</a>()&nbsp;to&nbsp;make&nbsp;it&nbsp;larger&nbsp;than&nbsp;0,&nbsp;and&nbsp;then&nbsp;return<br>
True.</tt></dd></dl>

<dl><dt><a name="BoundedSemaphore-locked"><strong>locked</strong></a>(self)</dt><dd><tt>Returns&nbsp;True&nbsp;if&nbsp;semaphore&nbsp;can&nbsp;not&nbsp;be&nbsp;acquired&nbsp;immediately.</tt></dd></dl>

<hr>
Methods inherited from <a href="asyncio.locks.html#_ContextManagerMixin">_ContextManagerMixin</a>:<br>
<dl><dt>async <a name="BoundedSemaphore-__aenter__"><strong>__aenter__</strong></a>(self)</dt></dl>

<dl><dt>async <a name="BoundedSemaphore-__aexit__"><strong>__aexit__</strong></a>(self, exc_type, exc, tb)</dt></dl>

<dl><dt><a name="BoundedSemaphore-__await__"><strong>__await__</strong></a>(self)</dt></dl>

<dl><dt><a name="BoundedSemaphore-__enter__"><strong>__enter__</strong></a>(self)</dt></dl>

<dl><dt><a name="BoundedSemaphore-__exit__"><strong>__exit__</strong></a>(self, *args)</dt></dl>

<dl><dt><a name="BoundedSemaphore-__iter__"><strong>__iter__</strong></a>(self)</dt></dl>

<hr>
Data descriptors inherited from <a href="asyncio.locks.html#_ContextManagerMixin">_ContextManagerMixin</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="BufferedProtocol">class <strong>BufferedProtocol</strong></a>(<a href="asyncio.protocols.html#BaseProtocol">BaseProtocol</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt>Interface&nbsp;for&nbsp;stream&nbsp;protocol&nbsp;with&nbsp;manual&nbsp;buffer&nbsp;control.<br>
&nbsp;<br>
Important:&nbsp;this&nbsp;has&nbsp;been&nbsp;added&nbsp;to&nbsp;asyncio&nbsp;in&nbsp;Python&nbsp;3.7<br>
*on&nbsp;a&nbsp;provisional&nbsp;basis*!&nbsp;&nbsp;Consider&nbsp;it&nbsp;as&nbsp;an&nbsp;experimental&nbsp;API&nbsp;that<br>
might&nbsp;be&nbsp;changed&nbsp;or&nbsp;removed&nbsp;in&nbsp;Python&nbsp;3.8.<br>
&nbsp;<br>
<a href="#Event">Event</a>&nbsp;methods,&nbsp;such&nbsp;as&nbsp;`create_server`&nbsp;and&nbsp;`create_connection`,<br>
accept&nbsp;factories&nbsp;that&nbsp;return&nbsp;protocols&nbsp;that&nbsp;implement&nbsp;this&nbsp;interface.<br>
&nbsp;<br>
The&nbsp;idea&nbsp;of&nbsp;<a href="#BufferedProtocol">BufferedProtocol</a>&nbsp;is&nbsp;that&nbsp;it&nbsp;allows&nbsp;to&nbsp;manually&nbsp;allocate<br>
and&nbsp;control&nbsp;the&nbsp;receive&nbsp;buffer.&nbsp;&nbsp;<a href="#Event">Event</a>&nbsp;loops&nbsp;can&nbsp;then&nbsp;use&nbsp;the&nbsp;buffer<br>
provided&nbsp;by&nbsp;the&nbsp;protocol&nbsp;to&nbsp;avoid&nbsp;unnecessary&nbsp;data&nbsp;copies.&nbsp;&nbsp;This<br>
can&nbsp;result&nbsp;in&nbsp;noticeable&nbsp;performance&nbsp;improvement&nbsp;for&nbsp;protocols&nbsp;that<br>
receive&nbsp;big&nbsp;amounts&nbsp;of&nbsp;data.&nbsp;&nbsp;Sophisticated&nbsp;protocols&nbsp;can&nbsp;allocate<br>
the&nbsp;buffer&nbsp;only&nbsp;once&nbsp;at&nbsp;creation&nbsp;time.<br>
&nbsp;<br>
State&nbsp;machine&nbsp;of&nbsp;calls:<br>
&nbsp;<br>
&nbsp;&nbsp;start&nbsp;-&gt;&nbsp;CM&nbsp;[-&gt;&nbsp;GB&nbsp;[-&gt;&nbsp;BU?]]*&nbsp;[-&gt;&nbsp;ER?]&nbsp;-&gt;&nbsp;CL&nbsp;-&gt;&nbsp;end<br>
&nbsp;<br>
*&nbsp;CM:&nbsp;<a href="#BufferedProtocol-connection_made">connection_made</a>()<br>
*&nbsp;GB:&nbsp;<a href="#BufferedProtocol-get_buffer">get_buffer</a>()<br>
*&nbsp;BU:&nbsp;<a href="#BufferedProtocol-buffer_updated">buffer_updated</a>()<br>
*&nbsp;ER:&nbsp;<a href="#BufferedProtocol-eof_received">eof_received</a>()<br>
*&nbsp;CL:&nbsp;<a href="#BufferedProtocol-connection_lost">connection_lost</a>()<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="asyncio.protocols.html#BufferedProtocol">BufferedProtocol</a></dd>
<dd><a href="asyncio.protocols.html#BaseProtocol">BaseProtocol</a></dd>
<dd><a href="builtins.html#object">builtins.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="BufferedProtocol-buffer_updated"><strong>buffer_updated</strong></a>(self, nbytes)</dt><dd><tt>Called&nbsp;when&nbsp;the&nbsp;buffer&nbsp;was&nbsp;updated&nbsp;with&nbsp;the&nbsp;received&nbsp;data.<br>
&nbsp;<br>
*nbytes*&nbsp;is&nbsp;the&nbsp;total&nbsp;number&nbsp;of&nbsp;bytes&nbsp;that&nbsp;were&nbsp;written&nbsp;to<br>
the&nbsp;buffer.</tt></dd></dl>

<dl><dt><a name="BufferedProtocol-eof_received"><strong>eof_received</strong></a>(self)</dt><dd><tt>Called&nbsp;when&nbsp;the&nbsp;other&nbsp;end&nbsp;calls&nbsp;write_eof()&nbsp;or&nbsp;equivalent.<br>
&nbsp;<br>
If&nbsp;this&nbsp;returns&nbsp;a&nbsp;false&nbsp;value&nbsp;(including&nbsp;None),&nbsp;the&nbsp;transport<br>
will&nbsp;close&nbsp;itself.&nbsp;&nbsp;If&nbsp;it&nbsp;returns&nbsp;a&nbsp;true&nbsp;value,&nbsp;closing&nbsp;the<br>
transport&nbsp;is&nbsp;up&nbsp;to&nbsp;the&nbsp;protocol.</tt></dd></dl>

<dl><dt><a name="BufferedProtocol-get_buffer"><strong>get_buffer</strong></a>(self, sizehint)</dt><dd><tt>Called&nbsp;to&nbsp;allocate&nbsp;a&nbsp;new&nbsp;receive&nbsp;buffer.<br>
&nbsp;<br>
*sizehint*&nbsp;is&nbsp;a&nbsp;recommended&nbsp;minimal&nbsp;size&nbsp;for&nbsp;the&nbsp;returned<br>
buffer.&nbsp;&nbsp;When&nbsp;set&nbsp;to&nbsp;-1,&nbsp;the&nbsp;buffer&nbsp;size&nbsp;can&nbsp;be&nbsp;arbitrary.<br>
&nbsp;<br>
Must&nbsp;return&nbsp;an&nbsp;<a href="builtins.html#object">object</a>&nbsp;that&nbsp;implements&nbsp;the<br>
:ref:`buffer&nbsp;protocol&nbsp;&lt;bufferobjects&gt;`.<br>
It&nbsp;is&nbsp;an&nbsp;error&nbsp;to&nbsp;return&nbsp;a&nbsp;zero-sized&nbsp;buffer.</tt></dd></dl>

<hr>
Methods inherited from <a href="asyncio.protocols.html#BaseProtocol">BaseProtocol</a>:<br>
<dl><dt><a name="BufferedProtocol-connection_lost"><strong>connection_lost</strong></a>(self, exc)</dt><dd><tt>Called&nbsp;when&nbsp;the&nbsp;connection&nbsp;is&nbsp;lost&nbsp;or&nbsp;closed.<br>
&nbsp;<br>
The&nbsp;argument&nbsp;is&nbsp;an&nbsp;exception&nbsp;<a href="builtins.html#object">object</a>&nbsp;or&nbsp;None&nbsp;(the&nbsp;latter<br>
meaning&nbsp;a&nbsp;regular&nbsp;EOF&nbsp;is&nbsp;received&nbsp;or&nbsp;the&nbsp;connection&nbsp;was<br>
aborted&nbsp;or&nbsp;closed).</tt></dd></dl>

<dl><dt><a name="BufferedProtocol-connection_made"><strong>connection_made</strong></a>(self, transport)</dt><dd><tt>Called&nbsp;when&nbsp;a&nbsp;connection&nbsp;is&nbsp;made.<br>
&nbsp;<br>
The&nbsp;argument&nbsp;is&nbsp;the&nbsp;transport&nbsp;representing&nbsp;the&nbsp;pipe&nbsp;connection.<br>
To&nbsp;receive&nbsp;data,&nbsp;wait&nbsp;for&nbsp;data_received()&nbsp;calls.<br>
When&nbsp;the&nbsp;connection&nbsp;is&nbsp;closed,&nbsp;<a href="#BufferedProtocol-connection_lost">connection_lost</a>()&nbsp;is&nbsp;called.</tt></dd></dl>

<dl><dt><a name="BufferedProtocol-pause_writing"><strong>pause_writing</strong></a>(self)</dt><dd><tt>Called&nbsp;when&nbsp;the&nbsp;transport's&nbsp;buffer&nbsp;goes&nbsp;over&nbsp;the&nbsp;high-water&nbsp;mark.<br>
&nbsp;<br>
Pause&nbsp;and&nbsp;resume&nbsp;calls&nbsp;are&nbsp;paired&nbsp;--&nbsp;<a href="#BufferedProtocol-pause_writing">pause_writing</a>()&nbsp;is&nbsp;called<br>
once&nbsp;when&nbsp;the&nbsp;buffer&nbsp;goes&nbsp;strictly&nbsp;over&nbsp;the&nbsp;high-water&nbsp;mark<br>
(even&nbsp;if&nbsp;subsequent&nbsp;writes&nbsp;increases&nbsp;the&nbsp;buffer&nbsp;size&nbsp;even<br>
more),&nbsp;and&nbsp;eventually&nbsp;<a href="#BufferedProtocol-resume_writing">resume_writing</a>()&nbsp;is&nbsp;called&nbsp;once&nbsp;when&nbsp;the<br>
buffer&nbsp;size&nbsp;reaches&nbsp;the&nbsp;low-water&nbsp;mark.<br>
&nbsp;<br>
Note&nbsp;that&nbsp;if&nbsp;the&nbsp;buffer&nbsp;size&nbsp;equals&nbsp;the&nbsp;high-water&nbsp;mark,<br>
<a href="#BufferedProtocol-pause_writing">pause_writing</a>()&nbsp;is&nbsp;not&nbsp;called&nbsp;--&nbsp;it&nbsp;must&nbsp;go&nbsp;strictly&nbsp;over.<br>
Conversely,&nbsp;<a href="#BufferedProtocol-resume_writing">resume_writing</a>()&nbsp;is&nbsp;called&nbsp;when&nbsp;the&nbsp;buffer&nbsp;size&nbsp;is<br>
equal&nbsp;or&nbsp;lower&nbsp;than&nbsp;the&nbsp;low-water&nbsp;mark.&nbsp;&nbsp;These&nbsp;end&nbsp;conditions<br>
are&nbsp;important&nbsp;to&nbsp;ensure&nbsp;that&nbsp;things&nbsp;go&nbsp;as&nbsp;expected&nbsp;when&nbsp;either<br>
mark&nbsp;is&nbsp;zero.<br>
&nbsp;<br>
NOTE:&nbsp;This&nbsp;is&nbsp;the&nbsp;only&nbsp;<a href="#Protocol">Protocol</a>&nbsp;callback&nbsp;that&nbsp;is&nbsp;not&nbsp;called<br>
through&nbsp;EventLoop.call_soon()&nbsp;--&nbsp;if&nbsp;it&nbsp;were,&nbsp;it&nbsp;would&nbsp;have&nbsp;no<br>
effect&nbsp;when&nbsp;it's&nbsp;most&nbsp;needed&nbsp;(when&nbsp;the&nbsp;app&nbsp;keeps&nbsp;writing<br>
without&nbsp;yielding&nbsp;until&nbsp;<a href="#BufferedProtocol-pause_writing">pause_writing</a>()&nbsp;is&nbsp;called).</tt></dd></dl>

<dl><dt><a name="BufferedProtocol-resume_writing"><strong>resume_writing</strong></a>(self)</dt><dd><tt>Called&nbsp;when&nbsp;the&nbsp;transport's&nbsp;buffer&nbsp;drains&nbsp;below&nbsp;the&nbsp;low-water&nbsp;mark.<br>
&nbsp;<br>
See&nbsp;<a href="#BufferedProtocol-pause_writing">pause_writing</a>()&nbsp;for&nbsp;details.</tt></dd></dl>

</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="CancelledError">class <strong>CancelledError</strong></a>(<a href="builtins.html#BaseException">builtins.BaseException</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt>The&nbsp;<a href="#Future">Future</a>&nbsp;or&nbsp;<a href="#Task">Task</a>&nbsp;was&nbsp;cancelled.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="asyncio.exceptions.html#CancelledError">CancelledError</a></dd>
<dd><a href="builtins.html#BaseException">builtins.BaseException</a></dd>
<dd><a href="builtins.html#object">builtins.object</a></dd>
</dl>
<hr>
Data descriptors defined here:<br>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<hr>
Methods inherited from <a href="builtins.html#BaseException">builtins.BaseException</a>:<br>
<dl><dt><a name="CancelledError-__delattr__"><strong>__delattr__</strong></a>(self, name, /)</dt><dd><tt>Implement&nbsp;delattr(self,&nbsp;name).</tt></dd></dl>

<dl><dt><a name="CancelledError-__getattribute__"><strong>__getattribute__</strong></a>(self, name, /)</dt><dd><tt>Return&nbsp;getattr(self,&nbsp;name).</tt></dd></dl>

<dl><dt><a name="CancelledError-__init__"><strong>__init__</strong></a>(self, /, *args, **kwargs)</dt><dd><tt>Initialize&nbsp;self.&nbsp;&nbsp;See&nbsp;help(type(self))&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<dl><dt><a name="CancelledError-__reduce__"><strong>__reduce__</strong></a>(...)</dt><dd><tt>Helper&nbsp;for&nbsp;pickle.</tt></dd></dl>

<dl><dt><a name="CancelledError-__repr__"><strong>__repr__</strong></a>(self, /)</dt><dd><tt>Return&nbsp;repr(self).</tt></dd></dl>

<dl><dt><a name="CancelledError-__setattr__"><strong>__setattr__</strong></a>(self, name, value, /)</dt><dd><tt>Implement&nbsp;setattr(self,&nbsp;name,&nbsp;value).</tt></dd></dl>

<dl><dt><a name="CancelledError-__setstate__"><strong>__setstate__</strong></a>(...)</dt></dl>

<dl><dt><a name="CancelledError-__str__"><strong>__str__</strong></a>(self, /)</dt><dd><tt>Return&nbsp;str(self).</tt></dd></dl>

<dl><dt><a name="CancelledError-with_traceback"><strong>with_traceback</strong></a>(...)</dt><dd><tt><a href="builtins.html#Exception">Exception</a>.<a href="#CancelledError-with_traceback">with_traceback</a>(tb)&nbsp;--<br>
set&nbsp;self.<strong>__traceback__</strong>&nbsp;to&nbsp;tb&nbsp;and&nbsp;return&nbsp;self.</tt></dd></dl>

<hr>
Static methods inherited from <a href="builtins.html#BaseException">builtins.BaseException</a>:<br>
<dl><dt><a name="CancelledError-__new__"><strong>__new__</strong></a>(*args, **kwargs)<font color="#909090"><font face="helvetica, arial"> from <a href="builtins.html#type">builtins.type</a></font></font></dt><dd><tt>Create&nbsp;and&nbsp;return&nbsp;a&nbsp;new&nbsp;<a href="builtins.html#object">object</a>.&nbsp;&nbsp;See&nbsp;help(type)&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<hr>
Data descriptors inherited from <a href="builtins.html#BaseException">builtins.BaseException</a>:<br>
<dl><dt><strong>__cause__</strong></dt>
<dd><tt>exception&nbsp;cause</tt></dd>
</dl>
<dl><dt><strong>__context__</strong></dt>
<dd><tt>exception&nbsp;context</tt></dd>
</dl>
<dl><dt><strong>__dict__</strong></dt>
</dl>
<dl><dt><strong>__suppress_context__</strong></dt>
</dl>
<dl><dt><strong>__traceback__</strong></dt>
</dl>
<dl><dt><strong>args</strong></dt>
</dl>
</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="Condition">class <strong>Condition</strong></a>(<a href="asyncio.locks.html#_ContextManagerMixin">_ContextManagerMixin</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#Condition">Condition</a>(lock=None,&nbsp;*,&nbsp;loop=None)<br>
&nbsp;<br>
Asynchronous&nbsp;equivalent&nbsp;to&nbsp;threading.<a href="#Condition">Condition</a>.<br>
&nbsp;<br>
This&nbsp;class&nbsp;implements&nbsp;condition&nbsp;variable&nbsp;objects.&nbsp;A&nbsp;condition&nbsp;variable<br>
allows&nbsp;one&nbsp;or&nbsp;more&nbsp;coroutines&nbsp;to&nbsp;wait&nbsp;until&nbsp;they&nbsp;are&nbsp;notified&nbsp;by&nbsp;another<br>
coroutine.<br>
&nbsp;<br>
A&nbsp;new&nbsp;<a href="#Lock">Lock</a>&nbsp;<a href="builtins.html#object">object</a>&nbsp;is&nbsp;created&nbsp;and&nbsp;used&nbsp;as&nbsp;the&nbsp;underlying&nbsp;lock.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="asyncio.locks.html#Condition">Condition</a></dd>
<dd><a href="asyncio.locks.html#_ContextManagerMixin">_ContextManagerMixin</a></dd>
<dd><a href="builtins.html#object">builtins.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="Condition-__init__"><strong>__init__</strong></a>(self, lock=None, *, loop=None)</dt><dd><tt>Initialize&nbsp;self.&nbsp;&nbsp;See&nbsp;help(type(self))&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<dl><dt><a name="Condition-__repr__"><strong>__repr__</strong></a>(self)</dt><dd><tt>Return&nbsp;repr(self).</tt></dd></dl>

<dl><dt><a name="Condition-notify"><strong>notify</strong></a>(self, n=1)</dt><dd><tt>By&nbsp;default,&nbsp;wake&nbsp;up&nbsp;one&nbsp;coroutine&nbsp;waiting&nbsp;on&nbsp;this&nbsp;condition,&nbsp;if&nbsp;any.<br>
If&nbsp;the&nbsp;calling&nbsp;coroutine&nbsp;has&nbsp;not&nbsp;acquired&nbsp;the&nbsp;lock&nbsp;when&nbsp;this&nbsp;method<br>
is&nbsp;called,&nbsp;a&nbsp;<a href="builtins.html#RuntimeError">RuntimeError</a>&nbsp;is&nbsp;raised.<br>
&nbsp;<br>
This&nbsp;method&nbsp;wakes&nbsp;up&nbsp;at&nbsp;most&nbsp;n&nbsp;of&nbsp;the&nbsp;coroutines&nbsp;waiting&nbsp;for&nbsp;the<br>
condition&nbsp;variable;&nbsp;it&nbsp;is&nbsp;a&nbsp;no-op&nbsp;if&nbsp;no&nbsp;coroutines&nbsp;are&nbsp;waiting.<br>
&nbsp;<br>
Note:&nbsp;an&nbsp;awakened&nbsp;coroutine&nbsp;does&nbsp;not&nbsp;actually&nbsp;return&nbsp;from&nbsp;its<br>
<a href="#Condition-wait">wait</a>()&nbsp;call&nbsp;until&nbsp;it&nbsp;can&nbsp;reacquire&nbsp;the&nbsp;lock.&nbsp;Since&nbsp;<a href="#Condition-notify">notify</a>()&nbsp;does<br>
not&nbsp;release&nbsp;the&nbsp;lock,&nbsp;its&nbsp;caller&nbsp;should.</tt></dd></dl>

<dl><dt><a name="Condition-notify_all"><strong>notify_all</strong></a>(self)</dt><dd><tt>Wake&nbsp;up&nbsp;all&nbsp;threads&nbsp;waiting&nbsp;on&nbsp;this&nbsp;condition.&nbsp;This&nbsp;method&nbsp;acts<br>
like&nbsp;<a href="#Condition-notify">notify</a>(),&nbsp;but&nbsp;wakes&nbsp;up&nbsp;all&nbsp;waiting&nbsp;threads&nbsp;instead&nbsp;of&nbsp;one.&nbsp;If&nbsp;the<br>
calling&nbsp;thread&nbsp;has&nbsp;not&nbsp;acquired&nbsp;the&nbsp;lock&nbsp;when&nbsp;this&nbsp;method&nbsp;is&nbsp;called,<br>
a&nbsp;<a href="builtins.html#RuntimeError">RuntimeError</a>&nbsp;is&nbsp;raised.</tt></dd></dl>

<dl><dt>async <a name="Condition-wait"><strong>wait</strong></a>(self)</dt><dd><tt>Wait&nbsp;until&nbsp;notified.<br>
&nbsp;<br>
If&nbsp;the&nbsp;calling&nbsp;coroutine&nbsp;has&nbsp;not&nbsp;acquired&nbsp;the&nbsp;lock&nbsp;when&nbsp;this<br>
method&nbsp;is&nbsp;called,&nbsp;a&nbsp;<a href="builtins.html#RuntimeError">RuntimeError</a>&nbsp;is&nbsp;raised.<br>
&nbsp;<br>
This&nbsp;method&nbsp;releases&nbsp;the&nbsp;underlying&nbsp;lock,&nbsp;and&nbsp;then&nbsp;blocks<br>
until&nbsp;it&nbsp;is&nbsp;awakened&nbsp;by&nbsp;a&nbsp;<a href="#Condition-notify">notify</a>()&nbsp;or&nbsp;<a href="#Condition-notify_all">notify_all</a>()&nbsp;call&nbsp;for<br>
the&nbsp;same&nbsp;condition&nbsp;variable&nbsp;in&nbsp;another&nbsp;coroutine.&nbsp;&nbsp;Once<br>
awakened,&nbsp;it&nbsp;re-acquires&nbsp;the&nbsp;lock&nbsp;and&nbsp;returns&nbsp;True.</tt></dd></dl>

<dl><dt>async <a name="Condition-wait_for"><strong>wait_for</strong></a>(self, predicate)</dt><dd><tt>Wait&nbsp;until&nbsp;a&nbsp;predicate&nbsp;becomes&nbsp;true.<br>
&nbsp;<br>
The&nbsp;predicate&nbsp;should&nbsp;be&nbsp;a&nbsp;callable&nbsp;which&nbsp;result&nbsp;will&nbsp;be<br>
interpreted&nbsp;as&nbsp;a&nbsp;boolean&nbsp;value.&nbsp;&nbsp;The&nbsp;final&nbsp;predicate&nbsp;value&nbsp;is<br>
the&nbsp;return&nbsp;value.</tt></dd></dl>

<hr>
Methods inherited from <a href="asyncio.locks.html#_ContextManagerMixin">_ContextManagerMixin</a>:<br>
<dl><dt>async <a name="Condition-__aenter__"><strong>__aenter__</strong></a>(self)</dt></dl>

<dl><dt>async <a name="Condition-__aexit__"><strong>__aexit__</strong></a>(self, exc_type, exc, tb)</dt></dl>

<dl><dt><a name="Condition-__await__"><strong>__await__</strong></a>(self)</dt></dl>

<dl><dt><a name="Condition-__enter__"><strong>__enter__</strong></a>(self)</dt></dl>

<dl><dt><a name="Condition-__exit__"><strong>__exit__</strong></a>(self, *args)</dt></dl>

<dl><dt><a name="Condition-__iter__"><strong>__iter__</strong></a>(self)</dt></dl>

<hr>
Data descriptors inherited from <a href="asyncio.locks.html#_ContextManagerMixin">_ContextManagerMixin</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="DatagramProtocol">class <strong>DatagramProtocol</strong></a>(<a href="asyncio.protocols.html#BaseProtocol">BaseProtocol</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt>Interface&nbsp;for&nbsp;datagram&nbsp;protocol.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="asyncio.protocols.html#DatagramProtocol">DatagramProtocol</a></dd>
<dd><a href="asyncio.protocols.html#BaseProtocol">BaseProtocol</a></dd>
<dd><a href="builtins.html#object">builtins.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="DatagramProtocol-datagram_received"><strong>datagram_received</strong></a>(self, data, addr)</dt><dd><tt>Called&nbsp;when&nbsp;some&nbsp;datagram&nbsp;is&nbsp;received.</tt></dd></dl>

<dl><dt><a name="DatagramProtocol-error_received"><strong>error_received</strong></a>(self, exc)</dt><dd><tt>Called&nbsp;when&nbsp;a&nbsp;send&nbsp;or&nbsp;receive&nbsp;operation&nbsp;raises&nbsp;an&nbsp;OSError.<br>
&nbsp;<br>
(Other&nbsp;than&nbsp;BlockingIOError&nbsp;or&nbsp;InterruptedError.)</tt></dd></dl>

<hr>
Methods inherited from <a href="asyncio.protocols.html#BaseProtocol">BaseProtocol</a>:<br>
<dl><dt><a name="DatagramProtocol-connection_lost"><strong>connection_lost</strong></a>(self, exc)</dt><dd><tt>Called&nbsp;when&nbsp;the&nbsp;connection&nbsp;is&nbsp;lost&nbsp;or&nbsp;closed.<br>
&nbsp;<br>
The&nbsp;argument&nbsp;is&nbsp;an&nbsp;exception&nbsp;<a href="builtins.html#object">object</a>&nbsp;or&nbsp;None&nbsp;(the&nbsp;latter<br>
meaning&nbsp;a&nbsp;regular&nbsp;EOF&nbsp;is&nbsp;received&nbsp;or&nbsp;the&nbsp;connection&nbsp;was<br>
aborted&nbsp;or&nbsp;closed).</tt></dd></dl>

<dl><dt><a name="DatagramProtocol-connection_made"><strong>connection_made</strong></a>(self, transport)</dt><dd><tt>Called&nbsp;when&nbsp;a&nbsp;connection&nbsp;is&nbsp;made.<br>
&nbsp;<br>
The&nbsp;argument&nbsp;is&nbsp;the&nbsp;transport&nbsp;representing&nbsp;the&nbsp;pipe&nbsp;connection.<br>
To&nbsp;receive&nbsp;data,&nbsp;wait&nbsp;for&nbsp;data_received()&nbsp;calls.<br>
When&nbsp;the&nbsp;connection&nbsp;is&nbsp;closed,&nbsp;<a href="#DatagramProtocol-connection_lost">connection_lost</a>()&nbsp;is&nbsp;called.</tt></dd></dl>

<dl><dt><a name="DatagramProtocol-pause_writing"><strong>pause_writing</strong></a>(self)</dt><dd><tt>Called&nbsp;when&nbsp;the&nbsp;transport's&nbsp;buffer&nbsp;goes&nbsp;over&nbsp;the&nbsp;high-water&nbsp;mark.<br>
&nbsp;<br>
Pause&nbsp;and&nbsp;resume&nbsp;calls&nbsp;are&nbsp;paired&nbsp;--&nbsp;<a href="#DatagramProtocol-pause_writing">pause_writing</a>()&nbsp;is&nbsp;called<br>
once&nbsp;when&nbsp;the&nbsp;buffer&nbsp;goes&nbsp;strictly&nbsp;over&nbsp;the&nbsp;high-water&nbsp;mark<br>
(even&nbsp;if&nbsp;subsequent&nbsp;writes&nbsp;increases&nbsp;the&nbsp;buffer&nbsp;size&nbsp;even<br>
more),&nbsp;and&nbsp;eventually&nbsp;<a href="#DatagramProtocol-resume_writing">resume_writing</a>()&nbsp;is&nbsp;called&nbsp;once&nbsp;when&nbsp;the<br>
buffer&nbsp;size&nbsp;reaches&nbsp;the&nbsp;low-water&nbsp;mark.<br>
&nbsp;<br>
Note&nbsp;that&nbsp;if&nbsp;the&nbsp;buffer&nbsp;size&nbsp;equals&nbsp;the&nbsp;high-water&nbsp;mark,<br>
<a href="#DatagramProtocol-pause_writing">pause_writing</a>()&nbsp;is&nbsp;not&nbsp;called&nbsp;--&nbsp;it&nbsp;must&nbsp;go&nbsp;strictly&nbsp;over.<br>
Conversely,&nbsp;<a href="#DatagramProtocol-resume_writing">resume_writing</a>()&nbsp;is&nbsp;called&nbsp;when&nbsp;the&nbsp;buffer&nbsp;size&nbsp;is<br>
equal&nbsp;or&nbsp;lower&nbsp;than&nbsp;the&nbsp;low-water&nbsp;mark.&nbsp;&nbsp;These&nbsp;end&nbsp;conditions<br>
are&nbsp;important&nbsp;to&nbsp;ensure&nbsp;that&nbsp;things&nbsp;go&nbsp;as&nbsp;expected&nbsp;when&nbsp;either<br>
mark&nbsp;is&nbsp;zero.<br>
&nbsp;<br>
NOTE:&nbsp;This&nbsp;is&nbsp;the&nbsp;only&nbsp;<a href="#Protocol">Protocol</a>&nbsp;callback&nbsp;that&nbsp;is&nbsp;not&nbsp;called<br>
through&nbsp;EventLoop.call_soon()&nbsp;--&nbsp;if&nbsp;it&nbsp;were,&nbsp;it&nbsp;would&nbsp;have&nbsp;no<br>
effect&nbsp;when&nbsp;it's&nbsp;most&nbsp;needed&nbsp;(when&nbsp;the&nbsp;app&nbsp;keeps&nbsp;writing<br>
without&nbsp;yielding&nbsp;until&nbsp;<a href="#DatagramProtocol-pause_writing">pause_writing</a>()&nbsp;is&nbsp;called).</tt></dd></dl>

<dl><dt><a name="DatagramProtocol-resume_writing"><strong>resume_writing</strong></a>(self)</dt><dd><tt>Called&nbsp;when&nbsp;the&nbsp;transport's&nbsp;buffer&nbsp;drains&nbsp;below&nbsp;the&nbsp;low-water&nbsp;mark.<br>
&nbsp;<br>
See&nbsp;<a href="#DatagramProtocol-pause_writing">pause_writing</a>()&nbsp;for&nbsp;details.</tt></dd></dl>

</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="DatagramTransport">class <strong>DatagramTransport</strong></a>(<a href="asyncio.transports.html#BaseTransport">BaseTransport</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#DatagramTransport">DatagramTransport</a>(extra=None)<br>
&nbsp;<br>
Interface&nbsp;for&nbsp;datagram&nbsp;(UDP)&nbsp;transports.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="asyncio.transports.html#DatagramTransport">DatagramTransport</a></dd>
<dd><a href="asyncio.transports.html#BaseTransport">BaseTransport</a></dd>
<dd><a href="builtins.html#object">builtins.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="DatagramTransport-abort"><strong>abort</strong></a>(self)</dt><dd><tt>Close&nbsp;the&nbsp;transport&nbsp;immediately.<br>
&nbsp;<br>
Buffered&nbsp;data&nbsp;will&nbsp;be&nbsp;lost.&nbsp;&nbsp;No&nbsp;more&nbsp;data&nbsp;will&nbsp;be&nbsp;received.<br>
The&nbsp;protocol's&nbsp;connection_lost()&nbsp;method&nbsp;will&nbsp;(eventually)&nbsp;be<br>
called&nbsp;with&nbsp;None&nbsp;as&nbsp;its&nbsp;argument.</tt></dd></dl>

<dl><dt><a name="DatagramTransport-sendto"><strong>sendto</strong></a>(self, data, addr=None)</dt><dd><tt>Send&nbsp;data&nbsp;to&nbsp;the&nbsp;transport.<br>
&nbsp;<br>
This&nbsp;does&nbsp;not&nbsp;block;&nbsp;it&nbsp;buffers&nbsp;the&nbsp;data&nbsp;and&nbsp;arranges&nbsp;for&nbsp;it<br>
to&nbsp;be&nbsp;sent&nbsp;out&nbsp;asynchronously.<br>
addr&nbsp;is&nbsp;target&nbsp;socket&nbsp;address.<br>
If&nbsp;addr&nbsp;is&nbsp;None&nbsp;use&nbsp;target&nbsp;address&nbsp;pointed&nbsp;on&nbsp;transport&nbsp;creation.</tt></dd></dl>

<hr>
Methods inherited from <a href="asyncio.transports.html#BaseTransport">BaseTransport</a>:<br>
<dl><dt><a name="DatagramTransport-__init__"><strong>__init__</strong></a>(self, extra=None)</dt><dd><tt>Initialize&nbsp;self.&nbsp;&nbsp;See&nbsp;help(type(self))&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<dl><dt><a name="DatagramTransport-close"><strong>close</strong></a>(self)</dt><dd><tt>Close&nbsp;the&nbsp;transport.<br>
&nbsp;<br>
Buffered&nbsp;data&nbsp;will&nbsp;be&nbsp;flushed&nbsp;asynchronously.&nbsp;&nbsp;No&nbsp;more&nbsp;data<br>
will&nbsp;be&nbsp;received.&nbsp;&nbsp;After&nbsp;all&nbsp;buffered&nbsp;data&nbsp;is&nbsp;flushed,&nbsp;the<br>
protocol's&nbsp;connection_lost()&nbsp;method&nbsp;will&nbsp;(eventually)&nbsp;be<br>
called&nbsp;with&nbsp;None&nbsp;as&nbsp;its&nbsp;argument.</tt></dd></dl>

<dl><dt><a name="DatagramTransport-get_extra_info"><strong>get_extra_info</strong></a>(self, name, default=None)</dt><dd><tt>Get&nbsp;optional&nbsp;transport&nbsp;information.</tt></dd></dl>

<dl><dt><a name="DatagramTransport-get_protocol"><strong>get_protocol</strong></a>(self)</dt><dd><tt>Return&nbsp;the&nbsp;current&nbsp;protocol.</tt></dd></dl>

<dl><dt><a name="DatagramTransport-is_closing"><strong>is_closing</strong></a>(self)</dt><dd><tt>Return&nbsp;True&nbsp;if&nbsp;the&nbsp;transport&nbsp;is&nbsp;closing&nbsp;or&nbsp;closed.</tt></dd></dl>

<dl><dt><a name="DatagramTransport-set_protocol"><strong>set_protocol</strong></a>(self, protocol)</dt><dd><tt>Set&nbsp;a&nbsp;new&nbsp;protocol.</tt></dd></dl>

</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><strong>DefaultEventLoopPolicy</strong> = <a name="DefaultEventLoopPolicy">class WindowsProactorEventLoopPolicy</a>(<a href="asyncio.events.html#BaseDefaultEventLoopPolicy">asyncio.events.BaseDefaultEventLoopPolicy</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt>Default&nbsp;policy&nbsp;implementation&nbsp;for&nbsp;accessing&nbsp;the&nbsp;event&nbsp;loop.<br>
&nbsp;<br>
In&nbsp;this&nbsp;policy,&nbsp;each&nbsp;thread&nbsp;has&nbsp;its&nbsp;own&nbsp;event&nbsp;loop.&nbsp;&nbsp;However,&nbsp;we<br>
only&nbsp;automatically&nbsp;create&nbsp;an&nbsp;event&nbsp;loop&nbsp;by&nbsp;default&nbsp;for&nbsp;the&nbsp;main<br>
thread;&nbsp;other&nbsp;threads&nbsp;by&nbsp;default&nbsp;have&nbsp;no&nbsp;event&nbsp;loop.<br>
&nbsp;<br>
Other&nbsp;policies&nbsp;may&nbsp;have&nbsp;different&nbsp;rules&nbsp;(e.g.&nbsp;a&nbsp;single&nbsp;global<br>
event&nbsp;loop,&nbsp;or&nbsp;automatically&nbsp;creating&nbsp;an&nbsp;event&nbsp;loop&nbsp;per&nbsp;thread,&nbsp;or<br>
using&nbsp;some&nbsp;other&nbsp;notion&nbsp;of&nbsp;context&nbsp;to&nbsp;which&nbsp;an&nbsp;event&nbsp;loop&nbsp;is<br>
associated).<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="asyncio.windows_events.html#WindowsProactorEventLoopPolicy">WindowsProactorEventLoopPolicy</a></dd>
<dd><a href="asyncio.events.html#BaseDefaultEventLoopPolicy">asyncio.events.BaseDefaultEventLoopPolicy</a></dd>
<dd><a href="asyncio.events.html#AbstractEventLoopPolicy">asyncio.events.AbstractEventLoopPolicy</a></dd>
<dd><a href="builtins.html#object">builtins.object</a></dd>
</dl>
<hr>
Methods inherited from <a href="asyncio.events.html#BaseDefaultEventLoopPolicy">asyncio.events.BaseDefaultEventLoopPolicy</a>:<br>
<dl><dt><a name="WindowsProactorEventLoopPolicy-__init__"><strong>__init__</strong></a>(self)</dt><dd><tt>Initialize&nbsp;self.&nbsp;&nbsp;See&nbsp;help(type(self))&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<dl><dt><a name="WindowsProactorEventLoopPolicy-get_event_loop"><strong>get_event_loop</strong></a>(self)</dt><dd><tt>Get&nbsp;the&nbsp;event&nbsp;loop&nbsp;for&nbsp;the&nbsp;current&nbsp;context.<br>
&nbsp;<br>
Returns&nbsp;an&nbsp;instance&nbsp;of&nbsp;EventLoop&nbsp;or&nbsp;raises&nbsp;an&nbsp;exception.</tt></dd></dl>

<dl><dt><a name="WindowsProactorEventLoopPolicy-new_event_loop"><strong>new_event_loop</strong></a>(self)</dt><dd><tt>Create&nbsp;a&nbsp;new&nbsp;event&nbsp;loop.<br>
&nbsp;<br>
You&nbsp;must&nbsp;call&nbsp;<a href="#DefaultEventLoopPolicy-set_event_loop">set_event_loop</a>()&nbsp;to&nbsp;make&nbsp;this&nbsp;the&nbsp;current&nbsp;event<br>
loop.</tt></dd></dl>

<dl><dt><a name="WindowsProactorEventLoopPolicy-set_event_loop"><strong>set_event_loop</strong></a>(self, loop)</dt><dd><tt>Set&nbsp;the&nbsp;event&nbsp;loop.</tt></dd></dl>

<hr>
Methods inherited from <a href="asyncio.events.html#AbstractEventLoopPolicy">asyncio.events.AbstractEventLoopPolicy</a>:<br>
<dl><dt><a name="WindowsProactorEventLoopPolicy-get_child_watcher"><strong>get_child_watcher</strong></a>(self)</dt><dd><tt>Get&nbsp;the&nbsp;watcher&nbsp;for&nbsp;child&nbsp;processes.</tt></dd></dl>

<dl><dt><a name="WindowsProactorEventLoopPolicy-set_child_watcher"><strong>set_child_watcher</strong></a>(self, watcher)</dt><dd><tt>Set&nbsp;the&nbsp;watcher&nbsp;for&nbsp;child&nbsp;processes.</tt></dd></dl>

<hr>
Data descriptors inherited from <a href="asyncio.events.html#AbstractEventLoopPolicy">asyncio.events.AbstractEventLoopPolicy</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="Event">class <strong>Event</strong></a>(<a href="builtins.html#object">builtins.object</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#Event">Event</a>(*,&nbsp;loop=None)<br>
&nbsp;<br>
Asynchronous&nbsp;equivalent&nbsp;to&nbsp;threading.<a href="#Event">Event</a>.<br>
&nbsp;<br>
Class&nbsp;implementing&nbsp;event&nbsp;objects.&nbsp;An&nbsp;event&nbsp;manages&nbsp;a&nbsp;flag&nbsp;that&nbsp;can&nbsp;be&nbsp;set<br>
to&nbsp;true&nbsp;with&nbsp;the&nbsp;<a href="#Event-set">set</a>()&nbsp;method&nbsp;and&nbsp;reset&nbsp;to&nbsp;false&nbsp;with&nbsp;the&nbsp;<a href="#Event-clear">clear</a>()&nbsp;method.<br>
The&nbsp;<a href="#Event-wait">wait</a>()&nbsp;method&nbsp;blocks&nbsp;until&nbsp;the&nbsp;flag&nbsp;is&nbsp;true.&nbsp;The&nbsp;flag&nbsp;is&nbsp;initially<br>
false.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%">Methods defined here:<br>
<dl><dt><a name="Event-__init__"><strong>__init__</strong></a>(self, *, loop=None)</dt><dd><tt>Initialize&nbsp;self.&nbsp;&nbsp;See&nbsp;help(type(self))&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<dl><dt><a name="Event-__repr__"><strong>__repr__</strong></a>(self)</dt><dd><tt>Return&nbsp;repr(self).</tt></dd></dl>

<dl><dt><a name="Event-clear"><strong>clear</strong></a>(self)</dt><dd><tt>Reset&nbsp;the&nbsp;internal&nbsp;flag&nbsp;to&nbsp;false.&nbsp;Subsequently,&nbsp;coroutines&nbsp;calling<br>
<a href="#Event-wait">wait</a>()&nbsp;will&nbsp;block&nbsp;until&nbsp;<a href="#Event-set">set</a>()&nbsp;is&nbsp;called&nbsp;to&nbsp;set&nbsp;the&nbsp;internal&nbsp;flag<br>
to&nbsp;true&nbsp;again.</tt></dd></dl>

<dl><dt><a name="Event-is_set"><strong>is_set</strong></a>(self)</dt><dd><tt>Return&nbsp;True&nbsp;if&nbsp;and&nbsp;only&nbsp;if&nbsp;the&nbsp;internal&nbsp;flag&nbsp;is&nbsp;true.</tt></dd></dl>

<dl><dt><a name="Event-set"><strong>set</strong></a>(self)</dt><dd><tt>Set&nbsp;the&nbsp;internal&nbsp;flag&nbsp;to&nbsp;true.&nbsp;All&nbsp;coroutines&nbsp;waiting&nbsp;for&nbsp;it&nbsp;to<br>
become&nbsp;true&nbsp;are&nbsp;awakened.&nbsp;Coroutine&nbsp;that&nbsp;call&nbsp;<a href="#Event-wait">wait</a>()&nbsp;once&nbsp;the&nbsp;flag&nbsp;is<br>
true&nbsp;will&nbsp;not&nbsp;block&nbsp;at&nbsp;all.</tt></dd></dl>

<dl><dt>async <a name="Event-wait"><strong>wait</strong></a>(self)</dt><dd><tt>Block&nbsp;until&nbsp;the&nbsp;internal&nbsp;flag&nbsp;is&nbsp;true.<br>
&nbsp;<br>
If&nbsp;the&nbsp;internal&nbsp;flag&nbsp;is&nbsp;true&nbsp;on&nbsp;entry,&nbsp;return&nbsp;True<br>
immediately.&nbsp;&nbsp;Otherwise,&nbsp;block&nbsp;until&nbsp;another&nbsp;coroutine&nbsp;calls<br>
<a href="#Event-set">set</a>()&nbsp;to&nbsp;set&nbsp;the&nbsp;flag&nbsp;to&nbsp;true,&nbsp;then&nbsp;return&nbsp;True.</tt></dd></dl>

<hr>
Data descriptors defined here:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="Future">class <strong>Future</strong></a>(<a href="builtins.html#object">builtins.object</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#Future">Future</a>(*,&nbsp;loop=None)<br>
&nbsp;<br>
This&nbsp;class&nbsp;is&nbsp;*almost*&nbsp;compatible&nbsp;with&nbsp;concurrent.futures.<a href="#Future">Future</a>.<br>
&nbsp;<br>
Differences:<br>
&nbsp;<br>
-&nbsp;<a href="#Future-result">result</a>()&nbsp;and&nbsp;<a href="#Future-exception">exception</a>()&nbsp;do&nbsp;not&nbsp;take&nbsp;a&nbsp;timeout&nbsp;argument&nbsp;and<br>
&nbsp;&nbsp;raise&nbsp;an&nbsp;exception&nbsp;when&nbsp;the&nbsp;future&nbsp;isn't&nbsp;done&nbsp;yet.<br>
&nbsp;<br>
-&nbsp;Callbacks&nbsp;registered&nbsp;with&nbsp;<a href="#Future-add_done_callback">add_done_callback</a>()&nbsp;are&nbsp;always&nbsp;called<br>
&nbsp;&nbsp;via&nbsp;the&nbsp;event&nbsp;loop's&nbsp;call_soon_threadsafe().<br>
&nbsp;<br>
-&nbsp;This&nbsp;class&nbsp;is&nbsp;not&nbsp;compatible&nbsp;with&nbsp;the&nbsp;<a href="#-wait">wait</a>()&nbsp;and&nbsp;<a href="#-as_completed">as_completed</a>()<br>
&nbsp;&nbsp;methods&nbsp;in&nbsp;the&nbsp;concurrent.futures&nbsp;package.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%">Methods defined here:<br>
<dl><dt><a name="Future-__await__"><strong>__await__</strong></a>(self, /)</dt><dd><tt>Return&nbsp;an&nbsp;iterator&nbsp;to&nbsp;be&nbsp;used&nbsp;in&nbsp;await&nbsp;expression.</tt></dd></dl>

<dl><dt><a name="Future-__del__"><strong>__del__</strong></a>(...)</dt></dl>

<dl><dt><a name="Future-__init__"><strong>__init__</strong></a>(self, /, *args, **kwargs)</dt><dd><tt>Initialize&nbsp;self.&nbsp;&nbsp;See&nbsp;help(type(self))&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<dl><dt><a name="Future-__iter__"><strong>__iter__</strong></a>(self, /)</dt><dd><tt>Implement&nbsp;iter(self).</tt></dd></dl>

<dl><dt><a name="Future-__repr__"><strong>__repr__</strong></a>(self, /)</dt><dd><tt>Return&nbsp;repr(self).</tt></dd></dl>

<dl><dt><a name="Future-add_done_callback"><strong>add_done_callback</strong></a>(...)</dt><dd><tt>Add&nbsp;a&nbsp;callback&nbsp;to&nbsp;be&nbsp;run&nbsp;when&nbsp;the&nbsp;future&nbsp;becomes&nbsp;done.<br>
&nbsp;<br>
The&nbsp;callback&nbsp;is&nbsp;called&nbsp;with&nbsp;a&nbsp;single&nbsp;argument&nbsp;-&nbsp;the&nbsp;future&nbsp;<a href="builtins.html#object">object</a>.&nbsp;If<br>
the&nbsp;future&nbsp;is&nbsp;already&nbsp;done&nbsp;when&nbsp;this&nbsp;is&nbsp;called,&nbsp;the&nbsp;callback&nbsp;is<br>
scheduled&nbsp;with&nbsp;call_soon.</tt></dd></dl>

<dl><dt><a name="Future-cancel"><strong>cancel</strong></a>(self, /)</dt><dd><tt>Cancel&nbsp;the&nbsp;future&nbsp;and&nbsp;schedule&nbsp;callbacks.<br>
&nbsp;<br>
If&nbsp;the&nbsp;future&nbsp;is&nbsp;already&nbsp;done&nbsp;or&nbsp;cancelled,&nbsp;return&nbsp;False.&nbsp;&nbsp;Otherwise,<br>
change&nbsp;the&nbsp;future's&nbsp;state&nbsp;to&nbsp;cancelled,&nbsp;schedule&nbsp;the&nbsp;callbacks&nbsp;and<br>
return&nbsp;True.</tt></dd></dl>

<dl><dt><a name="Future-cancelled"><strong>cancelled</strong></a>(self, /)</dt><dd><tt>Return&nbsp;True&nbsp;if&nbsp;the&nbsp;future&nbsp;was&nbsp;cancelled.</tt></dd></dl>

<dl><dt><a name="Future-done"><strong>done</strong></a>(self, /)</dt><dd><tt>Return&nbsp;True&nbsp;if&nbsp;the&nbsp;future&nbsp;is&nbsp;done.<br>
&nbsp;<br>
Done&nbsp;means&nbsp;either&nbsp;that&nbsp;a&nbsp;result&nbsp;/&nbsp;exception&nbsp;are&nbsp;available,&nbsp;or&nbsp;that&nbsp;the<br>
future&nbsp;was&nbsp;cancelled.</tt></dd></dl>

<dl><dt><a name="Future-exception"><strong>exception</strong></a>(self, /)</dt><dd><tt>Return&nbsp;the&nbsp;exception&nbsp;that&nbsp;was&nbsp;set&nbsp;on&nbsp;this&nbsp;future.<br>
&nbsp;<br>
The&nbsp;exception&nbsp;(or&nbsp;None&nbsp;if&nbsp;no&nbsp;exception&nbsp;was&nbsp;set)&nbsp;is&nbsp;returned&nbsp;only&nbsp;if<br>
the&nbsp;future&nbsp;is&nbsp;done.&nbsp;&nbsp;If&nbsp;the&nbsp;future&nbsp;has&nbsp;been&nbsp;cancelled,&nbsp;raises<br>
<a href="#CancelledError">CancelledError</a>.&nbsp;&nbsp;If&nbsp;the&nbsp;future&nbsp;isn't&nbsp;done&nbsp;yet,&nbsp;raises<br>
<a href="#InvalidStateError">InvalidStateError</a>.</tt></dd></dl>

<dl><dt><a name="Future-get_loop"><strong>get_loop</strong></a>(self, /)</dt><dd><tt>Return&nbsp;the&nbsp;event&nbsp;loop&nbsp;the&nbsp;<a href="#Future">Future</a>&nbsp;is&nbsp;bound&nbsp;to.</tt></dd></dl>

<dl><dt><a name="Future-remove_done_callback"><strong>remove_done_callback</strong></a>(self, fn, /)</dt><dd><tt>Remove&nbsp;all&nbsp;instances&nbsp;of&nbsp;a&nbsp;callback&nbsp;from&nbsp;the&nbsp;"call&nbsp;when&nbsp;done"&nbsp;list.<br>
&nbsp;<br>
Returns&nbsp;the&nbsp;number&nbsp;of&nbsp;callbacks&nbsp;removed.</tt></dd></dl>

<dl><dt><a name="Future-result"><strong>result</strong></a>(self, /)</dt><dd><tt>Return&nbsp;the&nbsp;result&nbsp;this&nbsp;future&nbsp;represents.<br>
&nbsp;<br>
If&nbsp;the&nbsp;future&nbsp;has&nbsp;been&nbsp;cancelled,&nbsp;raises&nbsp;<a href="#CancelledError">CancelledError</a>.&nbsp;&nbsp;If&nbsp;the<br>
future's&nbsp;result&nbsp;isn't&nbsp;yet&nbsp;available,&nbsp;raises&nbsp;<a href="#InvalidStateError">InvalidStateError</a>.&nbsp;&nbsp;If<br>
the&nbsp;future&nbsp;is&nbsp;done&nbsp;and&nbsp;has&nbsp;an&nbsp;exception&nbsp;set,&nbsp;this&nbsp;exception&nbsp;is&nbsp;raised.</tt></dd></dl>

<dl><dt><a name="Future-set_exception"><strong>set_exception</strong></a>(self, exception, /)</dt><dd><tt>Mark&nbsp;the&nbsp;future&nbsp;done&nbsp;and&nbsp;set&nbsp;an&nbsp;exception.<br>
&nbsp;<br>
If&nbsp;the&nbsp;future&nbsp;is&nbsp;already&nbsp;done&nbsp;when&nbsp;this&nbsp;method&nbsp;is&nbsp;called,&nbsp;raises<br>
<a href="#InvalidStateError">InvalidStateError</a>.</tt></dd></dl>

<dl><dt><a name="Future-set_result"><strong>set_result</strong></a>(self, result, /)</dt><dd><tt>Mark&nbsp;the&nbsp;future&nbsp;done&nbsp;and&nbsp;set&nbsp;its&nbsp;result.<br>
&nbsp;<br>
If&nbsp;the&nbsp;future&nbsp;is&nbsp;already&nbsp;done&nbsp;when&nbsp;this&nbsp;method&nbsp;is&nbsp;called,&nbsp;raises<br>
<a href="#InvalidStateError">InvalidStateError</a>.</tt></dd></dl>

<hr>
Static methods defined here:<br>
<dl><dt><a name="Future-__new__"><strong>__new__</strong></a>(*args, **kwargs)<font color="#909090"><font face="helvetica, arial"> from <a href="builtins.html#type">builtins.type</a></font></font></dt><dd><tt>Create&nbsp;and&nbsp;return&nbsp;a&nbsp;new&nbsp;<a href="builtins.html#object">object</a>.&nbsp;&nbsp;See&nbsp;help(type)&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="Handle">class <strong>Handle</strong></a>(<a href="builtins.html#object">builtins.object</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#Handle">Handle</a>(callback,&nbsp;args,&nbsp;loop,&nbsp;context=None)<br>
&nbsp;<br>
Object&nbsp;returned&nbsp;by&nbsp;callback&nbsp;registration&nbsp;methods.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%">Methods defined here:<br>
<dl><dt><a name="Handle-__init__"><strong>__init__</strong></a>(self, callback, args, loop, context=None)</dt><dd><tt>Initialize&nbsp;self.&nbsp;&nbsp;See&nbsp;help(type(self))&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<dl><dt><a name="Handle-__repr__"><strong>__repr__</strong></a>(self)</dt><dd><tt>Return&nbsp;repr(self).</tt></dd></dl>

<dl><dt><a name="Handle-cancel"><strong>cancel</strong></a>(self)</dt></dl>

<dl><dt><a name="Handle-cancelled"><strong>cancelled</strong></a>(self)</dt></dl>

<hr>
Data descriptors defined here:<br>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="IncompleteReadError">class <strong>IncompleteReadError</strong></a>(<a href="builtins.html#EOFError">builtins.EOFError</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#IncompleteReadError">IncompleteReadError</a>(partial,&nbsp;expected)<br>
&nbsp;<br>
Incomplete&nbsp;read&nbsp;error.&nbsp;Attributes:<br>
&nbsp;<br>
-&nbsp;partial:&nbsp;read&nbsp;bytes&nbsp;string&nbsp;before&nbsp;the&nbsp;end&nbsp;of&nbsp;stream&nbsp;was&nbsp;reached<br>
-&nbsp;expected:&nbsp;total&nbsp;number&nbsp;of&nbsp;expected&nbsp;bytes&nbsp;(or&nbsp;None&nbsp;if&nbsp;unknown)<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="asyncio.exceptions.html#IncompleteReadError">IncompleteReadError</a></dd>
<dd><a href="builtins.html#EOFError">builtins.EOFError</a></dd>
<dd><a href="builtins.html#Exception">builtins.Exception</a></dd>
<dd><a href="builtins.html#BaseException">builtins.BaseException</a></dd>
<dd><a href="builtins.html#object">builtins.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="IncompleteReadError-__init__"><strong>__init__</strong></a>(self, partial, expected)</dt><dd><tt>Initialize&nbsp;self.&nbsp;&nbsp;See&nbsp;help(type(self))&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<dl><dt><a name="IncompleteReadError-__reduce__"><strong>__reduce__</strong></a>(self)</dt><dd><tt>Helper&nbsp;for&nbsp;pickle.</tt></dd></dl>

<hr>
Data descriptors defined here:<br>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<hr>
Static methods inherited from <a href="builtins.html#EOFError">builtins.EOFError</a>:<br>
<dl><dt><a name="IncompleteReadError-__new__"><strong>__new__</strong></a>(*args, **kwargs)<font color="#909090"><font face="helvetica, arial"> from <a href="builtins.html#type">builtins.type</a></font></font></dt><dd><tt>Create&nbsp;and&nbsp;return&nbsp;a&nbsp;new&nbsp;<a href="builtins.html#object">object</a>.&nbsp;&nbsp;See&nbsp;help(type)&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<hr>
Methods inherited from <a href="builtins.html#BaseException">builtins.BaseException</a>:<br>
<dl><dt><a name="IncompleteReadError-__delattr__"><strong>__delattr__</strong></a>(self, name, /)</dt><dd><tt>Implement&nbsp;delattr(self,&nbsp;name).</tt></dd></dl>

<dl><dt><a name="IncompleteReadError-__getattribute__"><strong>__getattribute__</strong></a>(self, name, /)</dt><dd><tt>Return&nbsp;getattr(self,&nbsp;name).</tt></dd></dl>

<dl><dt><a name="IncompleteReadError-__repr__"><strong>__repr__</strong></a>(self, /)</dt><dd><tt>Return&nbsp;repr(self).</tt></dd></dl>

<dl><dt><a name="IncompleteReadError-__setattr__"><strong>__setattr__</strong></a>(self, name, value, /)</dt><dd><tt>Implement&nbsp;setattr(self,&nbsp;name,&nbsp;value).</tt></dd></dl>

<dl><dt><a name="IncompleteReadError-__setstate__"><strong>__setstate__</strong></a>(...)</dt></dl>

<dl><dt><a name="IncompleteReadError-__str__"><strong>__str__</strong></a>(self, /)</dt><dd><tt>Return&nbsp;str(self).</tt></dd></dl>

<dl><dt><a name="IncompleteReadError-with_traceback"><strong>with_traceback</strong></a>(...)</dt><dd><tt><a href="builtins.html#Exception">Exception</a>.<a href="#IncompleteReadError-with_traceback">with_traceback</a>(tb)&nbsp;--<br>
set&nbsp;self.<strong>__traceback__</strong>&nbsp;to&nbsp;tb&nbsp;and&nbsp;return&nbsp;self.</tt></dd></dl>

<hr>
Data descriptors inherited from <a href="builtins.html#BaseException">builtins.BaseException</a>:<br>
<dl><dt><strong>__cause__</strong></dt>
<dd><tt>exception&nbsp;cause</tt></dd>
</dl>
<dl><dt><strong>__context__</strong></dt>
<dd><tt>exception&nbsp;context</tt></dd>
</dl>
<dl><dt><strong>__dict__</strong></dt>
</dl>
<dl><dt><strong>__suppress_context__</strong></dt>
</dl>
<dl><dt><strong>__traceback__</strong></dt>
</dl>
<dl><dt><strong>args</strong></dt>
</dl>
</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="InvalidStateError">class <strong>InvalidStateError</strong></a>(<a href="builtins.html#Exception">builtins.Exception</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt>The&nbsp;operation&nbsp;is&nbsp;not&nbsp;allowed&nbsp;in&nbsp;this&nbsp;state.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="asyncio.exceptions.html#InvalidStateError">InvalidStateError</a></dd>
<dd><a href="builtins.html#Exception">builtins.Exception</a></dd>
<dd><a href="builtins.html#BaseException">builtins.BaseException</a></dd>
<dd><a href="builtins.html#object">builtins.object</a></dd>
</dl>
<hr>
Data descriptors defined here:<br>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<hr>
Methods inherited from <a href="builtins.html#Exception">builtins.Exception</a>:<br>
<dl><dt><a name="InvalidStateError-__init__"><strong>__init__</strong></a>(self, /, *args, **kwargs)</dt><dd><tt>Initialize&nbsp;self.&nbsp;&nbsp;See&nbsp;help(type(self))&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<hr>
Static methods inherited from <a href="builtins.html#Exception">builtins.Exception</a>:<br>
<dl><dt><a name="InvalidStateError-__new__"><strong>__new__</strong></a>(*args, **kwargs)<font color="#909090"><font face="helvetica, arial"> from <a href="builtins.html#type">builtins.type</a></font></font></dt><dd><tt>Create&nbsp;and&nbsp;return&nbsp;a&nbsp;new&nbsp;<a href="builtins.html#object">object</a>.&nbsp;&nbsp;See&nbsp;help(type)&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<hr>
Methods inherited from <a href="builtins.html#BaseException">builtins.BaseException</a>:<br>
<dl><dt><a name="InvalidStateError-__delattr__"><strong>__delattr__</strong></a>(self, name, /)</dt><dd><tt>Implement&nbsp;delattr(self,&nbsp;name).</tt></dd></dl>

<dl><dt><a name="InvalidStateError-__getattribute__"><strong>__getattribute__</strong></a>(self, name, /)</dt><dd><tt>Return&nbsp;getattr(self,&nbsp;name).</tt></dd></dl>

<dl><dt><a name="InvalidStateError-__reduce__"><strong>__reduce__</strong></a>(...)</dt><dd><tt>Helper&nbsp;for&nbsp;pickle.</tt></dd></dl>

<dl><dt><a name="InvalidStateError-__repr__"><strong>__repr__</strong></a>(self, /)</dt><dd><tt>Return&nbsp;repr(self).</tt></dd></dl>

<dl><dt><a name="InvalidStateError-__setattr__"><strong>__setattr__</strong></a>(self, name, value, /)</dt><dd><tt>Implement&nbsp;setattr(self,&nbsp;name,&nbsp;value).</tt></dd></dl>

<dl><dt><a name="InvalidStateError-__setstate__"><strong>__setstate__</strong></a>(...)</dt></dl>

<dl><dt><a name="InvalidStateError-__str__"><strong>__str__</strong></a>(self, /)</dt><dd><tt>Return&nbsp;str(self).</tt></dd></dl>

<dl><dt><a name="InvalidStateError-with_traceback"><strong>with_traceback</strong></a>(...)</dt><dd><tt><a href="builtins.html#Exception">Exception</a>.<a href="#InvalidStateError-with_traceback">with_traceback</a>(tb)&nbsp;--<br>
set&nbsp;self.<strong>__traceback__</strong>&nbsp;to&nbsp;tb&nbsp;and&nbsp;return&nbsp;self.</tt></dd></dl>

<hr>
Data descriptors inherited from <a href="builtins.html#BaseException">builtins.BaseException</a>:<br>
<dl><dt><strong>__cause__</strong></dt>
<dd><tt>exception&nbsp;cause</tt></dd>
</dl>
<dl><dt><strong>__context__</strong></dt>
<dd><tt>exception&nbsp;context</tt></dd>
</dl>
<dl><dt><strong>__dict__</strong></dt>
</dl>
<dl><dt><strong>__suppress_context__</strong></dt>
</dl>
<dl><dt><strong>__traceback__</strong></dt>
</dl>
<dl><dt><strong>args</strong></dt>
</dl>
</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="IocpProactor">class <strong>IocpProactor</strong></a>(<a href="builtins.html#object">builtins.object</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#IocpProactor">IocpProactor</a>(concurrency=4294967295)<br>
&nbsp;<br>
Proactor&nbsp;implementation&nbsp;using&nbsp;IOCP.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%">Methods defined here:<br>
<dl><dt><a name="IocpProactor-__del__"><strong>__del__</strong></a>(self)</dt></dl>

<dl><dt><a name="IocpProactor-__init__"><strong>__init__</strong></a>(self, concurrency=4294967295)</dt><dd><tt>Initialize&nbsp;self.&nbsp;&nbsp;See&nbsp;help(type(self))&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<dl><dt><a name="IocpProactor-__repr__"><strong>__repr__</strong></a>(self)</dt><dd><tt>Return&nbsp;repr(self).</tt></dd></dl>

<dl><dt><a name="IocpProactor-accept"><strong>accept</strong></a>(self, listener)</dt></dl>

<dl><dt><a name="IocpProactor-accept_pipe"><strong>accept_pipe</strong></a>(self, pipe)</dt></dl>

<dl><dt><a name="IocpProactor-close"><strong>close</strong></a>(self)</dt></dl>

<dl><dt><a name="IocpProactor-connect"><strong>connect</strong></a>(self, conn, address)</dt></dl>

<dl><dt>async <a name="IocpProactor-connect_pipe"><strong>connect_pipe</strong></a>(self, address)</dt></dl>

<dl><dt><a name="IocpProactor-recv"><strong>recv</strong></a>(self, conn, nbytes, flags=0)</dt></dl>

<dl><dt><a name="IocpProactor-recv_into"><strong>recv_into</strong></a>(self, conn, buf, flags=0)</dt></dl>

<dl><dt><a name="IocpProactor-recvfrom"><strong>recvfrom</strong></a>(self, conn, nbytes, flags=0)</dt></dl>

<dl><dt><a name="IocpProactor-select"><strong>select</strong></a>(self, timeout=None)</dt></dl>

<dl><dt><a name="IocpProactor-send"><strong>send</strong></a>(self, conn, buf, flags=0)</dt></dl>

<dl><dt><a name="IocpProactor-sendfile"><strong>sendfile</strong></a>(self, sock, file, offset, count)</dt></dl>

<dl><dt><a name="IocpProactor-sendto"><strong>sendto</strong></a>(self, conn, buf, flags=0, addr=None)</dt></dl>

<dl><dt><a name="IocpProactor-set_loop"><strong>set_loop</strong></a>(self, loop)</dt></dl>

<dl><dt><a name="IocpProactor-wait_for_handle"><strong>wait_for_handle</strong></a>(self, handle, timeout=None)</dt><dd><tt>Wait&nbsp;for&nbsp;a&nbsp;handle.<br>
&nbsp;<br>
Return&nbsp;a&nbsp;<a href="#Future">Future</a>&nbsp;<a href="builtins.html#object">object</a>.&nbsp;The&nbsp;result&nbsp;of&nbsp;the&nbsp;future&nbsp;is&nbsp;True&nbsp;if&nbsp;the&nbsp;wait<br>
completed,&nbsp;or&nbsp;False&nbsp;if&nbsp;the&nbsp;wait&nbsp;did&nbsp;not&nbsp;complete&nbsp;(on&nbsp;timeout).</tt></dd></dl>

<hr>
Data descriptors defined here:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="LifoQueue">class <strong>LifoQueue</strong></a>(<a href="asyncio.queues.html#Queue">Queue</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#LifoQueue">LifoQueue</a>(maxsize=0,&nbsp;*,&nbsp;loop=None)<br>
&nbsp;<br>
A&nbsp;subclass&nbsp;of&nbsp;<a href="#Queue">Queue</a>&nbsp;that&nbsp;retrieves&nbsp;most&nbsp;recently&nbsp;added&nbsp;entries&nbsp;first.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="asyncio.queues.html#LifoQueue">LifoQueue</a></dd>
<dd><a href="asyncio.queues.html#Queue">Queue</a></dd>
<dd><a href="builtins.html#object">builtins.object</a></dd>
</dl>
<hr>
Methods inherited from <a href="asyncio.queues.html#Queue">Queue</a>:<br>
<dl><dt><a name="LifoQueue-__init__"><strong>__init__</strong></a>(self, maxsize=0, *, loop=None)</dt><dd><tt>Initialize&nbsp;self.&nbsp;&nbsp;See&nbsp;help(type(self))&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<dl><dt><a name="LifoQueue-__repr__"><strong>__repr__</strong></a>(self)</dt><dd><tt>Return&nbsp;repr(self).</tt></dd></dl>

<dl><dt><a name="LifoQueue-__str__"><strong>__str__</strong></a>(self)</dt><dd><tt>Return&nbsp;str(self).</tt></dd></dl>

<dl><dt><a name="LifoQueue-empty"><strong>empty</strong></a>(self)</dt><dd><tt>Return&nbsp;True&nbsp;if&nbsp;the&nbsp;queue&nbsp;is&nbsp;empty,&nbsp;False&nbsp;otherwise.</tt></dd></dl>

<dl><dt><a name="LifoQueue-full"><strong>full</strong></a>(self)</dt><dd><tt>Return&nbsp;True&nbsp;if&nbsp;there&nbsp;are&nbsp;maxsize&nbsp;items&nbsp;in&nbsp;the&nbsp;queue.<br>
&nbsp;<br>
Note:&nbsp;if&nbsp;the&nbsp;<a href="#Queue">Queue</a>&nbsp;was&nbsp;initialized&nbsp;with&nbsp;maxsize=0&nbsp;(the&nbsp;default),<br>
then&nbsp;<a href="#LifoQueue-full">full</a>()&nbsp;is&nbsp;never&nbsp;True.</tt></dd></dl>

<dl><dt>async <a name="LifoQueue-get"><strong>get</strong></a>(self)</dt><dd><tt>Remove&nbsp;and&nbsp;return&nbsp;an&nbsp;item&nbsp;from&nbsp;the&nbsp;queue.<br>
&nbsp;<br>
If&nbsp;queue&nbsp;is&nbsp;empty,&nbsp;wait&nbsp;until&nbsp;an&nbsp;item&nbsp;is&nbsp;available.</tt></dd></dl>

<dl><dt><a name="LifoQueue-get_nowait"><strong>get_nowait</strong></a>(self)</dt><dd><tt>Remove&nbsp;and&nbsp;return&nbsp;an&nbsp;item&nbsp;from&nbsp;the&nbsp;queue.<br>
&nbsp;<br>
Return&nbsp;an&nbsp;item&nbsp;if&nbsp;one&nbsp;is&nbsp;immediately&nbsp;available,&nbsp;else&nbsp;raise&nbsp;<a href="#QueueEmpty">QueueEmpty</a>.</tt></dd></dl>

<dl><dt>async <a name="LifoQueue-join"><strong>join</strong></a>(self)</dt><dd><tt>Block&nbsp;until&nbsp;all&nbsp;items&nbsp;in&nbsp;the&nbsp;queue&nbsp;have&nbsp;been&nbsp;gotten&nbsp;and&nbsp;processed.<br>
&nbsp;<br>
The&nbsp;count&nbsp;of&nbsp;unfinished&nbsp;tasks&nbsp;goes&nbsp;up&nbsp;whenever&nbsp;an&nbsp;item&nbsp;is&nbsp;added&nbsp;to&nbsp;the<br>
queue.&nbsp;The&nbsp;count&nbsp;goes&nbsp;down&nbsp;whenever&nbsp;a&nbsp;consumer&nbsp;calls&nbsp;<a href="#LifoQueue-task_done">task_done</a>()&nbsp;to<br>
indicate&nbsp;that&nbsp;the&nbsp;item&nbsp;was&nbsp;retrieved&nbsp;and&nbsp;all&nbsp;work&nbsp;on&nbsp;it&nbsp;is&nbsp;complete.<br>
When&nbsp;the&nbsp;count&nbsp;of&nbsp;unfinished&nbsp;tasks&nbsp;drops&nbsp;to&nbsp;zero,&nbsp;<a href="#LifoQueue-join">join</a>()&nbsp;unblocks.</tt></dd></dl>

<dl><dt>async <a name="LifoQueue-put"><strong>put</strong></a>(self, item)</dt><dd><tt>Put&nbsp;an&nbsp;item&nbsp;into&nbsp;the&nbsp;queue.<br>
&nbsp;<br>
Put&nbsp;an&nbsp;item&nbsp;into&nbsp;the&nbsp;queue.&nbsp;If&nbsp;the&nbsp;queue&nbsp;is&nbsp;full,&nbsp;wait&nbsp;until&nbsp;a&nbsp;free<br>
slot&nbsp;is&nbsp;available&nbsp;before&nbsp;adding&nbsp;item.</tt></dd></dl>

<dl><dt><a name="LifoQueue-put_nowait"><strong>put_nowait</strong></a>(self, item)</dt><dd><tt>Put&nbsp;an&nbsp;item&nbsp;into&nbsp;the&nbsp;queue&nbsp;without&nbsp;blocking.<br>
&nbsp;<br>
If&nbsp;no&nbsp;free&nbsp;slot&nbsp;is&nbsp;immediately&nbsp;available,&nbsp;raise&nbsp;<a href="#QueueFull">QueueFull</a>.</tt></dd></dl>

<dl><dt><a name="LifoQueue-qsize"><strong>qsize</strong></a>(self)</dt><dd><tt>Number&nbsp;of&nbsp;items&nbsp;in&nbsp;the&nbsp;queue.</tt></dd></dl>

<dl><dt><a name="LifoQueue-task_done"><strong>task_done</strong></a>(self)</dt><dd><tt>Indicate&nbsp;that&nbsp;a&nbsp;formerly&nbsp;enqueued&nbsp;task&nbsp;is&nbsp;complete.<br>
&nbsp;<br>
Used&nbsp;by&nbsp;queue&nbsp;consumers.&nbsp;For&nbsp;each&nbsp;<a href="#LifoQueue-get">get</a>()&nbsp;used&nbsp;to&nbsp;fetch&nbsp;a&nbsp;task,<br>
a&nbsp;subsequent&nbsp;call&nbsp;to&nbsp;<a href="#LifoQueue-task_done">task_done</a>()&nbsp;tells&nbsp;the&nbsp;queue&nbsp;that&nbsp;the&nbsp;processing<br>
on&nbsp;the&nbsp;task&nbsp;is&nbsp;complete.<br>
&nbsp;<br>
If&nbsp;a&nbsp;<a href="#LifoQueue-join">join</a>()&nbsp;is&nbsp;currently&nbsp;blocking,&nbsp;it&nbsp;will&nbsp;resume&nbsp;when&nbsp;all&nbsp;items&nbsp;have<br>
been&nbsp;processed&nbsp;(meaning&nbsp;that&nbsp;a&nbsp;<a href="#LifoQueue-task_done">task_done</a>()&nbsp;call&nbsp;was&nbsp;received&nbsp;for&nbsp;every<br>
item&nbsp;that&nbsp;had&nbsp;been&nbsp;<a href="#LifoQueue-put">put</a>()&nbsp;into&nbsp;the&nbsp;queue).<br>
&nbsp;<br>
Raises&nbsp;ValueError&nbsp;if&nbsp;called&nbsp;more&nbsp;times&nbsp;than&nbsp;there&nbsp;were&nbsp;items&nbsp;placed&nbsp;in<br>
the&nbsp;queue.</tt></dd></dl>

<hr>
Readonly properties inherited from <a href="asyncio.queues.html#Queue">Queue</a>:<br>
<dl><dt><strong>maxsize</strong></dt>
<dd><tt>Number&nbsp;of&nbsp;items&nbsp;allowed&nbsp;in&nbsp;the&nbsp;queue.</tt></dd>
</dl>
<hr>
Data descriptors inherited from <a href="asyncio.queues.html#Queue">Queue</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="LimitOverrunError">class <strong>LimitOverrunError</strong></a>(<a href="builtins.html#Exception">builtins.Exception</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#LimitOverrunError">LimitOverrunError</a>(message,&nbsp;consumed)<br>
&nbsp;<br>
Reached&nbsp;the&nbsp;buffer&nbsp;limit&nbsp;while&nbsp;looking&nbsp;for&nbsp;a&nbsp;separator.<br>
&nbsp;<br>
Attributes:<br>
-&nbsp;consumed:&nbsp;total&nbsp;number&nbsp;of&nbsp;to&nbsp;be&nbsp;consumed&nbsp;bytes.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="asyncio.exceptions.html#LimitOverrunError">LimitOverrunError</a></dd>
<dd><a href="builtins.html#Exception">builtins.Exception</a></dd>
<dd><a href="builtins.html#BaseException">builtins.BaseException</a></dd>
<dd><a href="builtins.html#object">builtins.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="LimitOverrunError-__init__"><strong>__init__</strong></a>(self, message, consumed)</dt><dd><tt>Initialize&nbsp;self.&nbsp;&nbsp;See&nbsp;help(type(self))&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<dl><dt><a name="LimitOverrunError-__reduce__"><strong>__reduce__</strong></a>(self)</dt><dd><tt>Helper&nbsp;for&nbsp;pickle.</tt></dd></dl>

<hr>
Data descriptors defined here:<br>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<hr>
Static methods inherited from <a href="builtins.html#Exception">builtins.Exception</a>:<br>
<dl><dt><a name="LimitOverrunError-__new__"><strong>__new__</strong></a>(*args, **kwargs)<font color="#909090"><font face="helvetica, arial"> from <a href="builtins.html#type">builtins.type</a></font></font></dt><dd><tt>Create&nbsp;and&nbsp;return&nbsp;a&nbsp;new&nbsp;<a href="builtins.html#object">object</a>.&nbsp;&nbsp;See&nbsp;help(type)&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<hr>
Methods inherited from <a href="builtins.html#BaseException">builtins.BaseException</a>:<br>
<dl><dt><a name="LimitOverrunError-__delattr__"><strong>__delattr__</strong></a>(self, name, /)</dt><dd><tt>Implement&nbsp;delattr(self,&nbsp;name).</tt></dd></dl>

<dl><dt><a name="LimitOverrunError-__getattribute__"><strong>__getattribute__</strong></a>(self, name, /)</dt><dd><tt>Return&nbsp;getattr(self,&nbsp;name).</tt></dd></dl>

<dl><dt><a name="LimitOverrunError-__repr__"><strong>__repr__</strong></a>(self, /)</dt><dd><tt>Return&nbsp;repr(self).</tt></dd></dl>

<dl><dt><a name="LimitOverrunError-__setattr__"><strong>__setattr__</strong></a>(self, name, value, /)</dt><dd><tt>Implement&nbsp;setattr(self,&nbsp;name,&nbsp;value).</tt></dd></dl>

<dl><dt><a name="LimitOverrunError-__setstate__"><strong>__setstate__</strong></a>(...)</dt></dl>

<dl><dt><a name="LimitOverrunError-__str__"><strong>__str__</strong></a>(self, /)</dt><dd><tt>Return&nbsp;str(self).</tt></dd></dl>

<dl><dt><a name="LimitOverrunError-with_traceback"><strong>with_traceback</strong></a>(...)</dt><dd><tt><a href="builtins.html#Exception">Exception</a>.<a href="#LimitOverrunError-with_traceback">with_traceback</a>(tb)&nbsp;--<br>
set&nbsp;self.<strong>__traceback__</strong>&nbsp;to&nbsp;tb&nbsp;and&nbsp;return&nbsp;self.</tt></dd></dl>

<hr>
Data descriptors inherited from <a href="builtins.html#BaseException">builtins.BaseException</a>:<br>
<dl><dt><strong>__cause__</strong></dt>
<dd><tt>exception&nbsp;cause</tt></dd>
</dl>
<dl><dt><strong>__context__</strong></dt>
<dd><tt>exception&nbsp;context</tt></dd>
</dl>
<dl><dt><strong>__dict__</strong></dt>
</dl>
<dl><dt><strong>__suppress_context__</strong></dt>
</dl>
<dl><dt><strong>__traceback__</strong></dt>
</dl>
<dl><dt><strong>args</strong></dt>
</dl>
</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="Lock">class <strong>Lock</strong></a>(<a href="asyncio.locks.html#_ContextManagerMixin">_ContextManagerMixin</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#Lock">Lock</a>(*,&nbsp;loop=None)<br>
&nbsp;<br>
Primitive&nbsp;lock&nbsp;objects.<br>
&nbsp;<br>
A&nbsp;primitive&nbsp;lock&nbsp;is&nbsp;a&nbsp;synchronization&nbsp;primitive&nbsp;that&nbsp;is&nbsp;not&nbsp;owned<br>
by&nbsp;a&nbsp;particular&nbsp;coroutine&nbsp;when&nbsp;locked.&nbsp;&nbsp;A&nbsp;primitive&nbsp;lock&nbsp;is&nbsp;in&nbsp;one<br>
of&nbsp;two&nbsp;states,&nbsp;'locked'&nbsp;or&nbsp;'unlocked'.<br>
&nbsp;<br>
It&nbsp;is&nbsp;created&nbsp;in&nbsp;the&nbsp;unlocked&nbsp;state.&nbsp;&nbsp;It&nbsp;has&nbsp;two&nbsp;basic&nbsp;methods,<br>
<a href="#Lock-acquire">acquire</a>()&nbsp;and&nbsp;<a href="#Lock-release">release</a>().&nbsp;&nbsp;When&nbsp;the&nbsp;state&nbsp;is&nbsp;unlocked,&nbsp;<a href="#Lock-acquire">acquire</a>()<br>
changes&nbsp;the&nbsp;state&nbsp;to&nbsp;locked&nbsp;and&nbsp;returns&nbsp;immediately.&nbsp;&nbsp;When&nbsp;the<br>
state&nbsp;is&nbsp;locked,&nbsp;<a href="#Lock-acquire">acquire</a>()&nbsp;blocks&nbsp;until&nbsp;a&nbsp;call&nbsp;to&nbsp;<a href="#Lock-release">release</a>()&nbsp;in<br>
another&nbsp;coroutine&nbsp;changes&nbsp;it&nbsp;to&nbsp;unlocked,&nbsp;then&nbsp;the&nbsp;<a href="#Lock-acquire">acquire</a>()&nbsp;call<br>
resets&nbsp;it&nbsp;to&nbsp;locked&nbsp;and&nbsp;returns.&nbsp;&nbsp;The&nbsp;<a href="#Lock-release">release</a>()&nbsp;method&nbsp;should&nbsp;only<br>
be&nbsp;called&nbsp;in&nbsp;the&nbsp;locked&nbsp;state;&nbsp;it&nbsp;changes&nbsp;the&nbsp;state&nbsp;to&nbsp;unlocked<br>
and&nbsp;returns&nbsp;immediately.&nbsp;&nbsp;If&nbsp;an&nbsp;attempt&nbsp;is&nbsp;made&nbsp;to&nbsp;release&nbsp;an<br>
unlocked&nbsp;lock,&nbsp;a&nbsp;<a href="builtins.html#RuntimeError">RuntimeError</a>&nbsp;will&nbsp;be&nbsp;raised.<br>
&nbsp;<br>
When&nbsp;more&nbsp;than&nbsp;one&nbsp;coroutine&nbsp;is&nbsp;blocked&nbsp;in&nbsp;<a href="#Lock-acquire">acquire</a>()&nbsp;waiting&nbsp;for<br>
the&nbsp;state&nbsp;to&nbsp;turn&nbsp;to&nbsp;unlocked,&nbsp;only&nbsp;one&nbsp;coroutine&nbsp;proceeds&nbsp;when&nbsp;a<br>
<a href="#Lock-release">release</a>()&nbsp;call&nbsp;resets&nbsp;the&nbsp;state&nbsp;to&nbsp;unlocked;&nbsp;first&nbsp;coroutine&nbsp;which<br>
is&nbsp;blocked&nbsp;in&nbsp;<a href="#Lock-acquire">acquire</a>()&nbsp;is&nbsp;being&nbsp;processed.<br>
&nbsp;<br>
<a href="#Lock-acquire">acquire</a>()&nbsp;is&nbsp;a&nbsp;coroutine&nbsp;and&nbsp;should&nbsp;be&nbsp;called&nbsp;with&nbsp;'await'.<br>
&nbsp;<br>
Locks&nbsp;also&nbsp;support&nbsp;the&nbsp;asynchronous&nbsp;context&nbsp;management&nbsp;protocol.<br>
'async&nbsp;with&nbsp;lock'&nbsp;statement&nbsp;should&nbsp;be&nbsp;used.<br>
&nbsp;<br>
Usage:<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;=&nbsp;<a href="#Lock">Lock</a>()<br>
&nbsp;&nbsp;&nbsp;&nbsp;...<br>
&nbsp;&nbsp;&nbsp;&nbsp;await&nbsp;lock.<a href="#Lock-acquire">acquire</a>()<br>
&nbsp;&nbsp;&nbsp;&nbsp;try:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>
&nbsp;&nbsp;&nbsp;&nbsp;finally:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lock.<a href="#Lock-release">release</a>()<br>
&nbsp;<br>
Context&nbsp;manager&nbsp;usage:<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;lock&nbsp;=&nbsp;<a href="#Lock">Lock</a>()<br>
&nbsp;&nbsp;&nbsp;&nbsp;...<br>
&nbsp;&nbsp;&nbsp;&nbsp;async&nbsp;with&nbsp;lock:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>
&nbsp;<br>
<a href="#Lock">Lock</a>&nbsp;objects&nbsp;can&nbsp;be&nbsp;tested&nbsp;for&nbsp;locking&nbsp;state:<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;not&nbsp;lock.<a href="#Lock-locked">locked</a>():<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;await&nbsp;lock.<a href="#Lock-acquire">acquire</a>()<br>
&nbsp;&nbsp;&nbsp;&nbsp;else:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;lock&nbsp;is&nbsp;acquired<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="asyncio.locks.html#Lock">Lock</a></dd>
<dd><a href="asyncio.locks.html#_ContextManagerMixin">_ContextManagerMixin</a></dd>
<dd><a href="builtins.html#object">builtins.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="Lock-__init__"><strong>__init__</strong></a>(self, *, loop=None)</dt><dd><tt>Initialize&nbsp;self.&nbsp;&nbsp;See&nbsp;help(type(self))&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<dl><dt><a name="Lock-__repr__"><strong>__repr__</strong></a>(self)</dt><dd><tt>Return&nbsp;repr(self).</tt></dd></dl>

<dl><dt>async <a name="Lock-acquire"><strong>acquire</strong></a>(self)</dt><dd><tt>Acquire&nbsp;a&nbsp;lock.<br>
&nbsp;<br>
This&nbsp;method&nbsp;blocks&nbsp;until&nbsp;the&nbsp;lock&nbsp;is&nbsp;unlocked,&nbsp;then&nbsp;sets&nbsp;it&nbsp;to<br>
locked&nbsp;and&nbsp;returns&nbsp;True.</tt></dd></dl>

<dl><dt><a name="Lock-locked"><strong>locked</strong></a>(self)</dt><dd><tt>Return&nbsp;True&nbsp;if&nbsp;lock&nbsp;is&nbsp;acquired.</tt></dd></dl>

<dl><dt><a name="Lock-release"><strong>release</strong></a>(self)</dt><dd><tt>Release&nbsp;a&nbsp;lock.<br>
&nbsp;<br>
When&nbsp;the&nbsp;lock&nbsp;is&nbsp;locked,&nbsp;reset&nbsp;it&nbsp;to&nbsp;unlocked,&nbsp;and&nbsp;return.<br>
If&nbsp;any&nbsp;other&nbsp;coroutines&nbsp;are&nbsp;blocked&nbsp;waiting&nbsp;for&nbsp;the&nbsp;lock&nbsp;to&nbsp;become<br>
unlocked,&nbsp;allow&nbsp;exactly&nbsp;one&nbsp;of&nbsp;them&nbsp;to&nbsp;proceed.<br>
&nbsp;<br>
When&nbsp;invoked&nbsp;on&nbsp;an&nbsp;unlocked&nbsp;lock,&nbsp;a&nbsp;<a href="builtins.html#RuntimeError">RuntimeError</a>&nbsp;is&nbsp;raised.<br>
&nbsp;<br>
There&nbsp;is&nbsp;no&nbsp;return&nbsp;value.</tt></dd></dl>

<hr>
Methods inherited from <a href="asyncio.locks.html#_ContextManagerMixin">_ContextManagerMixin</a>:<br>
<dl><dt>async <a name="Lock-__aenter__"><strong>__aenter__</strong></a>(self)</dt></dl>

<dl><dt>async <a name="Lock-__aexit__"><strong>__aexit__</strong></a>(self, exc_type, exc, tb)</dt></dl>

<dl><dt><a name="Lock-__await__"><strong>__await__</strong></a>(self)</dt></dl>

<dl><dt><a name="Lock-__enter__"><strong>__enter__</strong></a>(self)</dt></dl>

<dl><dt><a name="Lock-__exit__"><strong>__exit__</strong></a>(self, *args)</dt></dl>

<dl><dt><a name="Lock-__iter__"><strong>__iter__</strong></a>(self)</dt></dl>

<hr>
Data descriptors inherited from <a href="asyncio.locks.html#_ContextManagerMixin">_ContextManagerMixin</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="PriorityQueue">class <strong>PriorityQueue</strong></a>(<a href="asyncio.queues.html#Queue">Queue</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#PriorityQueue">PriorityQueue</a>(maxsize=0,&nbsp;*,&nbsp;loop=None)<br>
&nbsp;<br>
A&nbsp;subclass&nbsp;of&nbsp;<a href="#Queue">Queue</a>;&nbsp;retrieves&nbsp;entries&nbsp;in&nbsp;priority&nbsp;order&nbsp;(lowest&nbsp;first).<br>
&nbsp;<br>
Entries&nbsp;are&nbsp;typically&nbsp;tuples&nbsp;of&nbsp;the&nbsp;form:&nbsp;(priority&nbsp;number,&nbsp;data).<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="asyncio.queues.html#PriorityQueue">PriorityQueue</a></dd>
<dd><a href="asyncio.queues.html#Queue">Queue</a></dd>
<dd><a href="builtins.html#object">builtins.object</a></dd>
</dl>
<hr>
Methods inherited from <a href="asyncio.queues.html#Queue">Queue</a>:<br>
<dl><dt><a name="PriorityQueue-__init__"><strong>__init__</strong></a>(self, maxsize=0, *, loop=None)</dt><dd><tt>Initialize&nbsp;self.&nbsp;&nbsp;See&nbsp;help(type(self))&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<dl><dt><a name="PriorityQueue-__repr__"><strong>__repr__</strong></a>(self)</dt><dd><tt>Return&nbsp;repr(self).</tt></dd></dl>

<dl><dt><a name="PriorityQueue-__str__"><strong>__str__</strong></a>(self)</dt><dd><tt>Return&nbsp;str(self).</tt></dd></dl>

<dl><dt><a name="PriorityQueue-empty"><strong>empty</strong></a>(self)</dt><dd><tt>Return&nbsp;True&nbsp;if&nbsp;the&nbsp;queue&nbsp;is&nbsp;empty,&nbsp;False&nbsp;otherwise.</tt></dd></dl>

<dl><dt><a name="PriorityQueue-full"><strong>full</strong></a>(self)</dt><dd><tt>Return&nbsp;True&nbsp;if&nbsp;there&nbsp;are&nbsp;maxsize&nbsp;items&nbsp;in&nbsp;the&nbsp;queue.<br>
&nbsp;<br>
Note:&nbsp;if&nbsp;the&nbsp;<a href="#Queue">Queue</a>&nbsp;was&nbsp;initialized&nbsp;with&nbsp;maxsize=0&nbsp;(the&nbsp;default),<br>
then&nbsp;<a href="#PriorityQueue-full">full</a>()&nbsp;is&nbsp;never&nbsp;True.</tt></dd></dl>

<dl><dt>async <a name="PriorityQueue-get"><strong>get</strong></a>(self)</dt><dd><tt>Remove&nbsp;and&nbsp;return&nbsp;an&nbsp;item&nbsp;from&nbsp;the&nbsp;queue.<br>
&nbsp;<br>
If&nbsp;queue&nbsp;is&nbsp;empty,&nbsp;wait&nbsp;until&nbsp;an&nbsp;item&nbsp;is&nbsp;available.</tt></dd></dl>

<dl><dt><a name="PriorityQueue-get_nowait"><strong>get_nowait</strong></a>(self)</dt><dd><tt>Remove&nbsp;and&nbsp;return&nbsp;an&nbsp;item&nbsp;from&nbsp;the&nbsp;queue.<br>
&nbsp;<br>
Return&nbsp;an&nbsp;item&nbsp;if&nbsp;one&nbsp;is&nbsp;immediately&nbsp;available,&nbsp;else&nbsp;raise&nbsp;<a href="#QueueEmpty">QueueEmpty</a>.</tt></dd></dl>

<dl><dt>async <a name="PriorityQueue-join"><strong>join</strong></a>(self)</dt><dd><tt>Block&nbsp;until&nbsp;all&nbsp;items&nbsp;in&nbsp;the&nbsp;queue&nbsp;have&nbsp;been&nbsp;gotten&nbsp;and&nbsp;processed.<br>
&nbsp;<br>
The&nbsp;count&nbsp;of&nbsp;unfinished&nbsp;tasks&nbsp;goes&nbsp;up&nbsp;whenever&nbsp;an&nbsp;item&nbsp;is&nbsp;added&nbsp;to&nbsp;the<br>
queue.&nbsp;The&nbsp;count&nbsp;goes&nbsp;down&nbsp;whenever&nbsp;a&nbsp;consumer&nbsp;calls&nbsp;<a href="#PriorityQueue-task_done">task_done</a>()&nbsp;to<br>
indicate&nbsp;that&nbsp;the&nbsp;item&nbsp;was&nbsp;retrieved&nbsp;and&nbsp;all&nbsp;work&nbsp;on&nbsp;it&nbsp;is&nbsp;complete.<br>
When&nbsp;the&nbsp;count&nbsp;of&nbsp;unfinished&nbsp;tasks&nbsp;drops&nbsp;to&nbsp;zero,&nbsp;<a href="#PriorityQueue-join">join</a>()&nbsp;unblocks.</tt></dd></dl>

<dl><dt>async <a name="PriorityQueue-put"><strong>put</strong></a>(self, item)</dt><dd><tt>Put&nbsp;an&nbsp;item&nbsp;into&nbsp;the&nbsp;queue.<br>
&nbsp;<br>
Put&nbsp;an&nbsp;item&nbsp;into&nbsp;the&nbsp;queue.&nbsp;If&nbsp;the&nbsp;queue&nbsp;is&nbsp;full,&nbsp;wait&nbsp;until&nbsp;a&nbsp;free<br>
slot&nbsp;is&nbsp;available&nbsp;before&nbsp;adding&nbsp;item.</tt></dd></dl>

<dl><dt><a name="PriorityQueue-put_nowait"><strong>put_nowait</strong></a>(self, item)</dt><dd><tt>Put&nbsp;an&nbsp;item&nbsp;into&nbsp;the&nbsp;queue&nbsp;without&nbsp;blocking.<br>
&nbsp;<br>
If&nbsp;no&nbsp;free&nbsp;slot&nbsp;is&nbsp;immediately&nbsp;available,&nbsp;raise&nbsp;<a href="#QueueFull">QueueFull</a>.</tt></dd></dl>

<dl><dt><a name="PriorityQueue-qsize"><strong>qsize</strong></a>(self)</dt><dd><tt>Number&nbsp;of&nbsp;items&nbsp;in&nbsp;the&nbsp;queue.</tt></dd></dl>

<dl><dt><a name="PriorityQueue-task_done"><strong>task_done</strong></a>(self)</dt><dd><tt>Indicate&nbsp;that&nbsp;a&nbsp;formerly&nbsp;enqueued&nbsp;task&nbsp;is&nbsp;complete.<br>
&nbsp;<br>
Used&nbsp;by&nbsp;queue&nbsp;consumers.&nbsp;For&nbsp;each&nbsp;<a href="#PriorityQueue-get">get</a>()&nbsp;used&nbsp;to&nbsp;fetch&nbsp;a&nbsp;task,<br>
a&nbsp;subsequent&nbsp;call&nbsp;to&nbsp;<a href="#PriorityQueue-task_done">task_done</a>()&nbsp;tells&nbsp;the&nbsp;queue&nbsp;that&nbsp;the&nbsp;processing<br>
on&nbsp;the&nbsp;task&nbsp;is&nbsp;complete.<br>
&nbsp;<br>
If&nbsp;a&nbsp;<a href="#PriorityQueue-join">join</a>()&nbsp;is&nbsp;currently&nbsp;blocking,&nbsp;it&nbsp;will&nbsp;resume&nbsp;when&nbsp;all&nbsp;items&nbsp;have<br>
been&nbsp;processed&nbsp;(meaning&nbsp;that&nbsp;a&nbsp;<a href="#PriorityQueue-task_done">task_done</a>()&nbsp;call&nbsp;was&nbsp;received&nbsp;for&nbsp;every<br>
item&nbsp;that&nbsp;had&nbsp;been&nbsp;<a href="#PriorityQueue-put">put</a>()&nbsp;into&nbsp;the&nbsp;queue).<br>
&nbsp;<br>
Raises&nbsp;ValueError&nbsp;if&nbsp;called&nbsp;more&nbsp;times&nbsp;than&nbsp;there&nbsp;were&nbsp;items&nbsp;placed&nbsp;in<br>
the&nbsp;queue.</tt></dd></dl>

<hr>
Readonly properties inherited from <a href="asyncio.queues.html#Queue">Queue</a>:<br>
<dl><dt><strong>maxsize</strong></dt>
<dd><tt>Number&nbsp;of&nbsp;items&nbsp;allowed&nbsp;in&nbsp;the&nbsp;queue.</tt></dd>
</dl>
<hr>
Data descriptors inherited from <a href="asyncio.queues.html#Queue">Queue</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="ProactorEventLoop">class <strong>ProactorEventLoop</strong></a>(<a href="asyncio.proactor_events.html#BaseProactorEventLoop">asyncio.proactor_events.BaseProactorEventLoop</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#ProactorEventLoop">ProactorEventLoop</a>(proactor=None)<br>
&nbsp;<br>
Windows&nbsp;version&nbsp;of&nbsp;proactor&nbsp;event&nbsp;loop&nbsp;using&nbsp;IOCP.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="asyncio.windows_events.html#ProactorEventLoop">ProactorEventLoop</a></dd>
<dd><a href="asyncio.proactor_events.html#BaseProactorEventLoop">asyncio.proactor_events.BaseProactorEventLoop</a></dd>
<dd><a href="asyncio.base_events.html#BaseEventLoop">asyncio.base_events.BaseEventLoop</a></dd>
<dd><a href="asyncio.events.html#AbstractEventLoop">asyncio.events.AbstractEventLoop</a></dd>
<dd><a href="builtins.html#object">builtins.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="ProactorEventLoop-__init__"><strong>__init__</strong></a>(self, proactor=None)</dt><dd><tt>Initialize&nbsp;self.&nbsp;&nbsp;See&nbsp;help(type(self))&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<dl><dt>async <a name="ProactorEventLoop-create_pipe_connection"><strong>create_pipe_connection</strong></a>(self, protocol_factory, address)</dt></dl>

<dl><dt><a name="ProactorEventLoop-run_forever"><strong>run_forever</strong></a>(self)</dt><dd><tt>Run&nbsp;until&nbsp;<a href="#ProactorEventLoop-stop">stop</a>()&nbsp;is&nbsp;called.</tt></dd></dl>

<dl><dt>async <a name="ProactorEventLoop-start_serving_pipe"><strong>start_serving_pipe</strong></a>(self, protocol_factory, address)</dt></dl>

<hr>
Methods inherited from <a href="asyncio.proactor_events.html#BaseProactorEventLoop">asyncio.proactor_events.BaseProactorEventLoop</a>:<br>
<dl><dt><a name="ProactorEventLoop-close"><strong>close</strong></a>(self)</dt><dd><tt>Close&nbsp;the&nbsp;event&nbsp;loop.<br>
&nbsp;<br>
This&nbsp;clears&nbsp;the&nbsp;queues&nbsp;and&nbsp;shuts&nbsp;down&nbsp;the&nbsp;executor,<br>
but&nbsp;does&nbsp;not&nbsp;wait&nbsp;for&nbsp;the&nbsp;executor&nbsp;to&nbsp;finish.<br>
&nbsp;<br>
The&nbsp;event&nbsp;loop&nbsp;must&nbsp;not&nbsp;be&nbsp;running.</tt></dd></dl>

<dl><dt>async <a name="ProactorEventLoop-sock_accept"><strong>sock_accept</strong></a>(self, sock)</dt></dl>

<dl><dt>async <a name="ProactorEventLoop-sock_connect"><strong>sock_connect</strong></a>(self, sock, address)</dt></dl>

<dl><dt>async <a name="ProactorEventLoop-sock_recv"><strong>sock_recv</strong></a>(self, sock, n)</dt></dl>

<dl><dt>async <a name="ProactorEventLoop-sock_recv_into"><strong>sock_recv_into</strong></a>(self, sock, buf)</dt></dl>

<dl><dt>async <a name="ProactorEventLoop-sock_sendall"><strong>sock_sendall</strong></a>(self, sock, data)</dt></dl>

<hr>
Methods inherited from <a href="asyncio.base_events.html#BaseEventLoop">asyncio.base_events.BaseEventLoop</a>:<br>
<dl><dt><a name="ProactorEventLoop-__del__"><strong>__del__</strong></a>(self, _warn=&lt;built-in function warn&gt;)</dt></dl>

<dl><dt><a name="ProactorEventLoop-__repr__"><strong>__repr__</strong></a>(self)</dt><dd><tt>Return&nbsp;repr(self).</tt></dd></dl>

<dl><dt><a name="ProactorEventLoop-call_at"><strong>call_at</strong></a>(self, when, callback, *args, context=None)</dt><dd><tt>Like&nbsp;<a href="#ProactorEventLoop-call_later">call_later</a>(),&nbsp;but&nbsp;uses&nbsp;an&nbsp;absolute&nbsp;time.<br>
&nbsp;<br>
Absolute&nbsp;time&nbsp;corresponds&nbsp;to&nbsp;the&nbsp;event&nbsp;loop's&nbsp;<a href="#ProactorEventLoop-time">time</a>()&nbsp;method.</tt></dd></dl>

<dl><dt><a name="ProactorEventLoop-call_exception_handler"><strong>call_exception_handler</strong></a>(self, context)</dt><dd><tt>Call&nbsp;the&nbsp;current&nbsp;event&nbsp;loop's&nbsp;exception&nbsp;handler.<br>
&nbsp;<br>
The&nbsp;context&nbsp;argument&nbsp;is&nbsp;a&nbsp;dict&nbsp;containing&nbsp;the&nbsp;following&nbsp;keys:<br>
&nbsp;<br>
-&nbsp;'message':&nbsp;Error&nbsp;message;<br>
-&nbsp;'exception'&nbsp;(optional):&nbsp;<a href="builtins.html#Exception">Exception</a>&nbsp;<a href="builtins.html#object">object</a>;<br>
-&nbsp;'future'&nbsp;(optional):&nbsp;<a href="#Future">Future</a>&nbsp;instance;<br>
-&nbsp;'task'&nbsp;(optional):&nbsp;<a href="#Task">Task</a>&nbsp;instance;<br>
-&nbsp;'handle'&nbsp;(optional):&nbsp;<a href="#Handle">Handle</a>&nbsp;instance;<br>
-&nbsp;'protocol'&nbsp;(optional):&nbsp;<a href="#Protocol">Protocol</a>&nbsp;instance;<br>
-&nbsp;'transport'&nbsp;(optional):&nbsp;<a href="#Transport">Transport</a>&nbsp;instance;<br>
-&nbsp;'socket'&nbsp;(optional):&nbsp;Socket&nbsp;instance;<br>
-&nbsp;'asyncgen'&nbsp;(optional):&nbsp;Asynchronous&nbsp;generator&nbsp;that&nbsp;caused<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;exception.<br>
&nbsp;<br>
New&nbsp;keys&nbsp;maybe&nbsp;introduced&nbsp;in&nbsp;the&nbsp;future.<br>
&nbsp;<br>
Note:&nbsp;do&nbsp;not&nbsp;overload&nbsp;this&nbsp;method&nbsp;in&nbsp;an&nbsp;event&nbsp;loop&nbsp;subclass.<br>
For&nbsp;custom&nbsp;exception&nbsp;handling,&nbsp;use&nbsp;the<br>
`<a href="#ProactorEventLoop-set_exception_handler">set_exception_handler</a>()`&nbsp;method.</tt></dd></dl>

<dl><dt><a name="ProactorEventLoop-call_later"><strong>call_later</strong></a>(self, delay, callback, *args, context=None)</dt><dd><tt>Arrange&nbsp;for&nbsp;a&nbsp;callback&nbsp;to&nbsp;be&nbsp;called&nbsp;at&nbsp;a&nbsp;given&nbsp;time.<br>
&nbsp;<br>
Return&nbsp;a&nbsp;<a href="#Handle">Handle</a>:&nbsp;an&nbsp;opaque&nbsp;<a href="builtins.html#object">object</a>&nbsp;with&nbsp;a&nbsp;cancel()&nbsp;method&nbsp;that<br>
can&nbsp;be&nbsp;used&nbsp;to&nbsp;cancel&nbsp;the&nbsp;call.<br>
&nbsp;<br>
The&nbsp;delay&nbsp;can&nbsp;be&nbsp;an&nbsp;int&nbsp;or&nbsp;float,&nbsp;expressed&nbsp;in&nbsp;seconds.&nbsp;&nbsp;It&nbsp;is<br>
always&nbsp;relative&nbsp;to&nbsp;the&nbsp;current&nbsp;time.<br>
&nbsp;<br>
Each&nbsp;callback&nbsp;will&nbsp;be&nbsp;called&nbsp;exactly&nbsp;once.&nbsp;&nbsp;If&nbsp;two&nbsp;callbacks<br>
are&nbsp;scheduled&nbsp;for&nbsp;exactly&nbsp;the&nbsp;same&nbsp;time,&nbsp;it&nbsp;undefined&nbsp;which<br>
will&nbsp;be&nbsp;called&nbsp;first.<br>
&nbsp;<br>
Any&nbsp;positional&nbsp;arguments&nbsp;after&nbsp;the&nbsp;callback&nbsp;will&nbsp;be&nbsp;passed&nbsp;to<br>
the&nbsp;callback&nbsp;when&nbsp;it&nbsp;is&nbsp;called.</tt></dd></dl>

<dl><dt><a name="ProactorEventLoop-call_soon"><strong>call_soon</strong></a>(self, callback, *args, context=None)</dt><dd><tt>Arrange&nbsp;for&nbsp;a&nbsp;callback&nbsp;to&nbsp;be&nbsp;called&nbsp;as&nbsp;soon&nbsp;as&nbsp;possible.<br>
&nbsp;<br>
This&nbsp;operates&nbsp;as&nbsp;a&nbsp;FIFO&nbsp;queue:&nbsp;callbacks&nbsp;are&nbsp;called&nbsp;in&nbsp;the<br>
order&nbsp;in&nbsp;which&nbsp;they&nbsp;are&nbsp;registered.&nbsp;&nbsp;Each&nbsp;callback&nbsp;will&nbsp;be<br>
called&nbsp;exactly&nbsp;once.<br>
&nbsp;<br>
Any&nbsp;positional&nbsp;arguments&nbsp;after&nbsp;the&nbsp;callback&nbsp;will&nbsp;be&nbsp;passed&nbsp;to<br>
the&nbsp;callback&nbsp;when&nbsp;it&nbsp;is&nbsp;called.</tt></dd></dl>

<dl><dt><a name="ProactorEventLoop-call_soon_threadsafe"><strong>call_soon_threadsafe</strong></a>(self, callback, *args, context=None)</dt><dd><tt>Like&nbsp;<a href="#ProactorEventLoop-call_soon">call_soon</a>(),&nbsp;but&nbsp;thread-safe.</tt></dd></dl>

<dl><dt>async <a name="ProactorEventLoop-connect_accepted_socket"><strong>connect_accepted_socket</strong></a>(self, protocol_factory, sock, *, ssl=None, ssl_handshake_timeout=None)</dt><dd><tt><a href="#Handle">Handle</a>&nbsp;an&nbsp;accepted&nbsp;connection.<br>
&nbsp;<br>
This&nbsp;is&nbsp;used&nbsp;by&nbsp;servers&nbsp;that&nbsp;accept&nbsp;connections&nbsp;outside&nbsp;of<br>
asyncio&nbsp;but&nbsp;that&nbsp;use&nbsp;asyncio&nbsp;to&nbsp;handle&nbsp;connections.<br>
&nbsp;<br>
This&nbsp;method&nbsp;is&nbsp;a&nbsp;coroutine.&nbsp;&nbsp;When&nbsp;completed,&nbsp;the&nbsp;coroutine<br>
returns&nbsp;a&nbsp;(transport,&nbsp;protocol)&nbsp;pair.</tt></dd></dl>

<dl><dt>async <a name="ProactorEventLoop-connect_read_pipe"><strong>connect_read_pipe</strong></a>(self, protocol_factory, pipe)</dt><dd><tt>Register&nbsp;read&nbsp;pipe&nbsp;in&nbsp;event&nbsp;loop.&nbsp;Set&nbsp;the&nbsp;pipe&nbsp;to&nbsp;non-blocking&nbsp;mode.<br>
&nbsp;<br>
protocol_factory&nbsp;should&nbsp;instantiate&nbsp;<a href="builtins.html#object">object</a>&nbsp;with&nbsp;<a href="#Protocol">Protocol</a>&nbsp;interface.<br>
pipe&nbsp;is&nbsp;a&nbsp;file-like&nbsp;<a href="builtins.html#object">object</a>.<br>
Return&nbsp;pair&nbsp;(transport,&nbsp;protocol),&nbsp;where&nbsp;transport&nbsp;supports&nbsp;the<br>
<a href="#ReadTransport">ReadTransport</a>&nbsp;interface.</tt></dd></dl>

<dl><dt>async <a name="ProactorEventLoop-connect_write_pipe"><strong>connect_write_pipe</strong></a>(self, protocol_factory, pipe)</dt><dd><tt>Register&nbsp;write&nbsp;pipe&nbsp;in&nbsp;event&nbsp;loop.<br>
&nbsp;<br>
protocol_factory&nbsp;should&nbsp;instantiate&nbsp;<a href="builtins.html#object">object</a>&nbsp;with&nbsp;<a href="#BaseProtocol">BaseProtocol</a>&nbsp;interface.<br>
Pipe&nbsp;is&nbsp;file-like&nbsp;<a href="builtins.html#object">object</a>&nbsp;already&nbsp;switched&nbsp;to&nbsp;nonblocking.<br>
Return&nbsp;pair&nbsp;(transport,&nbsp;protocol),&nbsp;where&nbsp;transport&nbsp;support<br>
<a href="#WriteTransport">WriteTransport</a>&nbsp;interface.</tt></dd></dl>

<dl><dt>async <a name="ProactorEventLoop-create_connection"><strong>create_connection</strong></a>(self, protocol_factory, host=None, port=None, *, ssl=None, family=0, proto=0, flags=0, sock=None, local_addr=None, server_hostname=None, ssl_handshake_timeout=None, happy_eyeballs_delay=None, interleave=None)</dt><dd><tt>Connect&nbsp;to&nbsp;a&nbsp;TCP&nbsp;server.<br>
&nbsp;<br>
Create&nbsp;a&nbsp;streaming&nbsp;transport&nbsp;connection&nbsp;to&nbsp;a&nbsp;given&nbsp;Internet&nbsp;host&nbsp;and<br>
port:&nbsp;socket&nbsp;family&nbsp;AF_INET&nbsp;or&nbsp;socket.AF_INET6&nbsp;depending&nbsp;on&nbsp;host&nbsp;(or<br>
family&nbsp;if&nbsp;specified),&nbsp;socket&nbsp;type&nbsp;SOCK_STREAM.&nbsp;protocol_factory&nbsp;must&nbsp;be<br>
a&nbsp;callable&nbsp;returning&nbsp;a&nbsp;protocol&nbsp;instance.<br>
&nbsp;<br>
This&nbsp;method&nbsp;is&nbsp;a&nbsp;coroutine&nbsp;which&nbsp;will&nbsp;try&nbsp;to&nbsp;establish&nbsp;the&nbsp;connection<br>
in&nbsp;the&nbsp;background.&nbsp;&nbsp;When&nbsp;successful,&nbsp;the&nbsp;coroutine&nbsp;returns&nbsp;a<br>
(transport,&nbsp;protocol)&nbsp;pair.</tt></dd></dl>

<dl><dt>async <a name="ProactorEventLoop-create_datagram_endpoint"><strong>create_datagram_endpoint</strong></a>(self, protocol_factory, local_addr=None, remote_addr=None, *, family=0, proto=0, flags=0, reuse_address=&lt;object object at 0x000001ED9C15F660&gt;, reuse_port=None, allow_broadcast=None, sock=None)</dt><dd><tt>Create&nbsp;datagram&nbsp;connection.</tt></dd></dl>

<dl><dt><a name="ProactorEventLoop-create_future"><strong>create_future</strong></a>(self)</dt><dd><tt>Create&nbsp;a&nbsp;<a href="#Future">Future</a>&nbsp;<a href="builtins.html#object">object</a>&nbsp;attached&nbsp;to&nbsp;the&nbsp;loop.</tt></dd></dl>

<dl><dt>async <a name="ProactorEventLoop-create_server"><strong>create_server</strong></a>(self, protocol_factory, host=None, port=None, *, family=&lt;AddressFamily.AF_UNSPEC: 0&gt;, flags=&lt;AddressInfo.AI_PASSIVE: 1&gt;, sock=None, backlog=100, ssl=None, reuse_address=None, reuse_port=None, ssl_handshake_timeout=None, start_serving=True)</dt><dd><tt>Create&nbsp;a&nbsp;TCP&nbsp;server.<br>
&nbsp;<br>
The&nbsp;host&nbsp;parameter&nbsp;can&nbsp;be&nbsp;a&nbsp;string,&nbsp;in&nbsp;that&nbsp;case&nbsp;the&nbsp;TCP&nbsp;server&nbsp;is<br>
bound&nbsp;to&nbsp;host&nbsp;and&nbsp;port.<br>
&nbsp;<br>
The&nbsp;host&nbsp;parameter&nbsp;can&nbsp;also&nbsp;be&nbsp;a&nbsp;sequence&nbsp;of&nbsp;strings&nbsp;and&nbsp;in&nbsp;that&nbsp;case<br>
the&nbsp;TCP&nbsp;server&nbsp;is&nbsp;bound&nbsp;to&nbsp;all&nbsp;hosts&nbsp;of&nbsp;the&nbsp;sequence.&nbsp;If&nbsp;a&nbsp;host<br>
appears&nbsp;multiple&nbsp;times&nbsp;(possibly&nbsp;indirectly&nbsp;e.g.&nbsp;when&nbsp;hostnames<br>
resolve&nbsp;to&nbsp;the&nbsp;same&nbsp;IP&nbsp;address),&nbsp;the&nbsp;server&nbsp;is&nbsp;only&nbsp;bound&nbsp;once&nbsp;to&nbsp;that<br>
host.<br>
&nbsp;<br>
Return&nbsp;a&nbsp;Server&nbsp;<a href="builtins.html#object">object</a>&nbsp;which&nbsp;can&nbsp;be&nbsp;used&nbsp;to&nbsp;stop&nbsp;the&nbsp;service.<br>
&nbsp;<br>
This&nbsp;method&nbsp;is&nbsp;a&nbsp;coroutine.</tt></dd></dl>

<dl><dt><a name="ProactorEventLoop-create_task"><strong>create_task</strong></a>(self, coro, *, name=None)</dt><dd><tt>Schedule&nbsp;a&nbsp;coroutine&nbsp;<a href="builtins.html#object">object</a>.<br>
&nbsp;<br>
Return&nbsp;a&nbsp;task&nbsp;<a href="builtins.html#object">object</a>.</tt></dd></dl>

<dl><dt><a name="ProactorEventLoop-default_exception_handler"><strong>default_exception_handler</strong></a>(self, context)</dt><dd><tt>Default&nbsp;exception&nbsp;handler.<br>
&nbsp;<br>
This&nbsp;is&nbsp;called&nbsp;when&nbsp;an&nbsp;exception&nbsp;occurs&nbsp;and&nbsp;no&nbsp;exception<br>
handler&nbsp;is&nbsp;set,&nbsp;and&nbsp;can&nbsp;be&nbsp;called&nbsp;by&nbsp;a&nbsp;custom&nbsp;exception<br>
handler&nbsp;that&nbsp;wants&nbsp;to&nbsp;defer&nbsp;to&nbsp;the&nbsp;default&nbsp;behavior.<br>
&nbsp;<br>
This&nbsp;default&nbsp;handler&nbsp;logs&nbsp;the&nbsp;error&nbsp;message&nbsp;and&nbsp;other<br>
context-dependent&nbsp;information.&nbsp;&nbsp;In&nbsp;debug&nbsp;mode,&nbsp;a&nbsp;truncated<br>
stack&nbsp;trace&nbsp;is&nbsp;also&nbsp;appended&nbsp;showing&nbsp;where&nbsp;the&nbsp;given&nbsp;<a href="builtins.html#object">object</a><br>
(e.g.&nbsp;a&nbsp;handle&nbsp;or&nbsp;future&nbsp;or&nbsp;task)&nbsp;was&nbsp;created,&nbsp;if&nbsp;any.<br>
&nbsp;<br>
The&nbsp;context&nbsp;parameter&nbsp;has&nbsp;the&nbsp;same&nbsp;meaning&nbsp;as&nbsp;in<br>
`<a href="#ProactorEventLoop-call_exception_handler">call_exception_handler</a>()`.</tt></dd></dl>

<dl><dt><a name="ProactorEventLoop-get_debug"><strong>get_debug</strong></a>(self)</dt></dl>

<dl><dt><a name="ProactorEventLoop-get_exception_handler"><strong>get_exception_handler</strong></a>(self)</dt><dd><tt>Return&nbsp;an&nbsp;exception&nbsp;handler,&nbsp;or&nbsp;None&nbsp;if&nbsp;the&nbsp;default&nbsp;one&nbsp;is&nbsp;in&nbsp;use.</tt></dd></dl>

<dl><dt><a name="ProactorEventLoop-get_task_factory"><strong>get_task_factory</strong></a>(self)</dt><dd><tt>Return&nbsp;a&nbsp;task&nbsp;factory,&nbsp;or&nbsp;None&nbsp;if&nbsp;the&nbsp;default&nbsp;one&nbsp;is&nbsp;in&nbsp;use.</tt></dd></dl>

<dl><dt>async <a name="ProactorEventLoop-getaddrinfo"><strong>getaddrinfo</strong></a>(self, host, port, *, family=0, type=0, proto=0, flags=0)</dt></dl>

<dl><dt>async <a name="ProactorEventLoop-getnameinfo"><strong>getnameinfo</strong></a>(self, sockaddr, flags=0)</dt></dl>

<dl><dt><a name="ProactorEventLoop-is_closed"><strong>is_closed</strong></a>(self)</dt><dd><tt>Returns&nbsp;True&nbsp;if&nbsp;the&nbsp;event&nbsp;loop&nbsp;was&nbsp;closed.</tt></dd></dl>

<dl><dt><a name="ProactorEventLoop-is_running"><strong>is_running</strong></a>(self)</dt><dd><tt>Returns&nbsp;True&nbsp;if&nbsp;the&nbsp;event&nbsp;loop&nbsp;is&nbsp;running.</tt></dd></dl>

<dl><dt><a name="ProactorEventLoop-run_in_executor"><strong>run_in_executor</strong></a>(self, executor, func, *args)</dt></dl>

<dl><dt><a name="ProactorEventLoop-run_until_complete"><strong>run_until_complete</strong></a>(self, future)</dt><dd><tt>Run&nbsp;until&nbsp;the&nbsp;<a href="#Future">Future</a>&nbsp;is&nbsp;done.<br>
&nbsp;<br>
If&nbsp;the&nbsp;argument&nbsp;is&nbsp;a&nbsp;coroutine,&nbsp;it&nbsp;is&nbsp;wrapped&nbsp;in&nbsp;a&nbsp;<a href="#Task">Task</a>.<br>
&nbsp;<br>
WARNING:&nbsp;It&nbsp;would&nbsp;be&nbsp;disastrous&nbsp;to&nbsp;call&nbsp;<a href="#ProactorEventLoop-run_until_complete">run_until_complete</a>()<br>
with&nbsp;the&nbsp;same&nbsp;coroutine&nbsp;twice&nbsp;--&nbsp;it&nbsp;would&nbsp;wrap&nbsp;it&nbsp;in&nbsp;two<br>
different&nbsp;Tasks&nbsp;and&nbsp;that&nbsp;can't&nbsp;be&nbsp;good.<br>
&nbsp;<br>
Return&nbsp;the&nbsp;<a href="#Future">Future</a>'s&nbsp;result,&nbsp;or&nbsp;raise&nbsp;its&nbsp;exception.</tt></dd></dl>

<dl><dt>async <a name="ProactorEventLoop-sendfile"><strong>sendfile</strong></a>(self, transport, file, offset=0, count=None, *, fallback=True)</dt><dd><tt>Send&nbsp;a&nbsp;file&nbsp;to&nbsp;transport.<br>
&nbsp;<br>
Return&nbsp;the&nbsp;total&nbsp;number&nbsp;of&nbsp;bytes&nbsp;which&nbsp;were&nbsp;sent.<br>
&nbsp;<br>
The&nbsp;method&nbsp;uses&nbsp;high-performance&nbsp;os.sendfile&nbsp;if&nbsp;available.<br>
&nbsp;<br>
file&nbsp;must&nbsp;be&nbsp;a&nbsp;regular&nbsp;file&nbsp;<a href="builtins.html#object">object</a>&nbsp;opened&nbsp;in&nbsp;binary&nbsp;mode.<br>
&nbsp;<br>
offset&nbsp;tells&nbsp;from&nbsp;where&nbsp;to&nbsp;start&nbsp;reading&nbsp;the&nbsp;file.&nbsp;If&nbsp;specified,<br>
count&nbsp;is&nbsp;the&nbsp;total&nbsp;number&nbsp;of&nbsp;bytes&nbsp;to&nbsp;transmit&nbsp;as&nbsp;opposed&nbsp;to<br>
sending&nbsp;the&nbsp;file&nbsp;until&nbsp;EOF&nbsp;is&nbsp;reached.&nbsp;File&nbsp;position&nbsp;is&nbsp;updated&nbsp;on<br>
return&nbsp;or&nbsp;also&nbsp;in&nbsp;case&nbsp;of&nbsp;error&nbsp;in&nbsp;which&nbsp;case&nbsp;file.tell()<br>
can&nbsp;be&nbsp;used&nbsp;to&nbsp;figure&nbsp;out&nbsp;the&nbsp;number&nbsp;of&nbsp;bytes<br>
which&nbsp;were&nbsp;sent.<br>
&nbsp;<br>
fallback&nbsp;set&nbsp;to&nbsp;True&nbsp;makes&nbsp;asyncio&nbsp;to&nbsp;manually&nbsp;read&nbsp;and&nbsp;send<br>
the&nbsp;file&nbsp;when&nbsp;the&nbsp;platform&nbsp;does&nbsp;not&nbsp;support&nbsp;the&nbsp;sendfile&nbsp;syscall<br>
(e.g.&nbsp;Windows&nbsp;or&nbsp;SSL&nbsp;socket&nbsp;on&nbsp;Unix).<br>
&nbsp;<br>
Raise&nbsp;<a href="#SendfileNotAvailableError">SendfileNotAvailableError</a>&nbsp;if&nbsp;the&nbsp;system&nbsp;does&nbsp;not&nbsp;support<br>
sendfile&nbsp;syscall&nbsp;and&nbsp;fallback&nbsp;is&nbsp;False.</tt></dd></dl>

<dl><dt><a name="ProactorEventLoop-set_debug"><strong>set_debug</strong></a>(self, enabled)</dt></dl>

<dl><dt><a name="ProactorEventLoop-set_default_executor"><strong>set_default_executor</strong></a>(self, executor)</dt></dl>

<dl><dt><a name="ProactorEventLoop-set_exception_handler"><strong>set_exception_handler</strong></a>(self, handler)</dt><dd><tt>Set&nbsp;handler&nbsp;as&nbsp;the&nbsp;new&nbsp;event&nbsp;loop&nbsp;exception&nbsp;handler.<br>
&nbsp;<br>
If&nbsp;handler&nbsp;is&nbsp;None,&nbsp;the&nbsp;default&nbsp;exception&nbsp;handler&nbsp;will<br>
be&nbsp;set.<br>
&nbsp;<br>
If&nbsp;handler&nbsp;is&nbsp;a&nbsp;callable&nbsp;<a href="builtins.html#object">object</a>,&nbsp;it&nbsp;should&nbsp;have&nbsp;a<br>
signature&nbsp;matching&nbsp;'(loop,&nbsp;context)',&nbsp;where&nbsp;'loop'<br>
will&nbsp;be&nbsp;a&nbsp;reference&nbsp;to&nbsp;the&nbsp;active&nbsp;event&nbsp;loop,&nbsp;'context'<br>
will&nbsp;be&nbsp;a&nbsp;dict&nbsp;<a href="builtins.html#object">object</a>&nbsp;(see&nbsp;`<a href="#ProactorEventLoop-call_exception_handler">call_exception_handler</a>()`<br>
documentation&nbsp;for&nbsp;details&nbsp;about&nbsp;context).</tt></dd></dl>

<dl><dt><a name="ProactorEventLoop-set_task_factory"><strong>set_task_factory</strong></a>(self, factory)</dt><dd><tt>Set&nbsp;a&nbsp;task&nbsp;factory&nbsp;that&nbsp;will&nbsp;be&nbsp;used&nbsp;by&nbsp;loop.<a href="#ProactorEventLoop-create_task">create_task</a>().<br>
&nbsp;<br>
If&nbsp;factory&nbsp;is&nbsp;None&nbsp;the&nbsp;default&nbsp;task&nbsp;factory&nbsp;will&nbsp;be&nbsp;set.<br>
&nbsp;<br>
If&nbsp;factory&nbsp;is&nbsp;a&nbsp;callable,&nbsp;it&nbsp;should&nbsp;have&nbsp;a&nbsp;signature&nbsp;matching<br>
'(loop,&nbsp;coro)',&nbsp;where&nbsp;'loop'&nbsp;will&nbsp;be&nbsp;a&nbsp;reference&nbsp;to&nbsp;the&nbsp;active<br>
event&nbsp;loop,&nbsp;'coro'&nbsp;will&nbsp;be&nbsp;a&nbsp;coroutine&nbsp;<a href="builtins.html#object">object</a>.&nbsp;&nbsp;The&nbsp;callable<br>
must&nbsp;return&nbsp;a&nbsp;<a href="#Future">Future</a>.</tt></dd></dl>

<dl><dt>async <a name="ProactorEventLoop-shutdown_asyncgens"><strong>shutdown_asyncgens</strong></a>(self)</dt><dd><tt>Shutdown&nbsp;all&nbsp;active&nbsp;asynchronous&nbsp;generators.</tt></dd></dl>

<dl><dt>async <a name="ProactorEventLoop-sock_sendfile"><strong>sock_sendfile</strong></a>(self, sock, file, offset=0, count=None, *, fallback=True)</dt></dl>

<dl><dt>async <a name="ProactorEventLoop-start_tls"><strong>start_tls</strong></a>(self, transport, protocol, sslcontext, *, server_side=False, server_hostname=None, ssl_handshake_timeout=None)</dt><dd><tt>Upgrade&nbsp;transport&nbsp;to&nbsp;TLS.<br>
&nbsp;<br>
Return&nbsp;a&nbsp;new&nbsp;transport&nbsp;that&nbsp;*protocol*&nbsp;should&nbsp;start&nbsp;using<br>
immediately.</tt></dd></dl>

<dl><dt><a name="ProactorEventLoop-stop"><strong>stop</strong></a>(self)</dt><dd><tt>Stop&nbsp;running&nbsp;the&nbsp;event&nbsp;loop.<br>
&nbsp;<br>
Every&nbsp;callback&nbsp;already&nbsp;scheduled&nbsp;will&nbsp;still&nbsp;run.&nbsp;&nbsp;This&nbsp;simply&nbsp;informs<br>
run_forever&nbsp;to&nbsp;stop&nbsp;looping&nbsp;after&nbsp;a&nbsp;complete&nbsp;iteration.</tt></dd></dl>

<dl><dt>async <a name="ProactorEventLoop-subprocess_exec"><strong>subprocess_exec</strong></a>(self, protocol_factory, program, *args, stdin=-1, stdout=-1, stderr=-1, universal_newlines=False, shell=False, bufsize=0, encoding=None, errors=None, text=None, **kwargs)</dt></dl>

<dl><dt>async <a name="ProactorEventLoop-subprocess_shell"><strong>subprocess_shell</strong></a>(self, protocol_factory, cmd, *, stdin=-1, stdout=-1, stderr=-1, universal_newlines=False, shell=True, bufsize=0, encoding=None, errors=None, text=None, **kwargs)</dt></dl>

<dl><dt><a name="ProactorEventLoop-time"><strong>time</strong></a>(self)</dt><dd><tt>Return&nbsp;the&nbsp;time&nbsp;according&nbsp;to&nbsp;the&nbsp;event&nbsp;loop's&nbsp;clock.<br>
&nbsp;<br>
This&nbsp;is&nbsp;a&nbsp;float&nbsp;expressed&nbsp;in&nbsp;seconds&nbsp;since&nbsp;an&nbsp;epoch,&nbsp;but&nbsp;the<br>
epoch,&nbsp;precision,&nbsp;accuracy&nbsp;and&nbsp;drift&nbsp;are&nbsp;unspecified&nbsp;and&nbsp;may<br>
differ&nbsp;per&nbsp;event&nbsp;loop.</tt></dd></dl>

<hr>
Methods inherited from <a href="asyncio.events.html#AbstractEventLoop">asyncio.events.AbstractEventLoop</a>:<br>
<dl><dt><a name="ProactorEventLoop-add_reader"><strong>add_reader</strong></a>(self, fd, callback, *args)</dt></dl>

<dl><dt><a name="ProactorEventLoop-add_signal_handler"><strong>add_signal_handler</strong></a>(self, sig, callback, *args)</dt></dl>

<dl><dt><a name="ProactorEventLoop-add_writer"><strong>add_writer</strong></a>(self, fd, callback, *args)</dt></dl>

<dl><dt>async <a name="ProactorEventLoop-create_unix_connection"><strong>create_unix_connection</strong></a>(self, protocol_factory, path=None, *, ssl=None, sock=None, server_hostname=None, ssl_handshake_timeout=None)</dt></dl>

<dl><dt>async <a name="ProactorEventLoop-create_unix_server"><strong>create_unix_server</strong></a>(self, protocol_factory, path=None, *, sock=None, backlog=100, ssl=None, ssl_handshake_timeout=None, start_serving=True)</dt><dd><tt>A&nbsp;coroutine&nbsp;which&nbsp;creates&nbsp;a&nbsp;UNIX&nbsp;Domain&nbsp;Socket&nbsp;server.<br>
&nbsp;<br>
The&nbsp;return&nbsp;value&nbsp;is&nbsp;a&nbsp;Server&nbsp;<a href="builtins.html#object">object</a>,&nbsp;which&nbsp;can&nbsp;be&nbsp;used&nbsp;to&nbsp;stop<br>
the&nbsp;service.<br>
&nbsp;<br>
path&nbsp;is&nbsp;a&nbsp;str,&nbsp;representing&nbsp;a&nbsp;file&nbsp;systsem&nbsp;path&nbsp;to&nbsp;bind&nbsp;the<br>
server&nbsp;socket&nbsp;to.<br>
&nbsp;<br>
sock&nbsp;can&nbsp;optionally&nbsp;be&nbsp;specified&nbsp;in&nbsp;order&nbsp;to&nbsp;use&nbsp;a&nbsp;preexisting<br>
socket&nbsp;<a href="builtins.html#object">object</a>.<br>
&nbsp;<br>
backlog&nbsp;is&nbsp;the&nbsp;maximum&nbsp;number&nbsp;of&nbsp;queued&nbsp;connections&nbsp;passed&nbsp;to<br>
listen()&nbsp;(defaults&nbsp;to&nbsp;100).<br>
&nbsp;<br>
ssl&nbsp;can&nbsp;be&nbsp;set&nbsp;to&nbsp;an&nbsp;SSLContext&nbsp;to&nbsp;enable&nbsp;SSL&nbsp;over&nbsp;the<br>
accepted&nbsp;connections.<br>
&nbsp;<br>
ssl_handshake_timeout&nbsp;is&nbsp;the&nbsp;time&nbsp;in&nbsp;seconds&nbsp;that&nbsp;an&nbsp;SSL&nbsp;server<br>
will&nbsp;wait&nbsp;for&nbsp;the&nbsp;SSL&nbsp;handshake&nbsp;to&nbsp;complete&nbsp;(defaults&nbsp;to&nbsp;60s).<br>
&nbsp;<br>
start_serving&nbsp;set&nbsp;to&nbsp;True&nbsp;(default)&nbsp;causes&nbsp;the&nbsp;created&nbsp;server<br>
to&nbsp;start&nbsp;accepting&nbsp;connections&nbsp;immediately.&nbsp;&nbsp;When&nbsp;set&nbsp;to&nbsp;False,<br>
the&nbsp;user&nbsp;should&nbsp;await&nbsp;Server.start_serving()&nbsp;or&nbsp;Server.serve_forever()<br>
to&nbsp;make&nbsp;the&nbsp;server&nbsp;to&nbsp;start&nbsp;accepting&nbsp;connections.</tt></dd></dl>

<dl><dt><a name="ProactorEventLoop-remove_reader"><strong>remove_reader</strong></a>(self, fd)</dt></dl>

<dl><dt><a name="ProactorEventLoop-remove_signal_handler"><strong>remove_signal_handler</strong></a>(self, sig)</dt></dl>

<dl><dt><a name="ProactorEventLoop-remove_writer"><strong>remove_writer</strong></a>(self, fd)</dt></dl>

<hr>
Data descriptors inherited from <a href="asyncio.events.html#AbstractEventLoop">asyncio.events.AbstractEventLoop</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="Protocol">class <strong>Protocol</strong></a>(<a href="asyncio.protocols.html#BaseProtocol">BaseProtocol</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt>Interface&nbsp;for&nbsp;stream&nbsp;protocol.<br>
&nbsp;<br>
The&nbsp;user&nbsp;should&nbsp;implement&nbsp;this&nbsp;interface.&nbsp;&nbsp;They&nbsp;can&nbsp;inherit&nbsp;from<br>
this&nbsp;class&nbsp;but&nbsp;don't&nbsp;need&nbsp;to.&nbsp;&nbsp;The&nbsp;implementations&nbsp;here&nbsp;do<br>
nothing&nbsp;(they&nbsp;don't&nbsp;raise&nbsp;exceptions).<br>
&nbsp;<br>
When&nbsp;the&nbsp;user&nbsp;wants&nbsp;to&nbsp;requests&nbsp;a&nbsp;transport,&nbsp;they&nbsp;pass&nbsp;a&nbsp;protocol<br>
factory&nbsp;to&nbsp;a&nbsp;utility&nbsp;function&nbsp;(e.g.,&nbsp;EventLoop.create_connection()).<br>
&nbsp;<br>
When&nbsp;the&nbsp;connection&nbsp;is&nbsp;made&nbsp;successfully,&nbsp;<a href="#Protocol-connection_made">connection_made</a>()&nbsp;is<br>
called&nbsp;with&nbsp;a&nbsp;suitable&nbsp;transport&nbsp;<a href="builtins.html#object">object</a>.&nbsp;&nbsp;Then&nbsp;<a href="#Protocol-data_received">data_received</a>()<br>
will&nbsp;be&nbsp;called&nbsp;0&nbsp;or&nbsp;more&nbsp;times&nbsp;with&nbsp;data&nbsp;(bytes)&nbsp;received&nbsp;from&nbsp;the<br>
transport;&nbsp;finally,&nbsp;<a href="#Protocol-connection_lost">connection_lost</a>()&nbsp;will&nbsp;be&nbsp;called&nbsp;exactly&nbsp;once<br>
with&nbsp;either&nbsp;an&nbsp;exception&nbsp;<a href="builtins.html#object">object</a>&nbsp;or&nbsp;None&nbsp;as&nbsp;an&nbsp;argument.<br>
&nbsp;<br>
State&nbsp;machine&nbsp;of&nbsp;calls:<br>
&nbsp;<br>
&nbsp;&nbsp;start&nbsp;-&gt;&nbsp;CM&nbsp;[-&gt;&nbsp;DR*]&nbsp;[-&gt;&nbsp;ER?]&nbsp;-&gt;&nbsp;CL&nbsp;-&gt;&nbsp;end<br>
&nbsp;<br>
*&nbsp;CM:&nbsp;<a href="#Protocol-connection_made">connection_made</a>()<br>
*&nbsp;DR:&nbsp;<a href="#Protocol-data_received">data_received</a>()<br>
*&nbsp;ER:&nbsp;<a href="#Protocol-eof_received">eof_received</a>()<br>
*&nbsp;CL:&nbsp;<a href="#Protocol-connection_lost">connection_lost</a>()<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="asyncio.protocols.html#Protocol">Protocol</a></dd>
<dd><a href="asyncio.protocols.html#BaseProtocol">BaseProtocol</a></dd>
<dd><a href="builtins.html#object">builtins.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="Protocol-data_received"><strong>data_received</strong></a>(self, data)</dt><dd><tt>Called&nbsp;when&nbsp;some&nbsp;data&nbsp;is&nbsp;received.<br>
&nbsp;<br>
The&nbsp;argument&nbsp;is&nbsp;a&nbsp;bytes&nbsp;<a href="builtins.html#object">object</a>.</tt></dd></dl>

<dl><dt><a name="Protocol-eof_received"><strong>eof_received</strong></a>(self)</dt><dd><tt>Called&nbsp;when&nbsp;the&nbsp;other&nbsp;end&nbsp;calls&nbsp;write_eof()&nbsp;or&nbsp;equivalent.<br>
&nbsp;<br>
If&nbsp;this&nbsp;returns&nbsp;a&nbsp;false&nbsp;value&nbsp;(including&nbsp;None),&nbsp;the&nbsp;transport<br>
will&nbsp;close&nbsp;itself.&nbsp;&nbsp;If&nbsp;it&nbsp;returns&nbsp;a&nbsp;true&nbsp;value,&nbsp;closing&nbsp;the<br>
transport&nbsp;is&nbsp;up&nbsp;to&nbsp;the&nbsp;protocol.</tt></dd></dl>

<hr>
Methods inherited from <a href="asyncio.protocols.html#BaseProtocol">BaseProtocol</a>:<br>
<dl><dt><a name="Protocol-connection_lost"><strong>connection_lost</strong></a>(self, exc)</dt><dd><tt>Called&nbsp;when&nbsp;the&nbsp;connection&nbsp;is&nbsp;lost&nbsp;or&nbsp;closed.<br>
&nbsp;<br>
The&nbsp;argument&nbsp;is&nbsp;an&nbsp;exception&nbsp;<a href="builtins.html#object">object</a>&nbsp;or&nbsp;None&nbsp;(the&nbsp;latter<br>
meaning&nbsp;a&nbsp;regular&nbsp;EOF&nbsp;is&nbsp;received&nbsp;or&nbsp;the&nbsp;connection&nbsp;was<br>
aborted&nbsp;or&nbsp;closed).</tt></dd></dl>

<dl><dt><a name="Protocol-connection_made"><strong>connection_made</strong></a>(self, transport)</dt><dd><tt>Called&nbsp;when&nbsp;a&nbsp;connection&nbsp;is&nbsp;made.<br>
&nbsp;<br>
The&nbsp;argument&nbsp;is&nbsp;the&nbsp;transport&nbsp;representing&nbsp;the&nbsp;pipe&nbsp;connection.<br>
To&nbsp;receive&nbsp;data,&nbsp;wait&nbsp;for&nbsp;<a href="#Protocol-data_received">data_received</a>()&nbsp;calls.<br>
When&nbsp;the&nbsp;connection&nbsp;is&nbsp;closed,&nbsp;<a href="#Protocol-connection_lost">connection_lost</a>()&nbsp;is&nbsp;called.</tt></dd></dl>

<dl><dt><a name="Protocol-pause_writing"><strong>pause_writing</strong></a>(self)</dt><dd><tt>Called&nbsp;when&nbsp;the&nbsp;transport's&nbsp;buffer&nbsp;goes&nbsp;over&nbsp;the&nbsp;high-water&nbsp;mark.<br>
&nbsp;<br>
Pause&nbsp;and&nbsp;resume&nbsp;calls&nbsp;are&nbsp;paired&nbsp;--&nbsp;<a href="#Protocol-pause_writing">pause_writing</a>()&nbsp;is&nbsp;called<br>
once&nbsp;when&nbsp;the&nbsp;buffer&nbsp;goes&nbsp;strictly&nbsp;over&nbsp;the&nbsp;high-water&nbsp;mark<br>
(even&nbsp;if&nbsp;subsequent&nbsp;writes&nbsp;increases&nbsp;the&nbsp;buffer&nbsp;size&nbsp;even<br>
more),&nbsp;and&nbsp;eventually&nbsp;<a href="#Protocol-resume_writing">resume_writing</a>()&nbsp;is&nbsp;called&nbsp;once&nbsp;when&nbsp;the<br>
buffer&nbsp;size&nbsp;reaches&nbsp;the&nbsp;low-water&nbsp;mark.<br>
&nbsp;<br>
Note&nbsp;that&nbsp;if&nbsp;the&nbsp;buffer&nbsp;size&nbsp;equals&nbsp;the&nbsp;high-water&nbsp;mark,<br>
<a href="#Protocol-pause_writing">pause_writing</a>()&nbsp;is&nbsp;not&nbsp;called&nbsp;--&nbsp;it&nbsp;must&nbsp;go&nbsp;strictly&nbsp;over.<br>
Conversely,&nbsp;<a href="#Protocol-resume_writing">resume_writing</a>()&nbsp;is&nbsp;called&nbsp;when&nbsp;the&nbsp;buffer&nbsp;size&nbsp;is<br>
equal&nbsp;or&nbsp;lower&nbsp;than&nbsp;the&nbsp;low-water&nbsp;mark.&nbsp;&nbsp;These&nbsp;end&nbsp;conditions<br>
are&nbsp;important&nbsp;to&nbsp;ensure&nbsp;that&nbsp;things&nbsp;go&nbsp;as&nbsp;expected&nbsp;when&nbsp;either<br>
mark&nbsp;is&nbsp;zero.<br>
&nbsp;<br>
NOTE:&nbsp;This&nbsp;is&nbsp;the&nbsp;only&nbsp;<a href="#Protocol">Protocol</a>&nbsp;callback&nbsp;that&nbsp;is&nbsp;not&nbsp;called<br>
through&nbsp;EventLoop.call_soon()&nbsp;--&nbsp;if&nbsp;it&nbsp;were,&nbsp;it&nbsp;would&nbsp;have&nbsp;no<br>
effect&nbsp;when&nbsp;it's&nbsp;most&nbsp;needed&nbsp;(when&nbsp;the&nbsp;app&nbsp;keeps&nbsp;writing<br>
without&nbsp;yielding&nbsp;until&nbsp;<a href="#Protocol-pause_writing">pause_writing</a>()&nbsp;is&nbsp;called).</tt></dd></dl>

<dl><dt><a name="Protocol-resume_writing"><strong>resume_writing</strong></a>(self)</dt><dd><tt>Called&nbsp;when&nbsp;the&nbsp;transport's&nbsp;buffer&nbsp;drains&nbsp;below&nbsp;the&nbsp;low-water&nbsp;mark.<br>
&nbsp;<br>
See&nbsp;<a href="#Protocol-pause_writing">pause_writing</a>()&nbsp;for&nbsp;details.</tt></dd></dl>

</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="Queue">class <strong>Queue</strong></a>(<a href="builtins.html#object">builtins.object</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#Queue">Queue</a>(maxsize=0,&nbsp;*,&nbsp;loop=None)<br>
&nbsp;<br>
A&nbsp;queue,&nbsp;useful&nbsp;for&nbsp;coordinating&nbsp;producer&nbsp;and&nbsp;consumer&nbsp;coroutines.<br>
&nbsp;<br>
If&nbsp;maxsize&nbsp;is&nbsp;less&nbsp;than&nbsp;or&nbsp;equal&nbsp;to&nbsp;zero,&nbsp;the&nbsp;queue&nbsp;size&nbsp;is&nbsp;infinite.&nbsp;If&nbsp;it<br>
is&nbsp;an&nbsp;integer&nbsp;greater&nbsp;than&nbsp;0,&nbsp;then&nbsp;"await&nbsp;<a href="#Queue-put">put</a>()"&nbsp;will&nbsp;block&nbsp;when&nbsp;the<br>
queue&nbsp;reaches&nbsp;maxsize,&nbsp;until&nbsp;an&nbsp;item&nbsp;is&nbsp;removed&nbsp;by&nbsp;<a href="#Queue-get">get</a>().<br>
&nbsp;<br>
Unlike&nbsp;the&nbsp;standard&nbsp;library&nbsp;<a href="#Queue">Queue</a>,&nbsp;you&nbsp;can&nbsp;reliably&nbsp;know&nbsp;this&nbsp;<a href="#Queue">Queue</a>'s&nbsp;size<br>
with&nbsp;<a href="#Queue-qsize">qsize</a>(),&nbsp;since&nbsp;your&nbsp;single-threaded&nbsp;asyncio&nbsp;application&nbsp;won't&nbsp;be<br>
interrupted&nbsp;between&nbsp;calling&nbsp;<a href="#Queue-qsize">qsize</a>()&nbsp;and&nbsp;doing&nbsp;an&nbsp;operation&nbsp;on&nbsp;the&nbsp;<a href="#Queue">Queue</a>.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%">Methods defined here:<br>
<dl><dt><a name="Queue-__init__"><strong>__init__</strong></a>(self, maxsize=0, *, loop=None)</dt><dd><tt>Initialize&nbsp;self.&nbsp;&nbsp;See&nbsp;help(type(self))&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<dl><dt><a name="Queue-__repr__"><strong>__repr__</strong></a>(self)</dt><dd><tt>Return&nbsp;repr(self).</tt></dd></dl>

<dl><dt><a name="Queue-__str__"><strong>__str__</strong></a>(self)</dt><dd><tt>Return&nbsp;str(self).</tt></dd></dl>

<dl><dt><a name="Queue-empty"><strong>empty</strong></a>(self)</dt><dd><tt>Return&nbsp;True&nbsp;if&nbsp;the&nbsp;queue&nbsp;is&nbsp;empty,&nbsp;False&nbsp;otherwise.</tt></dd></dl>

<dl><dt><a name="Queue-full"><strong>full</strong></a>(self)</dt><dd><tt>Return&nbsp;True&nbsp;if&nbsp;there&nbsp;are&nbsp;maxsize&nbsp;items&nbsp;in&nbsp;the&nbsp;queue.<br>
&nbsp;<br>
Note:&nbsp;if&nbsp;the&nbsp;<a href="#Queue">Queue</a>&nbsp;was&nbsp;initialized&nbsp;with&nbsp;maxsize=0&nbsp;(the&nbsp;default),<br>
then&nbsp;<a href="#Queue-full">full</a>()&nbsp;is&nbsp;never&nbsp;True.</tt></dd></dl>

<dl><dt>async <a name="Queue-get"><strong>get</strong></a>(self)</dt><dd><tt>Remove&nbsp;and&nbsp;return&nbsp;an&nbsp;item&nbsp;from&nbsp;the&nbsp;queue.<br>
&nbsp;<br>
If&nbsp;queue&nbsp;is&nbsp;empty,&nbsp;wait&nbsp;until&nbsp;an&nbsp;item&nbsp;is&nbsp;available.</tt></dd></dl>

<dl><dt><a name="Queue-get_nowait"><strong>get_nowait</strong></a>(self)</dt><dd><tt>Remove&nbsp;and&nbsp;return&nbsp;an&nbsp;item&nbsp;from&nbsp;the&nbsp;queue.<br>
&nbsp;<br>
Return&nbsp;an&nbsp;item&nbsp;if&nbsp;one&nbsp;is&nbsp;immediately&nbsp;available,&nbsp;else&nbsp;raise&nbsp;<a href="#QueueEmpty">QueueEmpty</a>.</tt></dd></dl>

<dl><dt>async <a name="Queue-join"><strong>join</strong></a>(self)</dt><dd><tt>Block&nbsp;until&nbsp;all&nbsp;items&nbsp;in&nbsp;the&nbsp;queue&nbsp;have&nbsp;been&nbsp;gotten&nbsp;and&nbsp;processed.<br>
&nbsp;<br>
The&nbsp;count&nbsp;of&nbsp;unfinished&nbsp;tasks&nbsp;goes&nbsp;up&nbsp;whenever&nbsp;an&nbsp;item&nbsp;is&nbsp;added&nbsp;to&nbsp;the<br>
queue.&nbsp;The&nbsp;count&nbsp;goes&nbsp;down&nbsp;whenever&nbsp;a&nbsp;consumer&nbsp;calls&nbsp;<a href="#Queue-task_done">task_done</a>()&nbsp;to<br>
indicate&nbsp;that&nbsp;the&nbsp;item&nbsp;was&nbsp;retrieved&nbsp;and&nbsp;all&nbsp;work&nbsp;on&nbsp;it&nbsp;is&nbsp;complete.<br>
When&nbsp;the&nbsp;count&nbsp;of&nbsp;unfinished&nbsp;tasks&nbsp;drops&nbsp;to&nbsp;zero,&nbsp;<a href="#Queue-join">join</a>()&nbsp;unblocks.</tt></dd></dl>

<dl><dt>async <a name="Queue-put"><strong>put</strong></a>(self, item)</dt><dd><tt>Put&nbsp;an&nbsp;item&nbsp;into&nbsp;the&nbsp;queue.<br>
&nbsp;<br>
Put&nbsp;an&nbsp;item&nbsp;into&nbsp;the&nbsp;queue.&nbsp;If&nbsp;the&nbsp;queue&nbsp;is&nbsp;full,&nbsp;wait&nbsp;until&nbsp;a&nbsp;free<br>
slot&nbsp;is&nbsp;available&nbsp;before&nbsp;adding&nbsp;item.</tt></dd></dl>

<dl><dt><a name="Queue-put_nowait"><strong>put_nowait</strong></a>(self, item)</dt><dd><tt>Put&nbsp;an&nbsp;item&nbsp;into&nbsp;the&nbsp;queue&nbsp;without&nbsp;blocking.<br>
&nbsp;<br>
If&nbsp;no&nbsp;free&nbsp;slot&nbsp;is&nbsp;immediately&nbsp;available,&nbsp;raise&nbsp;<a href="#QueueFull">QueueFull</a>.</tt></dd></dl>

<dl><dt><a name="Queue-qsize"><strong>qsize</strong></a>(self)</dt><dd><tt>Number&nbsp;of&nbsp;items&nbsp;in&nbsp;the&nbsp;queue.</tt></dd></dl>

<dl><dt><a name="Queue-task_done"><strong>task_done</strong></a>(self)</dt><dd><tt>Indicate&nbsp;that&nbsp;a&nbsp;formerly&nbsp;enqueued&nbsp;task&nbsp;is&nbsp;complete.<br>
&nbsp;<br>
Used&nbsp;by&nbsp;queue&nbsp;consumers.&nbsp;For&nbsp;each&nbsp;<a href="#Queue-get">get</a>()&nbsp;used&nbsp;to&nbsp;fetch&nbsp;a&nbsp;task,<br>
a&nbsp;subsequent&nbsp;call&nbsp;to&nbsp;<a href="#Queue-task_done">task_done</a>()&nbsp;tells&nbsp;the&nbsp;queue&nbsp;that&nbsp;the&nbsp;processing<br>
on&nbsp;the&nbsp;task&nbsp;is&nbsp;complete.<br>
&nbsp;<br>
If&nbsp;a&nbsp;<a href="#Queue-join">join</a>()&nbsp;is&nbsp;currently&nbsp;blocking,&nbsp;it&nbsp;will&nbsp;resume&nbsp;when&nbsp;all&nbsp;items&nbsp;have<br>
been&nbsp;processed&nbsp;(meaning&nbsp;that&nbsp;a&nbsp;<a href="#Queue-task_done">task_done</a>()&nbsp;call&nbsp;was&nbsp;received&nbsp;for&nbsp;every<br>
item&nbsp;that&nbsp;had&nbsp;been&nbsp;<a href="#Queue-put">put</a>()&nbsp;into&nbsp;the&nbsp;queue).<br>
&nbsp;<br>
Raises&nbsp;ValueError&nbsp;if&nbsp;called&nbsp;more&nbsp;times&nbsp;than&nbsp;there&nbsp;were&nbsp;items&nbsp;placed&nbsp;in<br>
the&nbsp;queue.</tt></dd></dl>

<hr>
Readonly properties defined here:<br>
<dl><dt><strong>maxsize</strong></dt>
<dd><tt>Number&nbsp;of&nbsp;items&nbsp;allowed&nbsp;in&nbsp;the&nbsp;queue.</tt></dd>
</dl>
<hr>
Data descriptors defined here:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="QueueEmpty">class <strong>QueueEmpty</strong></a>(<a href="builtins.html#Exception">builtins.Exception</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt>Raised&nbsp;when&nbsp;<a href="#Queue">Queue</a>.get_nowait()&nbsp;is&nbsp;called&nbsp;on&nbsp;an&nbsp;empty&nbsp;<a href="#Queue">Queue</a>.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="asyncio.queues.html#QueueEmpty">QueueEmpty</a></dd>
<dd><a href="builtins.html#Exception">builtins.Exception</a></dd>
<dd><a href="builtins.html#BaseException">builtins.BaseException</a></dd>
<dd><a href="builtins.html#object">builtins.object</a></dd>
</dl>
<hr>
Data descriptors defined here:<br>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<hr>
Methods inherited from <a href="builtins.html#Exception">builtins.Exception</a>:<br>
<dl><dt><a name="QueueEmpty-__init__"><strong>__init__</strong></a>(self, /, *args, **kwargs)</dt><dd><tt>Initialize&nbsp;self.&nbsp;&nbsp;See&nbsp;help(type(self))&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<hr>
Static methods inherited from <a href="builtins.html#Exception">builtins.Exception</a>:<br>
<dl><dt><a name="QueueEmpty-__new__"><strong>__new__</strong></a>(*args, **kwargs)<font color="#909090"><font face="helvetica, arial"> from <a href="builtins.html#type">builtins.type</a></font></font></dt><dd><tt>Create&nbsp;and&nbsp;return&nbsp;a&nbsp;new&nbsp;<a href="builtins.html#object">object</a>.&nbsp;&nbsp;See&nbsp;help(type)&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<hr>
Methods inherited from <a href="builtins.html#BaseException">builtins.BaseException</a>:<br>
<dl><dt><a name="QueueEmpty-__delattr__"><strong>__delattr__</strong></a>(self, name, /)</dt><dd><tt>Implement&nbsp;delattr(self,&nbsp;name).</tt></dd></dl>

<dl><dt><a name="QueueEmpty-__getattribute__"><strong>__getattribute__</strong></a>(self, name, /)</dt><dd><tt>Return&nbsp;getattr(self,&nbsp;name).</tt></dd></dl>

<dl><dt><a name="QueueEmpty-__reduce__"><strong>__reduce__</strong></a>(...)</dt><dd><tt>Helper&nbsp;for&nbsp;pickle.</tt></dd></dl>

<dl><dt><a name="QueueEmpty-__repr__"><strong>__repr__</strong></a>(self, /)</dt><dd><tt>Return&nbsp;repr(self).</tt></dd></dl>

<dl><dt><a name="QueueEmpty-__setattr__"><strong>__setattr__</strong></a>(self, name, value, /)</dt><dd><tt>Implement&nbsp;setattr(self,&nbsp;name,&nbsp;value).</tt></dd></dl>

<dl><dt><a name="QueueEmpty-__setstate__"><strong>__setstate__</strong></a>(...)</dt></dl>

<dl><dt><a name="QueueEmpty-__str__"><strong>__str__</strong></a>(self, /)</dt><dd><tt>Return&nbsp;str(self).</tt></dd></dl>

<dl><dt><a name="QueueEmpty-with_traceback"><strong>with_traceback</strong></a>(...)</dt><dd><tt><a href="builtins.html#Exception">Exception</a>.<a href="#QueueEmpty-with_traceback">with_traceback</a>(tb)&nbsp;--<br>
set&nbsp;self.<strong>__traceback__</strong>&nbsp;to&nbsp;tb&nbsp;and&nbsp;return&nbsp;self.</tt></dd></dl>

<hr>
Data descriptors inherited from <a href="builtins.html#BaseException">builtins.BaseException</a>:<br>
<dl><dt><strong>__cause__</strong></dt>
<dd><tt>exception&nbsp;cause</tt></dd>
</dl>
<dl><dt><strong>__context__</strong></dt>
<dd><tt>exception&nbsp;context</tt></dd>
</dl>
<dl><dt><strong>__dict__</strong></dt>
</dl>
<dl><dt><strong>__suppress_context__</strong></dt>
</dl>
<dl><dt><strong>__traceback__</strong></dt>
</dl>
<dl><dt><strong>args</strong></dt>
</dl>
</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="QueueFull">class <strong>QueueFull</strong></a>(<a href="builtins.html#Exception">builtins.Exception</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt>Raised&nbsp;when&nbsp;the&nbsp;<a href="#Queue">Queue</a>.put_nowait()&nbsp;method&nbsp;is&nbsp;called&nbsp;on&nbsp;a&nbsp;full&nbsp;<a href="#Queue">Queue</a>.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="asyncio.queues.html#QueueFull">QueueFull</a></dd>
<dd><a href="builtins.html#Exception">builtins.Exception</a></dd>
<dd><a href="builtins.html#BaseException">builtins.BaseException</a></dd>
<dd><a href="builtins.html#object">builtins.object</a></dd>
</dl>
<hr>
Data descriptors defined here:<br>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<hr>
Methods inherited from <a href="builtins.html#Exception">builtins.Exception</a>:<br>
<dl><dt><a name="QueueFull-__init__"><strong>__init__</strong></a>(self, /, *args, **kwargs)</dt><dd><tt>Initialize&nbsp;self.&nbsp;&nbsp;See&nbsp;help(type(self))&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<hr>
Static methods inherited from <a href="builtins.html#Exception">builtins.Exception</a>:<br>
<dl><dt><a name="QueueFull-__new__"><strong>__new__</strong></a>(*args, **kwargs)<font color="#909090"><font face="helvetica, arial"> from <a href="builtins.html#type">builtins.type</a></font></font></dt><dd><tt>Create&nbsp;and&nbsp;return&nbsp;a&nbsp;new&nbsp;<a href="builtins.html#object">object</a>.&nbsp;&nbsp;See&nbsp;help(type)&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<hr>
Methods inherited from <a href="builtins.html#BaseException">builtins.BaseException</a>:<br>
<dl><dt><a name="QueueFull-__delattr__"><strong>__delattr__</strong></a>(self, name, /)</dt><dd><tt>Implement&nbsp;delattr(self,&nbsp;name).</tt></dd></dl>

<dl><dt><a name="QueueFull-__getattribute__"><strong>__getattribute__</strong></a>(self, name, /)</dt><dd><tt>Return&nbsp;getattr(self,&nbsp;name).</tt></dd></dl>

<dl><dt><a name="QueueFull-__reduce__"><strong>__reduce__</strong></a>(...)</dt><dd><tt>Helper&nbsp;for&nbsp;pickle.</tt></dd></dl>

<dl><dt><a name="QueueFull-__repr__"><strong>__repr__</strong></a>(self, /)</dt><dd><tt>Return&nbsp;repr(self).</tt></dd></dl>

<dl><dt><a name="QueueFull-__setattr__"><strong>__setattr__</strong></a>(self, name, value, /)</dt><dd><tt>Implement&nbsp;setattr(self,&nbsp;name,&nbsp;value).</tt></dd></dl>

<dl><dt><a name="QueueFull-__setstate__"><strong>__setstate__</strong></a>(...)</dt></dl>

<dl><dt><a name="QueueFull-__str__"><strong>__str__</strong></a>(self, /)</dt><dd><tt>Return&nbsp;str(self).</tt></dd></dl>

<dl><dt><a name="QueueFull-with_traceback"><strong>with_traceback</strong></a>(...)</dt><dd><tt><a href="builtins.html#Exception">Exception</a>.<a href="#QueueFull-with_traceback">with_traceback</a>(tb)&nbsp;--<br>
set&nbsp;self.<strong>__traceback__</strong>&nbsp;to&nbsp;tb&nbsp;and&nbsp;return&nbsp;self.</tt></dd></dl>

<hr>
Data descriptors inherited from <a href="builtins.html#BaseException">builtins.BaseException</a>:<br>
<dl><dt><strong>__cause__</strong></dt>
<dd><tt>exception&nbsp;cause</tt></dd>
</dl>
<dl><dt><strong>__context__</strong></dt>
<dd><tt>exception&nbsp;context</tt></dd>
</dl>
<dl><dt><strong>__dict__</strong></dt>
</dl>
<dl><dt><strong>__suppress_context__</strong></dt>
</dl>
<dl><dt><strong>__traceback__</strong></dt>
</dl>
<dl><dt><strong>args</strong></dt>
</dl>
</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="ReadTransport">class <strong>ReadTransport</strong></a>(<a href="asyncio.transports.html#BaseTransport">BaseTransport</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#ReadTransport">ReadTransport</a>(extra=None)<br>
&nbsp;<br>
Interface&nbsp;for&nbsp;read-only&nbsp;transports.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="asyncio.transports.html#ReadTransport">ReadTransport</a></dd>
<dd><a href="asyncio.transports.html#BaseTransport">BaseTransport</a></dd>
<dd><a href="builtins.html#object">builtins.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="ReadTransport-is_reading"><strong>is_reading</strong></a>(self)</dt><dd><tt>Return&nbsp;True&nbsp;if&nbsp;the&nbsp;transport&nbsp;is&nbsp;receiving.</tt></dd></dl>

<dl><dt><a name="ReadTransport-pause_reading"><strong>pause_reading</strong></a>(self)</dt><dd><tt>Pause&nbsp;the&nbsp;receiving&nbsp;end.<br>
&nbsp;<br>
No&nbsp;data&nbsp;will&nbsp;be&nbsp;passed&nbsp;to&nbsp;the&nbsp;protocol's&nbsp;data_received()<br>
method&nbsp;until&nbsp;<a href="#ReadTransport-resume_reading">resume_reading</a>()&nbsp;is&nbsp;called.</tt></dd></dl>

<dl><dt><a name="ReadTransport-resume_reading"><strong>resume_reading</strong></a>(self)</dt><dd><tt>Resume&nbsp;the&nbsp;receiving&nbsp;end.<br>
&nbsp;<br>
Data&nbsp;received&nbsp;will&nbsp;once&nbsp;again&nbsp;be&nbsp;passed&nbsp;to&nbsp;the&nbsp;protocol's<br>
data_received()&nbsp;method.</tt></dd></dl>

<hr>
Methods inherited from <a href="asyncio.transports.html#BaseTransport">BaseTransport</a>:<br>
<dl><dt><a name="ReadTransport-__init__"><strong>__init__</strong></a>(self, extra=None)</dt><dd><tt>Initialize&nbsp;self.&nbsp;&nbsp;See&nbsp;help(type(self))&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<dl><dt><a name="ReadTransport-close"><strong>close</strong></a>(self)</dt><dd><tt>Close&nbsp;the&nbsp;transport.<br>
&nbsp;<br>
Buffered&nbsp;data&nbsp;will&nbsp;be&nbsp;flushed&nbsp;asynchronously.&nbsp;&nbsp;No&nbsp;more&nbsp;data<br>
will&nbsp;be&nbsp;received.&nbsp;&nbsp;After&nbsp;all&nbsp;buffered&nbsp;data&nbsp;is&nbsp;flushed,&nbsp;the<br>
protocol's&nbsp;connection_lost()&nbsp;method&nbsp;will&nbsp;(eventually)&nbsp;be<br>
called&nbsp;with&nbsp;None&nbsp;as&nbsp;its&nbsp;argument.</tt></dd></dl>

<dl><dt><a name="ReadTransport-get_extra_info"><strong>get_extra_info</strong></a>(self, name, default=None)</dt><dd><tt>Get&nbsp;optional&nbsp;transport&nbsp;information.</tt></dd></dl>

<dl><dt><a name="ReadTransport-get_protocol"><strong>get_protocol</strong></a>(self)</dt><dd><tt>Return&nbsp;the&nbsp;current&nbsp;protocol.</tt></dd></dl>

<dl><dt><a name="ReadTransport-is_closing"><strong>is_closing</strong></a>(self)</dt><dd><tt>Return&nbsp;True&nbsp;if&nbsp;the&nbsp;transport&nbsp;is&nbsp;closing&nbsp;or&nbsp;closed.</tt></dd></dl>

<dl><dt><a name="ReadTransport-set_protocol"><strong>set_protocol</strong></a>(self, protocol)</dt><dd><tt>Set&nbsp;a&nbsp;new&nbsp;protocol.</tt></dd></dl>

</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><strong>SelectorEventLoop</strong> = <a name="SelectorEventLoop">class _WindowsSelectorEventLoop</a>(<a href="asyncio.selector_events.html#BaseSelectorEventLoop">asyncio.selector_events.BaseSelectorEventLoop</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#SelectorEventLoop">SelectorEventLoop</a>(selector=None)<br>
&nbsp;<br>
Windows&nbsp;version&nbsp;of&nbsp;selector&nbsp;event&nbsp;loop.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="asyncio.windows_events.html#_WindowsSelectorEventLoop">_WindowsSelectorEventLoop</a></dd>
<dd><a href="asyncio.selector_events.html#BaseSelectorEventLoop">asyncio.selector_events.BaseSelectorEventLoop</a></dd>
<dd><a href="asyncio.base_events.html#BaseEventLoop">asyncio.base_events.BaseEventLoop</a></dd>
<dd><a href="asyncio.events.html#AbstractEventLoop">asyncio.events.AbstractEventLoop</a></dd>
<dd><a href="builtins.html#object">builtins.object</a></dd>
</dl>
<hr>
Methods inherited from <a href="asyncio.selector_events.html#BaseSelectorEventLoop">asyncio.selector_events.BaseSelectorEventLoop</a>:<br>
<dl><dt><a name="_WindowsSelectorEventLoop-__init__"><strong>__init__</strong></a>(self, selector=None)</dt><dd><tt>Initialize&nbsp;self.&nbsp;&nbsp;See&nbsp;help(type(self))&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<dl><dt><a name="_WindowsSelectorEventLoop-add_reader"><strong>add_reader</strong></a>(self, fd, callback, *args)</dt><dd><tt>Add&nbsp;a&nbsp;reader&nbsp;callback.</tt></dd></dl>

<dl><dt><a name="_WindowsSelectorEventLoop-add_writer"><strong>add_writer</strong></a>(self, fd, callback, *args)</dt><dd><tt>Add&nbsp;a&nbsp;writer&nbsp;callback..</tt></dd></dl>

<dl><dt><a name="_WindowsSelectorEventLoop-close"><strong>close</strong></a>(self)</dt><dd><tt>Close&nbsp;the&nbsp;event&nbsp;loop.<br>
&nbsp;<br>
This&nbsp;clears&nbsp;the&nbsp;queues&nbsp;and&nbsp;shuts&nbsp;down&nbsp;the&nbsp;executor,<br>
but&nbsp;does&nbsp;not&nbsp;wait&nbsp;for&nbsp;the&nbsp;executor&nbsp;to&nbsp;finish.<br>
&nbsp;<br>
The&nbsp;event&nbsp;loop&nbsp;must&nbsp;not&nbsp;be&nbsp;running.</tt></dd></dl>

<dl><dt><a name="_WindowsSelectorEventLoop-remove_reader"><strong>remove_reader</strong></a>(self, fd)</dt><dd><tt>Remove&nbsp;a&nbsp;reader&nbsp;callback.</tt></dd></dl>

<dl><dt><a name="_WindowsSelectorEventLoop-remove_writer"><strong>remove_writer</strong></a>(self, fd)</dt><dd><tt>Remove&nbsp;a&nbsp;writer&nbsp;callback.</tt></dd></dl>

<dl><dt>async <a name="_WindowsSelectorEventLoop-sock_accept"><strong>sock_accept</strong></a>(self, sock)</dt><dd><tt>Accept&nbsp;a&nbsp;connection.<br>
&nbsp;<br>
The&nbsp;socket&nbsp;must&nbsp;be&nbsp;bound&nbsp;to&nbsp;an&nbsp;address&nbsp;and&nbsp;listening&nbsp;for&nbsp;connections.<br>
The&nbsp;return&nbsp;value&nbsp;is&nbsp;a&nbsp;pair&nbsp;(conn,&nbsp;address)&nbsp;where&nbsp;conn&nbsp;is&nbsp;a&nbsp;new&nbsp;socket<br>
<a href="builtins.html#object">object</a>&nbsp;usable&nbsp;to&nbsp;send&nbsp;and&nbsp;receive&nbsp;data&nbsp;on&nbsp;the&nbsp;connection,&nbsp;and&nbsp;address<br>
is&nbsp;the&nbsp;address&nbsp;bound&nbsp;to&nbsp;the&nbsp;socket&nbsp;on&nbsp;the&nbsp;other&nbsp;end&nbsp;of&nbsp;the&nbsp;connection.</tt></dd></dl>

<dl><dt>async <a name="_WindowsSelectorEventLoop-sock_connect"><strong>sock_connect</strong></a>(self, sock, address)</dt><dd><tt>Connect&nbsp;to&nbsp;a&nbsp;remote&nbsp;socket&nbsp;at&nbsp;address.<br>
&nbsp;<br>
This&nbsp;method&nbsp;is&nbsp;a&nbsp;coroutine.</tt></dd></dl>

<dl><dt>async <a name="_WindowsSelectorEventLoop-sock_recv"><strong>sock_recv</strong></a>(self, sock, n)</dt><dd><tt>Receive&nbsp;data&nbsp;from&nbsp;the&nbsp;socket.<br>
&nbsp;<br>
The&nbsp;return&nbsp;value&nbsp;is&nbsp;a&nbsp;bytes&nbsp;<a href="builtins.html#object">object</a>&nbsp;representing&nbsp;the&nbsp;data&nbsp;received.<br>
The&nbsp;maximum&nbsp;amount&nbsp;of&nbsp;data&nbsp;to&nbsp;be&nbsp;received&nbsp;at&nbsp;once&nbsp;is&nbsp;specified&nbsp;by<br>
nbytes.</tt></dd></dl>

<dl><dt>async <a name="_WindowsSelectorEventLoop-sock_recv_into"><strong>sock_recv_into</strong></a>(self, sock, buf)</dt><dd><tt>Receive&nbsp;data&nbsp;from&nbsp;the&nbsp;socket.<br>
&nbsp;<br>
The&nbsp;received&nbsp;data&nbsp;is&nbsp;written&nbsp;into&nbsp;*buf*&nbsp;(a&nbsp;writable&nbsp;buffer).<br>
The&nbsp;return&nbsp;value&nbsp;is&nbsp;the&nbsp;number&nbsp;of&nbsp;bytes&nbsp;written.</tt></dd></dl>

<dl><dt>async <a name="_WindowsSelectorEventLoop-sock_sendall"><strong>sock_sendall</strong></a>(self, sock, data)</dt><dd><tt>Send&nbsp;data&nbsp;to&nbsp;the&nbsp;socket.<br>
&nbsp;<br>
The&nbsp;socket&nbsp;must&nbsp;be&nbsp;connected&nbsp;to&nbsp;a&nbsp;remote&nbsp;socket.&nbsp;This&nbsp;method&nbsp;continues<br>
to&nbsp;send&nbsp;data&nbsp;from&nbsp;data&nbsp;until&nbsp;either&nbsp;all&nbsp;data&nbsp;has&nbsp;been&nbsp;sent&nbsp;or&nbsp;an<br>
error&nbsp;occurs.&nbsp;None&nbsp;is&nbsp;returned&nbsp;on&nbsp;success.&nbsp;On&nbsp;error,&nbsp;an&nbsp;exception&nbsp;is<br>
raised,&nbsp;and&nbsp;there&nbsp;is&nbsp;no&nbsp;way&nbsp;to&nbsp;determine&nbsp;how&nbsp;much&nbsp;data,&nbsp;if&nbsp;any,&nbsp;was<br>
successfully&nbsp;processed&nbsp;by&nbsp;the&nbsp;receiving&nbsp;end&nbsp;of&nbsp;the&nbsp;connection.</tt></dd></dl>

<hr>
Methods inherited from <a href="asyncio.base_events.html#BaseEventLoop">asyncio.base_events.BaseEventLoop</a>:<br>
<dl><dt><a name="_WindowsSelectorEventLoop-__del__"><strong>__del__</strong></a>(self, _warn=&lt;built-in function warn&gt;)</dt></dl>

<dl><dt><a name="_WindowsSelectorEventLoop-__repr__"><strong>__repr__</strong></a>(self)</dt><dd><tt>Return&nbsp;repr(self).</tt></dd></dl>

<dl><dt><a name="_WindowsSelectorEventLoop-call_at"><strong>call_at</strong></a>(self, when, callback, *args, context=None)</dt><dd><tt>Like&nbsp;<a href="#SelectorEventLoop-call_later">call_later</a>(),&nbsp;but&nbsp;uses&nbsp;an&nbsp;absolute&nbsp;time.<br>
&nbsp;<br>
Absolute&nbsp;time&nbsp;corresponds&nbsp;to&nbsp;the&nbsp;event&nbsp;loop's&nbsp;<a href="#SelectorEventLoop-time">time</a>()&nbsp;method.</tt></dd></dl>

<dl><dt><a name="_WindowsSelectorEventLoop-call_exception_handler"><strong>call_exception_handler</strong></a>(self, context)</dt><dd><tt>Call&nbsp;the&nbsp;current&nbsp;event&nbsp;loop's&nbsp;exception&nbsp;handler.<br>
&nbsp;<br>
The&nbsp;context&nbsp;argument&nbsp;is&nbsp;a&nbsp;dict&nbsp;containing&nbsp;the&nbsp;following&nbsp;keys:<br>
&nbsp;<br>
-&nbsp;'message':&nbsp;Error&nbsp;message;<br>
-&nbsp;'exception'&nbsp;(optional):&nbsp;<a href="builtins.html#Exception">Exception</a>&nbsp;<a href="builtins.html#object">object</a>;<br>
-&nbsp;'future'&nbsp;(optional):&nbsp;<a href="#Future">Future</a>&nbsp;instance;<br>
-&nbsp;'task'&nbsp;(optional):&nbsp;<a href="#Task">Task</a>&nbsp;instance;<br>
-&nbsp;'handle'&nbsp;(optional):&nbsp;<a href="#Handle">Handle</a>&nbsp;instance;<br>
-&nbsp;'protocol'&nbsp;(optional):&nbsp;<a href="#Protocol">Protocol</a>&nbsp;instance;<br>
-&nbsp;'transport'&nbsp;(optional):&nbsp;<a href="#Transport">Transport</a>&nbsp;instance;<br>
-&nbsp;'socket'&nbsp;(optional):&nbsp;Socket&nbsp;instance;<br>
-&nbsp;'asyncgen'&nbsp;(optional):&nbsp;Asynchronous&nbsp;generator&nbsp;that&nbsp;caused<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;exception.<br>
&nbsp;<br>
New&nbsp;keys&nbsp;maybe&nbsp;introduced&nbsp;in&nbsp;the&nbsp;future.<br>
&nbsp;<br>
Note:&nbsp;do&nbsp;not&nbsp;overload&nbsp;this&nbsp;method&nbsp;in&nbsp;an&nbsp;event&nbsp;loop&nbsp;subclass.<br>
For&nbsp;custom&nbsp;exception&nbsp;handling,&nbsp;use&nbsp;the<br>
`<a href="#SelectorEventLoop-set_exception_handler">set_exception_handler</a>()`&nbsp;method.</tt></dd></dl>

<dl><dt><a name="_WindowsSelectorEventLoop-call_later"><strong>call_later</strong></a>(self, delay, callback, *args, context=None)</dt><dd><tt>Arrange&nbsp;for&nbsp;a&nbsp;callback&nbsp;to&nbsp;be&nbsp;called&nbsp;at&nbsp;a&nbsp;given&nbsp;time.<br>
&nbsp;<br>
Return&nbsp;a&nbsp;<a href="#Handle">Handle</a>:&nbsp;an&nbsp;opaque&nbsp;<a href="builtins.html#object">object</a>&nbsp;with&nbsp;a&nbsp;cancel()&nbsp;method&nbsp;that<br>
can&nbsp;be&nbsp;used&nbsp;to&nbsp;cancel&nbsp;the&nbsp;call.<br>
&nbsp;<br>
The&nbsp;delay&nbsp;can&nbsp;be&nbsp;an&nbsp;int&nbsp;or&nbsp;float,&nbsp;expressed&nbsp;in&nbsp;seconds.&nbsp;&nbsp;It&nbsp;is<br>
always&nbsp;relative&nbsp;to&nbsp;the&nbsp;current&nbsp;time.<br>
&nbsp;<br>
Each&nbsp;callback&nbsp;will&nbsp;be&nbsp;called&nbsp;exactly&nbsp;once.&nbsp;&nbsp;If&nbsp;two&nbsp;callbacks<br>
are&nbsp;scheduled&nbsp;for&nbsp;exactly&nbsp;the&nbsp;same&nbsp;time,&nbsp;it&nbsp;undefined&nbsp;which<br>
will&nbsp;be&nbsp;called&nbsp;first.<br>
&nbsp;<br>
Any&nbsp;positional&nbsp;arguments&nbsp;after&nbsp;the&nbsp;callback&nbsp;will&nbsp;be&nbsp;passed&nbsp;to<br>
the&nbsp;callback&nbsp;when&nbsp;it&nbsp;is&nbsp;called.</tt></dd></dl>

<dl><dt><a name="_WindowsSelectorEventLoop-call_soon"><strong>call_soon</strong></a>(self, callback, *args, context=None)</dt><dd><tt>Arrange&nbsp;for&nbsp;a&nbsp;callback&nbsp;to&nbsp;be&nbsp;called&nbsp;as&nbsp;soon&nbsp;as&nbsp;possible.<br>
&nbsp;<br>
This&nbsp;operates&nbsp;as&nbsp;a&nbsp;FIFO&nbsp;queue:&nbsp;callbacks&nbsp;are&nbsp;called&nbsp;in&nbsp;the<br>
order&nbsp;in&nbsp;which&nbsp;they&nbsp;are&nbsp;registered.&nbsp;&nbsp;Each&nbsp;callback&nbsp;will&nbsp;be<br>
called&nbsp;exactly&nbsp;once.<br>
&nbsp;<br>
Any&nbsp;positional&nbsp;arguments&nbsp;after&nbsp;the&nbsp;callback&nbsp;will&nbsp;be&nbsp;passed&nbsp;to<br>
the&nbsp;callback&nbsp;when&nbsp;it&nbsp;is&nbsp;called.</tt></dd></dl>

<dl><dt><a name="_WindowsSelectorEventLoop-call_soon_threadsafe"><strong>call_soon_threadsafe</strong></a>(self, callback, *args, context=None)</dt><dd><tt>Like&nbsp;<a href="#SelectorEventLoop-call_soon">call_soon</a>(),&nbsp;but&nbsp;thread-safe.</tt></dd></dl>

<dl><dt>async <a name="_WindowsSelectorEventLoop-connect_accepted_socket"><strong>connect_accepted_socket</strong></a>(self, protocol_factory, sock, *, ssl=None, ssl_handshake_timeout=None)</dt><dd><tt><a href="#Handle">Handle</a>&nbsp;an&nbsp;accepted&nbsp;connection.<br>
&nbsp;<br>
This&nbsp;is&nbsp;used&nbsp;by&nbsp;servers&nbsp;that&nbsp;accept&nbsp;connections&nbsp;outside&nbsp;of<br>
asyncio&nbsp;but&nbsp;that&nbsp;use&nbsp;asyncio&nbsp;to&nbsp;handle&nbsp;connections.<br>
&nbsp;<br>
This&nbsp;method&nbsp;is&nbsp;a&nbsp;coroutine.&nbsp;&nbsp;When&nbsp;completed,&nbsp;the&nbsp;coroutine<br>
returns&nbsp;a&nbsp;(transport,&nbsp;protocol)&nbsp;pair.</tt></dd></dl>

<dl><dt>async <a name="_WindowsSelectorEventLoop-connect_read_pipe"><strong>connect_read_pipe</strong></a>(self, protocol_factory, pipe)</dt><dd><tt>Register&nbsp;read&nbsp;pipe&nbsp;in&nbsp;event&nbsp;loop.&nbsp;Set&nbsp;the&nbsp;pipe&nbsp;to&nbsp;non-blocking&nbsp;mode.<br>
&nbsp;<br>
protocol_factory&nbsp;should&nbsp;instantiate&nbsp;<a href="builtins.html#object">object</a>&nbsp;with&nbsp;<a href="#Protocol">Protocol</a>&nbsp;interface.<br>
pipe&nbsp;is&nbsp;a&nbsp;file-like&nbsp;<a href="builtins.html#object">object</a>.<br>
Return&nbsp;pair&nbsp;(transport,&nbsp;protocol),&nbsp;where&nbsp;transport&nbsp;supports&nbsp;the<br>
<a href="#ReadTransport">ReadTransport</a>&nbsp;interface.</tt></dd></dl>

<dl><dt>async <a name="_WindowsSelectorEventLoop-connect_write_pipe"><strong>connect_write_pipe</strong></a>(self, protocol_factory, pipe)</dt><dd><tt>Register&nbsp;write&nbsp;pipe&nbsp;in&nbsp;event&nbsp;loop.<br>
&nbsp;<br>
protocol_factory&nbsp;should&nbsp;instantiate&nbsp;<a href="builtins.html#object">object</a>&nbsp;with&nbsp;<a href="#BaseProtocol">BaseProtocol</a>&nbsp;interface.<br>
Pipe&nbsp;is&nbsp;file-like&nbsp;<a href="builtins.html#object">object</a>&nbsp;already&nbsp;switched&nbsp;to&nbsp;nonblocking.<br>
Return&nbsp;pair&nbsp;(transport,&nbsp;protocol),&nbsp;where&nbsp;transport&nbsp;support<br>
<a href="#WriteTransport">WriteTransport</a>&nbsp;interface.</tt></dd></dl>

<dl><dt>async <a name="_WindowsSelectorEventLoop-create_connection"><strong>create_connection</strong></a>(self, protocol_factory, host=None, port=None, *, ssl=None, family=0, proto=0, flags=0, sock=None, local_addr=None, server_hostname=None, ssl_handshake_timeout=None, happy_eyeballs_delay=None, interleave=None)</dt><dd><tt>Connect&nbsp;to&nbsp;a&nbsp;TCP&nbsp;server.<br>
&nbsp;<br>
Create&nbsp;a&nbsp;streaming&nbsp;transport&nbsp;connection&nbsp;to&nbsp;a&nbsp;given&nbsp;Internet&nbsp;host&nbsp;and<br>
port:&nbsp;socket&nbsp;family&nbsp;AF_INET&nbsp;or&nbsp;socket.AF_INET6&nbsp;depending&nbsp;on&nbsp;host&nbsp;(or<br>
family&nbsp;if&nbsp;specified),&nbsp;socket&nbsp;type&nbsp;SOCK_STREAM.&nbsp;protocol_factory&nbsp;must&nbsp;be<br>
a&nbsp;callable&nbsp;returning&nbsp;a&nbsp;protocol&nbsp;instance.<br>
&nbsp;<br>
This&nbsp;method&nbsp;is&nbsp;a&nbsp;coroutine&nbsp;which&nbsp;will&nbsp;try&nbsp;to&nbsp;establish&nbsp;the&nbsp;connection<br>
in&nbsp;the&nbsp;background.&nbsp;&nbsp;When&nbsp;successful,&nbsp;the&nbsp;coroutine&nbsp;returns&nbsp;a<br>
(transport,&nbsp;protocol)&nbsp;pair.</tt></dd></dl>

<dl><dt>async <a name="_WindowsSelectorEventLoop-create_datagram_endpoint"><strong>create_datagram_endpoint</strong></a>(self, protocol_factory, local_addr=None, remote_addr=None, *, family=0, proto=0, flags=0, reuse_address=&lt;object object at 0x000001ED9C15F660&gt;, reuse_port=None, allow_broadcast=None, sock=None)</dt><dd><tt>Create&nbsp;datagram&nbsp;connection.</tt></dd></dl>

<dl><dt><a name="_WindowsSelectorEventLoop-create_future"><strong>create_future</strong></a>(self)</dt><dd><tt>Create&nbsp;a&nbsp;<a href="#Future">Future</a>&nbsp;<a href="builtins.html#object">object</a>&nbsp;attached&nbsp;to&nbsp;the&nbsp;loop.</tt></dd></dl>

<dl><dt>async <a name="_WindowsSelectorEventLoop-create_server"><strong>create_server</strong></a>(self, protocol_factory, host=None, port=None, *, family=&lt;AddressFamily.AF_UNSPEC: 0&gt;, flags=&lt;AddressInfo.AI_PASSIVE: 1&gt;, sock=None, backlog=100, ssl=None, reuse_address=None, reuse_port=None, ssl_handshake_timeout=None, start_serving=True)</dt><dd><tt>Create&nbsp;a&nbsp;TCP&nbsp;server.<br>
&nbsp;<br>
The&nbsp;host&nbsp;parameter&nbsp;can&nbsp;be&nbsp;a&nbsp;string,&nbsp;in&nbsp;that&nbsp;case&nbsp;the&nbsp;TCP&nbsp;server&nbsp;is<br>
bound&nbsp;to&nbsp;host&nbsp;and&nbsp;port.<br>
&nbsp;<br>
The&nbsp;host&nbsp;parameter&nbsp;can&nbsp;also&nbsp;be&nbsp;a&nbsp;sequence&nbsp;of&nbsp;strings&nbsp;and&nbsp;in&nbsp;that&nbsp;case<br>
the&nbsp;TCP&nbsp;server&nbsp;is&nbsp;bound&nbsp;to&nbsp;all&nbsp;hosts&nbsp;of&nbsp;the&nbsp;sequence.&nbsp;If&nbsp;a&nbsp;host<br>
appears&nbsp;multiple&nbsp;times&nbsp;(possibly&nbsp;indirectly&nbsp;e.g.&nbsp;when&nbsp;hostnames<br>
resolve&nbsp;to&nbsp;the&nbsp;same&nbsp;IP&nbsp;address),&nbsp;the&nbsp;server&nbsp;is&nbsp;only&nbsp;bound&nbsp;once&nbsp;to&nbsp;that<br>
host.<br>
&nbsp;<br>
Return&nbsp;a&nbsp;Server&nbsp;<a href="builtins.html#object">object</a>&nbsp;which&nbsp;can&nbsp;be&nbsp;used&nbsp;to&nbsp;stop&nbsp;the&nbsp;service.<br>
&nbsp;<br>
This&nbsp;method&nbsp;is&nbsp;a&nbsp;coroutine.</tt></dd></dl>

<dl><dt><a name="_WindowsSelectorEventLoop-create_task"><strong>create_task</strong></a>(self, coro, *, name=None)</dt><dd><tt>Schedule&nbsp;a&nbsp;coroutine&nbsp;<a href="builtins.html#object">object</a>.<br>
&nbsp;<br>
Return&nbsp;a&nbsp;task&nbsp;<a href="builtins.html#object">object</a>.</tt></dd></dl>

<dl><dt><a name="_WindowsSelectorEventLoop-default_exception_handler"><strong>default_exception_handler</strong></a>(self, context)</dt><dd><tt>Default&nbsp;exception&nbsp;handler.<br>
&nbsp;<br>
This&nbsp;is&nbsp;called&nbsp;when&nbsp;an&nbsp;exception&nbsp;occurs&nbsp;and&nbsp;no&nbsp;exception<br>
handler&nbsp;is&nbsp;set,&nbsp;and&nbsp;can&nbsp;be&nbsp;called&nbsp;by&nbsp;a&nbsp;custom&nbsp;exception<br>
handler&nbsp;that&nbsp;wants&nbsp;to&nbsp;defer&nbsp;to&nbsp;the&nbsp;default&nbsp;behavior.<br>
&nbsp;<br>
This&nbsp;default&nbsp;handler&nbsp;logs&nbsp;the&nbsp;error&nbsp;message&nbsp;and&nbsp;other<br>
context-dependent&nbsp;information.&nbsp;&nbsp;In&nbsp;debug&nbsp;mode,&nbsp;a&nbsp;truncated<br>
stack&nbsp;trace&nbsp;is&nbsp;also&nbsp;appended&nbsp;showing&nbsp;where&nbsp;the&nbsp;given&nbsp;<a href="builtins.html#object">object</a><br>
(e.g.&nbsp;a&nbsp;handle&nbsp;or&nbsp;future&nbsp;or&nbsp;task)&nbsp;was&nbsp;created,&nbsp;if&nbsp;any.<br>
&nbsp;<br>
The&nbsp;context&nbsp;parameter&nbsp;has&nbsp;the&nbsp;same&nbsp;meaning&nbsp;as&nbsp;in<br>
`<a href="#SelectorEventLoop-call_exception_handler">call_exception_handler</a>()`.</tt></dd></dl>

<dl><dt><a name="_WindowsSelectorEventLoop-get_debug"><strong>get_debug</strong></a>(self)</dt></dl>

<dl><dt><a name="_WindowsSelectorEventLoop-get_exception_handler"><strong>get_exception_handler</strong></a>(self)</dt><dd><tt>Return&nbsp;an&nbsp;exception&nbsp;handler,&nbsp;or&nbsp;None&nbsp;if&nbsp;the&nbsp;default&nbsp;one&nbsp;is&nbsp;in&nbsp;use.</tt></dd></dl>

<dl><dt><a name="_WindowsSelectorEventLoop-get_task_factory"><strong>get_task_factory</strong></a>(self)</dt><dd><tt>Return&nbsp;a&nbsp;task&nbsp;factory,&nbsp;or&nbsp;None&nbsp;if&nbsp;the&nbsp;default&nbsp;one&nbsp;is&nbsp;in&nbsp;use.</tt></dd></dl>

<dl><dt>async <a name="_WindowsSelectorEventLoop-getaddrinfo"><strong>getaddrinfo</strong></a>(self, host, port, *, family=0, type=0, proto=0, flags=0)</dt></dl>

<dl><dt>async <a name="_WindowsSelectorEventLoop-getnameinfo"><strong>getnameinfo</strong></a>(self, sockaddr, flags=0)</dt></dl>

<dl><dt><a name="_WindowsSelectorEventLoop-is_closed"><strong>is_closed</strong></a>(self)</dt><dd><tt>Returns&nbsp;True&nbsp;if&nbsp;the&nbsp;event&nbsp;loop&nbsp;was&nbsp;closed.</tt></dd></dl>

<dl><dt><a name="_WindowsSelectorEventLoop-is_running"><strong>is_running</strong></a>(self)</dt><dd><tt>Returns&nbsp;True&nbsp;if&nbsp;the&nbsp;event&nbsp;loop&nbsp;is&nbsp;running.</tt></dd></dl>

<dl><dt><a name="_WindowsSelectorEventLoop-run_forever"><strong>run_forever</strong></a>(self)</dt><dd><tt>Run&nbsp;until&nbsp;<a href="#SelectorEventLoop-stop">stop</a>()&nbsp;is&nbsp;called.</tt></dd></dl>

<dl><dt><a name="_WindowsSelectorEventLoop-run_in_executor"><strong>run_in_executor</strong></a>(self, executor, func, *args)</dt></dl>

<dl><dt><a name="_WindowsSelectorEventLoop-run_until_complete"><strong>run_until_complete</strong></a>(self, future)</dt><dd><tt>Run&nbsp;until&nbsp;the&nbsp;<a href="#Future">Future</a>&nbsp;is&nbsp;done.<br>
&nbsp;<br>
If&nbsp;the&nbsp;argument&nbsp;is&nbsp;a&nbsp;coroutine,&nbsp;it&nbsp;is&nbsp;wrapped&nbsp;in&nbsp;a&nbsp;<a href="#Task">Task</a>.<br>
&nbsp;<br>
WARNING:&nbsp;It&nbsp;would&nbsp;be&nbsp;disastrous&nbsp;to&nbsp;call&nbsp;<a href="#SelectorEventLoop-run_until_complete">run_until_complete</a>()<br>
with&nbsp;the&nbsp;same&nbsp;coroutine&nbsp;twice&nbsp;--&nbsp;it&nbsp;would&nbsp;wrap&nbsp;it&nbsp;in&nbsp;two<br>
different&nbsp;Tasks&nbsp;and&nbsp;that&nbsp;can't&nbsp;be&nbsp;good.<br>
&nbsp;<br>
Return&nbsp;the&nbsp;<a href="#Future">Future</a>'s&nbsp;result,&nbsp;or&nbsp;raise&nbsp;its&nbsp;exception.</tt></dd></dl>

<dl><dt>async <a name="_WindowsSelectorEventLoop-sendfile"><strong>sendfile</strong></a>(self, transport, file, offset=0, count=None, *, fallback=True)</dt><dd><tt>Send&nbsp;a&nbsp;file&nbsp;to&nbsp;transport.<br>
&nbsp;<br>
Return&nbsp;the&nbsp;total&nbsp;number&nbsp;of&nbsp;bytes&nbsp;which&nbsp;were&nbsp;sent.<br>
&nbsp;<br>
The&nbsp;method&nbsp;uses&nbsp;high-performance&nbsp;os.sendfile&nbsp;if&nbsp;available.<br>
&nbsp;<br>
file&nbsp;must&nbsp;be&nbsp;a&nbsp;regular&nbsp;file&nbsp;<a href="builtins.html#object">object</a>&nbsp;opened&nbsp;in&nbsp;binary&nbsp;mode.<br>
&nbsp;<br>
offset&nbsp;tells&nbsp;from&nbsp;where&nbsp;to&nbsp;start&nbsp;reading&nbsp;the&nbsp;file.&nbsp;If&nbsp;specified,<br>
count&nbsp;is&nbsp;the&nbsp;total&nbsp;number&nbsp;of&nbsp;bytes&nbsp;to&nbsp;transmit&nbsp;as&nbsp;opposed&nbsp;to<br>
sending&nbsp;the&nbsp;file&nbsp;until&nbsp;EOF&nbsp;is&nbsp;reached.&nbsp;File&nbsp;position&nbsp;is&nbsp;updated&nbsp;on<br>
return&nbsp;or&nbsp;also&nbsp;in&nbsp;case&nbsp;of&nbsp;error&nbsp;in&nbsp;which&nbsp;case&nbsp;file.tell()<br>
can&nbsp;be&nbsp;used&nbsp;to&nbsp;figure&nbsp;out&nbsp;the&nbsp;number&nbsp;of&nbsp;bytes<br>
which&nbsp;were&nbsp;sent.<br>
&nbsp;<br>
fallback&nbsp;set&nbsp;to&nbsp;True&nbsp;makes&nbsp;asyncio&nbsp;to&nbsp;manually&nbsp;read&nbsp;and&nbsp;send<br>
the&nbsp;file&nbsp;when&nbsp;the&nbsp;platform&nbsp;does&nbsp;not&nbsp;support&nbsp;the&nbsp;sendfile&nbsp;syscall<br>
(e.g.&nbsp;Windows&nbsp;or&nbsp;SSL&nbsp;socket&nbsp;on&nbsp;Unix).<br>
&nbsp;<br>
Raise&nbsp;<a href="#SendfileNotAvailableError">SendfileNotAvailableError</a>&nbsp;if&nbsp;the&nbsp;system&nbsp;does&nbsp;not&nbsp;support<br>
sendfile&nbsp;syscall&nbsp;and&nbsp;fallback&nbsp;is&nbsp;False.</tt></dd></dl>

<dl><dt><a name="_WindowsSelectorEventLoop-set_debug"><strong>set_debug</strong></a>(self, enabled)</dt></dl>

<dl><dt><a name="_WindowsSelectorEventLoop-set_default_executor"><strong>set_default_executor</strong></a>(self, executor)</dt></dl>

<dl><dt><a name="_WindowsSelectorEventLoop-set_exception_handler"><strong>set_exception_handler</strong></a>(self, handler)</dt><dd><tt>Set&nbsp;handler&nbsp;as&nbsp;the&nbsp;new&nbsp;event&nbsp;loop&nbsp;exception&nbsp;handler.<br>
&nbsp;<br>
If&nbsp;handler&nbsp;is&nbsp;None,&nbsp;the&nbsp;default&nbsp;exception&nbsp;handler&nbsp;will<br>
be&nbsp;set.<br>
&nbsp;<br>
If&nbsp;handler&nbsp;is&nbsp;a&nbsp;callable&nbsp;<a href="builtins.html#object">object</a>,&nbsp;it&nbsp;should&nbsp;have&nbsp;a<br>
signature&nbsp;matching&nbsp;'(loop,&nbsp;context)',&nbsp;where&nbsp;'loop'<br>
will&nbsp;be&nbsp;a&nbsp;reference&nbsp;to&nbsp;the&nbsp;active&nbsp;event&nbsp;loop,&nbsp;'context'<br>
will&nbsp;be&nbsp;a&nbsp;dict&nbsp;<a href="builtins.html#object">object</a>&nbsp;(see&nbsp;`<a href="#SelectorEventLoop-call_exception_handler">call_exception_handler</a>()`<br>
documentation&nbsp;for&nbsp;details&nbsp;about&nbsp;context).</tt></dd></dl>

<dl><dt><a name="_WindowsSelectorEventLoop-set_task_factory"><strong>set_task_factory</strong></a>(self, factory)</dt><dd><tt>Set&nbsp;a&nbsp;task&nbsp;factory&nbsp;that&nbsp;will&nbsp;be&nbsp;used&nbsp;by&nbsp;loop.<a href="#SelectorEventLoop-create_task">create_task</a>().<br>
&nbsp;<br>
If&nbsp;factory&nbsp;is&nbsp;None&nbsp;the&nbsp;default&nbsp;task&nbsp;factory&nbsp;will&nbsp;be&nbsp;set.<br>
&nbsp;<br>
If&nbsp;factory&nbsp;is&nbsp;a&nbsp;callable,&nbsp;it&nbsp;should&nbsp;have&nbsp;a&nbsp;signature&nbsp;matching<br>
'(loop,&nbsp;coro)',&nbsp;where&nbsp;'loop'&nbsp;will&nbsp;be&nbsp;a&nbsp;reference&nbsp;to&nbsp;the&nbsp;active<br>
event&nbsp;loop,&nbsp;'coro'&nbsp;will&nbsp;be&nbsp;a&nbsp;coroutine&nbsp;<a href="builtins.html#object">object</a>.&nbsp;&nbsp;The&nbsp;callable<br>
must&nbsp;return&nbsp;a&nbsp;<a href="#Future">Future</a>.</tt></dd></dl>

<dl><dt>async <a name="_WindowsSelectorEventLoop-shutdown_asyncgens"><strong>shutdown_asyncgens</strong></a>(self)</dt><dd><tt>Shutdown&nbsp;all&nbsp;active&nbsp;asynchronous&nbsp;generators.</tt></dd></dl>

<dl><dt>async <a name="_WindowsSelectorEventLoop-sock_sendfile"><strong>sock_sendfile</strong></a>(self, sock, file, offset=0, count=None, *, fallback=True)</dt></dl>

<dl><dt>async <a name="_WindowsSelectorEventLoop-start_tls"><strong>start_tls</strong></a>(self, transport, protocol, sslcontext, *, server_side=False, server_hostname=None, ssl_handshake_timeout=None)</dt><dd><tt>Upgrade&nbsp;transport&nbsp;to&nbsp;TLS.<br>
&nbsp;<br>
Return&nbsp;a&nbsp;new&nbsp;transport&nbsp;that&nbsp;*protocol*&nbsp;should&nbsp;start&nbsp;using<br>
immediately.</tt></dd></dl>

<dl><dt><a name="_WindowsSelectorEventLoop-stop"><strong>stop</strong></a>(self)</dt><dd><tt>Stop&nbsp;running&nbsp;the&nbsp;event&nbsp;loop.<br>
&nbsp;<br>
Every&nbsp;callback&nbsp;already&nbsp;scheduled&nbsp;will&nbsp;still&nbsp;run.&nbsp;&nbsp;This&nbsp;simply&nbsp;informs<br>
run_forever&nbsp;to&nbsp;stop&nbsp;looping&nbsp;after&nbsp;a&nbsp;complete&nbsp;iteration.</tt></dd></dl>

<dl><dt>async <a name="_WindowsSelectorEventLoop-subprocess_exec"><strong>subprocess_exec</strong></a>(self, protocol_factory, program, *args, stdin=-1, stdout=-1, stderr=-1, universal_newlines=False, shell=False, bufsize=0, encoding=None, errors=None, text=None, **kwargs)</dt></dl>

<dl><dt>async <a name="_WindowsSelectorEventLoop-subprocess_shell"><strong>subprocess_shell</strong></a>(self, protocol_factory, cmd, *, stdin=-1, stdout=-1, stderr=-1, universal_newlines=False, shell=True, bufsize=0, encoding=None, errors=None, text=None, **kwargs)</dt></dl>

<dl><dt><a name="_WindowsSelectorEventLoop-time"><strong>time</strong></a>(self)</dt><dd><tt>Return&nbsp;the&nbsp;time&nbsp;according&nbsp;to&nbsp;the&nbsp;event&nbsp;loop's&nbsp;clock.<br>
&nbsp;<br>
This&nbsp;is&nbsp;a&nbsp;float&nbsp;expressed&nbsp;in&nbsp;seconds&nbsp;since&nbsp;an&nbsp;epoch,&nbsp;but&nbsp;the<br>
epoch,&nbsp;precision,&nbsp;accuracy&nbsp;and&nbsp;drift&nbsp;are&nbsp;unspecified&nbsp;and&nbsp;may<br>
differ&nbsp;per&nbsp;event&nbsp;loop.</tt></dd></dl>

<hr>
Methods inherited from <a href="asyncio.events.html#AbstractEventLoop">asyncio.events.AbstractEventLoop</a>:<br>
<dl><dt><a name="_WindowsSelectorEventLoop-add_signal_handler"><strong>add_signal_handler</strong></a>(self, sig, callback, *args)</dt></dl>

<dl><dt>async <a name="_WindowsSelectorEventLoop-create_unix_connection"><strong>create_unix_connection</strong></a>(self, protocol_factory, path=None, *, ssl=None, sock=None, server_hostname=None, ssl_handshake_timeout=None)</dt></dl>

<dl><dt>async <a name="_WindowsSelectorEventLoop-create_unix_server"><strong>create_unix_server</strong></a>(self, protocol_factory, path=None, *, sock=None, backlog=100, ssl=None, ssl_handshake_timeout=None, start_serving=True)</dt><dd><tt>A&nbsp;coroutine&nbsp;which&nbsp;creates&nbsp;a&nbsp;UNIX&nbsp;Domain&nbsp;Socket&nbsp;server.<br>
&nbsp;<br>
The&nbsp;return&nbsp;value&nbsp;is&nbsp;a&nbsp;Server&nbsp;<a href="builtins.html#object">object</a>,&nbsp;which&nbsp;can&nbsp;be&nbsp;used&nbsp;to&nbsp;stop<br>
the&nbsp;service.<br>
&nbsp;<br>
path&nbsp;is&nbsp;a&nbsp;str,&nbsp;representing&nbsp;a&nbsp;file&nbsp;systsem&nbsp;path&nbsp;to&nbsp;bind&nbsp;the<br>
server&nbsp;socket&nbsp;to.<br>
&nbsp;<br>
sock&nbsp;can&nbsp;optionally&nbsp;be&nbsp;specified&nbsp;in&nbsp;order&nbsp;to&nbsp;use&nbsp;a&nbsp;preexisting<br>
socket&nbsp;<a href="builtins.html#object">object</a>.<br>
&nbsp;<br>
backlog&nbsp;is&nbsp;the&nbsp;maximum&nbsp;number&nbsp;of&nbsp;queued&nbsp;connections&nbsp;passed&nbsp;to<br>
listen()&nbsp;(defaults&nbsp;to&nbsp;100).<br>
&nbsp;<br>
ssl&nbsp;can&nbsp;be&nbsp;set&nbsp;to&nbsp;an&nbsp;SSLContext&nbsp;to&nbsp;enable&nbsp;SSL&nbsp;over&nbsp;the<br>
accepted&nbsp;connections.<br>
&nbsp;<br>
ssl_handshake_timeout&nbsp;is&nbsp;the&nbsp;time&nbsp;in&nbsp;seconds&nbsp;that&nbsp;an&nbsp;SSL&nbsp;server<br>
will&nbsp;wait&nbsp;for&nbsp;the&nbsp;SSL&nbsp;handshake&nbsp;to&nbsp;complete&nbsp;(defaults&nbsp;to&nbsp;60s).<br>
&nbsp;<br>
start_serving&nbsp;set&nbsp;to&nbsp;True&nbsp;(default)&nbsp;causes&nbsp;the&nbsp;created&nbsp;server<br>
to&nbsp;start&nbsp;accepting&nbsp;connections&nbsp;immediately.&nbsp;&nbsp;When&nbsp;set&nbsp;to&nbsp;False,<br>
the&nbsp;user&nbsp;should&nbsp;await&nbsp;Server.start_serving()&nbsp;or&nbsp;Server.serve_forever()<br>
to&nbsp;make&nbsp;the&nbsp;server&nbsp;to&nbsp;start&nbsp;accepting&nbsp;connections.</tt></dd></dl>

<dl><dt><a name="_WindowsSelectorEventLoop-remove_signal_handler"><strong>remove_signal_handler</strong></a>(self, sig)</dt></dl>

<hr>
Data descriptors inherited from <a href="asyncio.events.html#AbstractEventLoop">asyncio.events.AbstractEventLoop</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="Semaphore">class <strong>Semaphore</strong></a>(<a href="asyncio.locks.html#_ContextManagerMixin">_ContextManagerMixin</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#Semaphore">Semaphore</a>(value=1,&nbsp;*,&nbsp;loop=None)<br>
&nbsp;<br>
A&nbsp;<a href="#Semaphore">Semaphore</a>&nbsp;implementation.<br>
&nbsp;<br>
A&nbsp;semaphore&nbsp;manages&nbsp;an&nbsp;internal&nbsp;counter&nbsp;which&nbsp;is&nbsp;decremented&nbsp;by&nbsp;each<br>
<a href="#Semaphore-acquire">acquire</a>()&nbsp;call&nbsp;and&nbsp;incremented&nbsp;by&nbsp;each&nbsp;<a href="#Semaphore-release">release</a>()&nbsp;call.&nbsp;The&nbsp;counter<br>
can&nbsp;never&nbsp;go&nbsp;below&nbsp;zero;&nbsp;when&nbsp;<a href="#Semaphore-acquire">acquire</a>()&nbsp;finds&nbsp;that&nbsp;it&nbsp;is&nbsp;zero,&nbsp;it&nbsp;blocks,<br>
waiting&nbsp;until&nbsp;some&nbsp;other&nbsp;thread&nbsp;calls&nbsp;<a href="#Semaphore-release">release</a>().<br>
&nbsp;<br>
Semaphores&nbsp;also&nbsp;support&nbsp;the&nbsp;context&nbsp;management&nbsp;protocol.<br>
&nbsp;<br>
The&nbsp;optional&nbsp;argument&nbsp;gives&nbsp;the&nbsp;initial&nbsp;value&nbsp;for&nbsp;the&nbsp;internal<br>
counter;&nbsp;it&nbsp;defaults&nbsp;to&nbsp;1.&nbsp;If&nbsp;the&nbsp;value&nbsp;given&nbsp;is&nbsp;less&nbsp;than&nbsp;0,<br>
ValueError&nbsp;is&nbsp;raised.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="asyncio.locks.html#Semaphore">Semaphore</a></dd>
<dd><a href="asyncio.locks.html#_ContextManagerMixin">_ContextManagerMixin</a></dd>
<dd><a href="builtins.html#object">builtins.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="Semaphore-__init__"><strong>__init__</strong></a>(self, value=1, *, loop=None)</dt><dd><tt>Initialize&nbsp;self.&nbsp;&nbsp;See&nbsp;help(type(self))&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<dl><dt><a name="Semaphore-__repr__"><strong>__repr__</strong></a>(self)</dt><dd><tt>Return&nbsp;repr(self).</tt></dd></dl>

<dl><dt>async <a name="Semaphore-acquire"><strong>acquire</strong></a>(self)</dt><dd><tt>Acquire&nbsp;a&nbsp;semaphore.<br>
&nbsp;<br>
If&nbsp;the&nbsp;internal&nbsp;counter&nbsp;is&nbsp;larger&nbsp;than&nbsp;zero&nbsp;on&nbsp;entry,<br>
decrement&nbsp;it&nbsp;by&nbsp;one&nbsp;and&nbsp;return&nbsp;True&nbsp;immediately.&nbsp;&nbsp;If&nbsp;it&nbsp;is<br>
zero&nbsp;on&nbsp;entry,&nbsp;block,&nbsp;waiting&nbsp;until&nbsp;some&nbsp;other&nbsp;coroutine&nbsp;has<br>
called&nbsp;<a href="#Semaphore-release">release</a>()&nbsp;to&nbsp;make&nbsp;it&nbsp;larger&nbsp;than&nbsp;0,&nbsp;and&nbsp;then&nbsp;return<br>
True.</tt></dd></dl>

<dl><dt><a name="Semaphore-locked"><strong>locked</strong></a>(self)</dt><dd><tt>Returns&nbsp;True&nbsp;if&nbsp;semaphore&nbsp;can&nbsp;not&nbsp;be&nbsp;acquired&nbsp;immediately.</tt></dd></dl>

<dl><dt><a name="Semaphore-release"><strong>release</strong></a>(self)</dt><dd><tt>Release&nbsp;a&nbsp;semaphore,&nbsp;incrementing&nbsp;the&nbsp;internal&nbsp;counter&nbsp;by&nbsp;one.<br>
When&nbsp;it&nbsp;was&nbsp;zero&nbsp;on&nbsp;entry&nbsp;and&nbsp;another&nbsp;coroutine&nbsp;is&nbsp;waiting&nbsp;for&nbsp;it&nbsp;to<br>
become&nbsp;larger&nbsp;than&nbsp;zero&nbsp;again,&nbsp;wake&nbsp;up&nbsp;that&nbsp;coroutine.</tt></dd></dl>

<hr>
Methods inherited from <a href="asyncio.locks.html#_ContextManagerMixin">_ContextManagerMixin</a>:<br>
<dl><dt>async <a name="Semaphore-__aenter__"><strong>__aenter__</strong></a>(self)</dt></dl>

<dl><dt>async <a name="Semaphore-__aexit__"><strong>__aexit__</strong></a>(self, exc_type, exc, tb)</dt></dl>

<dl><dt><a name="Semaphore-__await__"><strong>__await__</strong></a>(self)</dt></dl>

<dl><dt><a name="Semaphore-__enter__"><strong>__enter__</strong></a>(self)</dt></dl>

<dl><dt><a name="Semaphore-__exit__"><strong>__exit__</strong></a>(self, *args)</dt></dl>

<dl><dt><a name="Semaphore-__iter__"><strong>__iter__</strong></a>(self)</dt></dl>

<hr>
Data descriptors inherited from <a href="asyncio.locks.html#_ContextManagerMixin">_ContextManagerMixin</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="SendfileNotAvailableError">class <strong>SendfileNotAvailableError</strong></a>(<a href="builtins.html#RuntimeError">builtins.RuntimeError</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt>Sendfile&nbsp;syscall&nbsp;is&nbsp;not&nbsp;available.<br>
&nbsp;<br>
Raised&nbsp;if&nbsp;OS&nbsp;does&nbsp;not&nbsp;support&nbsp;sendfile&nbsp;syscall&nbsp;for&nbsp;given&nbsp;socket&nbsp;or<br>
file&nbsp;type.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="asyncio.exceptions.html#SendfileNotAvailableError">SendfileNotAvailableError</a></dd>
<dd><a href="builtins.html#RuntimeError">builtins.RuntimeError</a></dd>
<dd><a href="builtins.html#Exception">builtins.Exception</a></dd>
<dd><a href="builtins.html#BaseException">builtins.BaseException</a></dd>
<dd><a href="builtins.html#object">builtins.object</a></dd>
</dl>
<hr>
Data descriptors defined here:<br>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<hr>
Methods inherited from <a href="builtins.html#RuntimeError">builtins.RuntimeError</a>:<br>
<dl><dt><a name="SendfileNotAvailableError-__init__"><strong>__init__</strong></a>(self, /, *args, **kwargs)</dt><dd><tt>Initialize&nbsp;self.&nbsp;&nbsp;See&nbsp;help(type(self))&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<hr>
Static methods inherited from <a href="builtins.html#RuntimeError">builtins.RuntimeError</a>:<br>
<dl><dt><a name="SendfileNotAvailableError-__new__"><strong>__new__</strong></a>(*args, **kwargs)<font color="#909090"><font face="helvetica, arial"> from <a href="builtins.html#type">builtins.type</a></font></font></dt><dd><tt>Create&nbsp;and&nbsp;return&nbsp;a&nbsp;new&nbsp;<a href="builtins.html#object">object</a>.&nbsp;&nbsp;See&nbsp;help(type)&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<hr>
Methods inherited from <a href="builtins.html#BaseException">builtins.BaseException</a>:<br>
<dl><dt><a name="SendfileNotAvailableError-__delattr__"><strong>__delattr__</strong></a>(self, name, /)</dt><dd><tt>Implement&nbsp;delattr(self,&nbsp;name).</tt></dd></dl>

<dl><dt><a name="SendfileNotAvailableError-__getattribute__"><strong>__getattribute__</strong></a>(self, name, /)</dt><dd><tt>Return&nbsp;getattr(self,&nbsp;name).</tt></dd></dl>

<dl><dt><a name="SendfileNotAvailableError-__reduce__"><strong>__reduce__</strong></a>(...)</dt><dd><tt>Helper&nbsp;for&nbsp;pickle.</tt></dd></dl>

<dl><dt><a name="SendfileNotAvailableError-__repr__"><strong>__repr__</strong></a>(self, /)</dt><dd><tt>Return&nbsp;repr(self).</tt></dd></dl>

<dl><dt><a name="SendfileNotAvailableError-__setattr__"><strong>__setattr__</strong></a>(self, name, value, /)</dt><dd><tt>Implement&nbsp;setattr(self,&nbsp;name,&nbsp;value).</tt></dd></dl>

<dl><dt><a name="SendfileNotAvailableError-__setstate__"><strong>__setstate__</strong></a>(...)</dt></dl>

<dl><dt><a name="SendfileNotAvailableError-__str__"><strong>__str__</strong></a>(self, /)</dt><dd><tt>Return&nbsp;str(self).</tt></dd></dl>

<dl><dt><a name="SendfileNotAvailableError-with_traceback"><strong>with_traceback</strong></a>(...)</dt><dd><tt><a href="builtins.html#Exception">Exception</a>.<a href="#SendfileNotAvailableError-with_traceback">with_traceback</a>(tb)&nbsp;--<br>
set&nbsp;self.<strong>__traceback__</strong>&nbsp;to&nbsp;tb&nbsp;and&nbsp;return&nbsp;self.</tt></dd></dl>

<hr>
Data descriptors inherited from <a href="builtins.html#BaseException">builtins.BaseException</a>:<br>
<dl><dt><strong>__cause__</strong></dt>
<dd><tt>exception&nbsp;cause</tt></dd>
</dl>
<dl><dt><strong>__context__</strong></dt>
<dd><tt>exception&nbsp;context</tt></dd>
</dl>
<dl><dt><strong>__dict__</strong></dt>
</dl>
<dl><dt><strong>__suppress_context__</strong></dt>
</dl>
<dl><dt><strong>__traceback__</strong></dt>
</dl>
<dl><dt><strong>args</strong></dt>
</dl>
</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="StreamReader">class <strong>StreamReader</strong></a>(<a href="builtins.html#object">builtins.object</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#StreamReader">StreamReader</a>(limit=65536,&nbsp;loop=None)<br>
&nbsp;<br>
<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%">Methods defined here:<br>
<dl><dt><a name="StreamReader-__aiter__"><strong>__aiter__</strong></a>(self)</dt></dl>

<dl><dt>async <a name="StreamReader-__anext__"><strong>__anext__</strong></a>(self)</dt></dl>

<dl><dt><a name="StreamReader-__init__"><strong>__init__</strong></a>(self, limit=65536, loop=None)</dt><dd><tt>Initialize&nbsp;self.&nbsp;&nbsp;See&nbsp;help(type(self))&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<dl><dt><a name="StreamReader-__repr__"><strong>__repr__</strong></a>(self)</dt><dd><tt>Return&nbsp;repr(self).</tt></dd></dl>

<dl><dt><a name="StreamReader-at_eof"><strong>at_eof</strong></a>(self)</dt><dd><tt>Return&nbsp;True&nbsp;if&nbsp;the&nbsp;buffer&nbsp;is&nbsp;empty&nbsp;and&nbsp;'feed_eof'&nbsp;was&nbsp;called.</tt></dd></dl>

<dl><dt><a name="StreamReader-exception"><strong>exception</strong></a>(self)</dt></dl>

<dl><dt><a name="StreamReader-feed_data"><strong>feed_data</strong></a>(self, data)</dt></dl>

<dl><dt><a name="StreamReader-feed_eof"><strong>feed_eof</strong></a>(self)</dt></dl>

<dl><dt>async <a name="StreamReader-read"><strong>read</strong></a>(self, n=-1)</dt><dd><tt>Read&nbsp;up&nbsp;to&nbsp;`n`&nbsp;bytes&nbsp;from&nbsp;the&nbsp;stream.<br>
&nbsp;<br>
If&nbsp;n&nbsp;is&nbsp;not&nbsp;provided,&nbsp;or&nbsp;set&nbsp;to&nbsp;-1,&nbsp;read&nbsp;until&nbsp;EOF&nbsp;and&nbsp;return&nbsp;all&nbsp;read<br>
bytes.&nbsp;If&nbsp;the&nbsp;EOF&nbsp;was&nbsp;received&nbsp;and&nbsp;the&nbsp;internal&nbsp;buffer&nbsp;is&nbsp;empty,&nbsp;return<br>
an&nbsp;empty&nbsp;bytes&nbsp;<a href="builtins.html#object">object</a>.<br>
&nbsp;<br>
If&nbsp;n&nbsp;is&nbsp;zero,&nbsp;return&nbsp;empty&nbsp;bytes&nbsp;<a href="builtins.html#object">object</a>&nbsp;immediately.<br>
&nbsp;<br>
If&nbsp;n&nbsp;is&nbsp;positive,&nbsp;this&nbsp;function&nbsp;try&nbsp;to&nbsp;read&nbsp;`n`&nbsp;bytes,&nbsp;and&nbsp;may&nbsp;return<br>
less&nbsp;or&nbsp;equal&nbsp;bytes&nbsp;than&nbsp;requested,&nbsp;but&nbsp;at&nbsp;least&nbsp;one&nbsp;byte.&nbsp;If&nbsp;EOF&nbsp;was<br>
received&nbsp;before&nbsp;any&nbsp;byte&nbsp;is&nbsp;read,&nbsp;this&nbsp;function&nbsp;returns&nbsp;empty&nbsp;byte<br>
<a href="builtins.html#object">object</a>.<br>
&nbsp;<br>
Returned&nbsp;value&nbsp;is&nbsp;not&nbsp;limited&nbsp;with&nbsp;limit,&nbsp;configured&nbsp;at&nbsp;stream<br>
creation.<br>
&nbsp;<br>
If&nbsp;stream&nbsp;was&nbsp;paused,&nbsp;this&nbsp;function&nbsp;will&nbsp;automatically&nbsp;resume&nbsp;it&nbsp;if<br>
needed.</tt></dd></dl>

<dl><dt>async <a name="StreamReader-readexactly"><strong>readexactly</strong></a>(self, n)</dt><dd><tt>Read&nbsp;exactly&nbsp;`n`&nbsp;bytes.<br>
&nbsp;<br>
Raise&nbsp;an&nbsp;<a href="#IncompleteReadError">IncompleteReadError</a>&nbsp;if&nbsp;EOF&nbsp;is&nbsp;reached&nbsp;before&nbsp;`n`&nbsp;bytes&nbsp;can&nbsp;be<br>
read.&nbsp;The&nbsp;<a href="#IncompleteReadError">IncompleteReadError</a>.partial&nbsp;attribute&nbsp;of&nbsp;the&nbsp;exception&nbsp;will<br>
contain&nbsp;the&nbsp;partial&nbsp;read&nbsp;bytes.<br>
&nbsp;<br>
if&nbsp;n&nbsp;is&nbsp;zero,&nbsp;return&nbsp;empty&nbsp;bytes&nbsp;<a href="builtins.html#object">object</a>.<br>
&nbsp;<br>
Returned&nbsp;value&nbsp;is&nbsp;not&nbsp;limited&nbsp;with&nbsp;limit,&nbsp;configured&nbsp;at&nbsp;stream<br>
creation.<br>
&nbsp;<br>
If&nbsp;stream&nbsp;was&nbsp;paused,&nbsp;this&nbsp;function&nbsp;will&nbsp;automatically&nbsp;resume&nbsp;it&nbsp;if<br>
needed.</tt></dd></dl>

<dl><dt>async <a name="StreamReader-readline"><strong>readline</strong></a>(self)</dt><dd><tt>Read&nbsp;chunk&nbsp;of&nbsp;data&nbsp;from&nbsp;the&nbsp;stream&nbsp;until&nbsp;newline&nbsp;(b'<br>
')&nbsp;is&nbsp;found.<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;On&nbsp;success,&nbsp;return&nbsp;chunk&nbsp;that&nbsp;ends&nbsp;with&nbsp;newline.&nbsp;If&nbsp;only&nbsp;partial<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;line&nbsp;can&nbsp;be&nbsp;read&nbsp;due&nbsp;to&nbsp;EOF,&nbsp;return&nbsp;incomplete&nbsp;line&nbsp;without<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;terminating&nbsp;newline.&nbsp;When&nbsp;EOF&nbsp;was&nbsp;reached&nbsp;while&nbsp;no&nbsp;bytes&nbsp;read,&nbsp;empty<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bytes&nbsp;<a href="builtins.html#object">object</a>&nbsp;is&nbsp;returned.<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;limit&nbsp;is&nbsp;reached,&nbsp;ValueError&nbsp;will&nbsp;be&nbsp;raised.&nbsp;In&nbsp;that&nbsp;case,&nbsp;if<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newline&nbsp;was&nbsp;found,&nbsp;complete&nbsp;line&nbsp;including&nbsp;newline&nbsp;will&nbsp;be&nbsp;removed<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;from&nbsp;internal&nbsp;buffer.&nbsp;Else,&nbsp;internal&nbsp;buffer&nbsp;will&nbsp;be&nbsp;cleared.&nbsp;Limit&nbsp;is<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;compared&nbsp;against&nbsp;part&nbsp;of&nbsp;the&nbsp;line&nbsp;without&nbsp;newline.<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If&nbsp;stream&nbsp;was&nbsp;paused,&nbsp;this&nbsp;function&nbsp;will&nbsp;automatically&nbsp;resume&nbsp;it&nbsp;if<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;needed.</tt></dd></dl>

<dl><dt>async <a name="StreamReader-readuntil"><strong>readuntil</strong></a>(self, separator=b'\n')</dt><dd><tt>Read&nbsp;data&nbsp;from&nbsp;the&nbsp;stream&nbsp;until&nbsp;``separator``&nbsp;is&nbsp;found.<br>
&nbsp;<br>
On&nbsp;success,&nbsp;the&nbsp;data&nbsp;and&nbsp;separator&nbsp;will&nbsp;be&nbsp;removed&nbsp;from&nbsp;the<br>
internal&nbsp;buffer&nbsp;(consumed).&nbsp;Returned&nbsp;data&nbsp;will&nbsp;include&nbsp;the<br>
separator&nbsp;at&nbsp;the&nbsp;end.<br>
&nbsp;<br>
Configured&nbsp;stream&nbsp;limit&nbsp;is&nbsp;used&nbsp;to&nbsp;check&nbsp;result.&nbsp;Limit&nbsp;sets&nbsp;the<br>
maximal&nbsp;length&nbsp;of&nbsp;data&nbsp;that&nbsp;can&nbsp;be&nbsp;returned,&nbsp;not&nbsp;counting&nbsp;the<br>
separator.<br>
&nbsp;<br>
If&nbsp;an&nbsp;EOF&nbsp;occurs&nbsp;and&nbsp;the&nbsp;complete&nbsp;separator&nbsp;is&nbsp;still&nbsp;not&nbsp;found,<br>
an&nbsp;<a href="#IncompleteReadError">IncompleteReadError</a>&nbsp;exception&nbsp;will&nbsp;be&nbsp;raised,&nbsp;and&nbsp;the&nbsp;internal<br>
buffer&nbsp;will&nbsp;be&nbsp;reset.&nbsp;&nbsp;The&nbsp;<a href="#IncompleteReadError">IncompleteReadError</a>.partial&nbsp;attribute<br>
may&nbsp;contain&nbsp;the&nbsp;separator&nbsp;partially.<br>
&nbsp;<br>
If&nbsp;the&nbsp;data&nbsp;cannot&nbsp;be&nbsp;read&nbsp;because&nbsp;of&nbsp;over&nbsp;limit,&nbsp;a<br>
<a href="#LimitOverrunError">LimitOverrunError</a>&nbsp;exception&nbsp;&nbsp;will&nbsp;be&nbsp;raised,&nbsp;and&nbsp;the&nbsp;data<br>
will&nbsp;be&nbsp;left&nbsp;in&nbsp;the&nbsp;internal&nbsp;buffer,&nbsp;so&nbsp;it&nbsp;can&nbsp;be&nbsp;read&nbsp;again.</tt></dd></dl>

<dl><dt><a name="StreamReader-set_exception"><strong>set_exception</strong></a>(self, exc)</dt></dl>

<dl><dt><a name="StreamReader-set_transport"><strong>set_transport</strong></a>(self, transport)</dt></dl>

<hr>
Data descriptors defined here:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="StreamReaderProtocol">class <strong>StreamReaderProtocol</strong></a>(<a href="asyncio.streams.html#FlowControlMixin">FlowControlMixin</a>, <a href="asyncio.protocols.html#Protocol">asyncio.protocols.Protocol</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#StreamReaderProtocol">StreamReaderProtocol</a>(stream_reader,&nbsp;client_connected_cb=None,&nbsp;loop=None)<br>
&nbsp;<br>
Helper&nbsp;class&nbsp;to&nbsp;adapt&nbsp;between&nbsp;<a href="#Protocol">Protocol</a>&nbsp;and&nbsp;<a href="#StreamReader">StreamReader</a>.<br>
&nbsp;<br>
(This&nbsp;is&nbsp;a&nbsp;helper&nbsp;class&nbsp;instead&nbsp;of&nbsp;making&nbsp;<a href="#StreamReader">StreamReader</a>&nbsp;itself&nbsp;a<br>
<a href="#Protocol">Protocol</a>&nbsp;subclass,&nbsp;because&nbsp;the&nbsp;<a href="#StreamReader">StreamReader</a>&nbsp;has&nbsp;other&nbsp;potential<br>
uses,&nbsp;and&nbsp;to&nbsp;prevent&nbsp;the&nbsp;user&nbsp;of&nbsp;the&nbsp;<a href="#StreamReader">StreamReader</a>&nbsp;to&nbsp;accidentally<br>
call&nbsp;inappropriate&nbsp;methods&nbsp;of&nbsp;the&nbsp;protocol.)<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="asyncio.streams.html#StreamReaderProtocol">StreamReaderProtocol</a></dd>
<dd><a href="asyncio.streams.html#FlowControlMixin">FlowControlMixin</a></dd>
<dd><a href="asyncio.protocols.html#Protocol">asyncio.protocols.Protocol</a></dd>
<dd><a href="asyncio.protocols.html#BaseProtocol">asyncio.protocols.BaseProtocol</a></dd>
<dd><a href="builtins.html#object">builtins.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="StreamReaderProtocol-__del__"><strong>__del__</strong></a>(self)</dt></dl>

<dl><dt><a name="StreamReaderProtocol-__init__"><strong>__init__</strong></a>(self, stream_reader, client_connected_cb=None, loop=None)</dt><dd><tt>Initialize&nbsp;self.&nbsp;&nbsp;See&nbsp;help(type(self))&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<dl><dt><a name="StreamReaderProtocol-connection_lost"><strong>connection_lost</strong></a>(self, exc)</dt><dd><tt>Called&nbsp;when&nbsp;the&nbsp;connection&nbsp;is&nbsp;lost&nbsp;or&nbsp;closed.<br>
&nbsp;<br>
The&nbsp;argument&nbsp;is&nbsp;an&nbsp;exception&nbsp;<a href="builtins.html#object">object</a>&nbsp;or&nbsp;None&nbsp;(the&nbsp;latter<br>
meaning&nbsp;a&nbsp;regular&nbsp;EOF&nbsp;is&nbsp;received&nbsp;or&nbsp;the&nbsp;connection&nbsp;was<br>
aborted&nbsp;or&nbsp;closed).</tt></dd></dl>

<dl><dt><a name="StreamReaderProtocol-connection_made"><strong>connection_made</strong></a>(self, transport)</dt><dd><tt>Called&nbsp;when&nbsp;a&nbsp;connection&nbsp;is&nbsp;made.<br>
&nbsp;<br>
The&nbsp;argument&nbsp;is&nbsp;the&nbsp;transport&nbsp;representing&nbsp;the&nbsp;pipe&nbsp;connection.<br>
To&nbsp;receive&nbsp;data,&nbsp;wait&nbsp;for&nbsp;<a href="#StreamReaderProtocol-data_received">data_received</a>()&nbsp;calls.<br>
When&nbsp;the&nbsp;connection&nbsp;is&nbsp;closed,&nbsp;<a href="#StreamReaderProtocol-connection_lost">connection_lost</a>()&nbsp;is&nbsp;called.</tt></dd></dl>

<dl><dt><a name="StreamReaderProtocol-data_received"><strong>data_received</strong></a>(self, data)</dt><dd><tt>Called&nbsp;when&nbsp;some&nbsp;data&nbsp;is&nbsp;received.<br>
&nbsp;<br>
The&nbsp;argument&nbsp;is&nbsp;a&nbsp;bytes&nbsp;<a href="builtins.html#object">object</a>.</tt></dd></dl>

<dl><dt><a name="StreamReaderProtocol-eof_received"><strong>eof_received</strong></a>(self)</dt><dd><tt>Called&nbsp;when&nbsp;the&nbsp;other&nbsp;end&nbsp;calls&nbsp;write_eof()&nbsp;or&nbsp;equivalent.<br>
&nbsp;<br>
If&nbsp;this&nbsp;returns&nbsp;a&nbsp;false&nbsp;value&nbsp;(including&nbsp;None),&nbsp;the&nbsp;transport<br>
will&nbsp;close&nbsp;itself.&nbsp;&nbsp;If&nbsp;it&nbsp;returns&nbsp;a&nbsp;true&nbsp;value,&nbsp;closing&nbsp;the<br>
transport&nbsp;is&nbsp;up&nbsp;to&nbsp;the&nbsp;protocol.</tt></dd></dl>

<hr>
Methods inherited from <a href="asyncio.streams.html#FlowControlMixin">FlowControlMixin</a>:<br>
<dl><dt><a name="StreamReaderProtocol-pause_writing"><strong>pause_writing</strong></a>(self)</dt><dd><tt>Called&nbsp;when&nbsp;the&nbsp;transport's&nbsp;buffer&nbsp;goes&nbsp;over&nbsp;the&nbsp;high-water&nbsp;mark.<br>
&nbsp;<br>
Pause&nbsp;and&nbsp;resume&nbsp;calls&nbsp;are&nbsp;paired&nbsp;--&nbsp;<a href="#StreamReaderProtocol-pause_writing">pause_writing</a>()&nbsp;is&nbsp;called<br>
once&nbsp;when&nbsp;the&nbsp;buffer&nbsp;goes&nbsp;strictly&nbsp;over&nbsp;the&nbsp;high-water&nbsp;mark<br>
(even&nbsp;if&nbsp;subsequent&nbsp;writes&nbsp;increases&nbsp;the&nbsp;buffer&nbsp;size&nbsp;even<br>
more),&nbsp;and&nbsp;eventually&nbsp;<a href="#StreamReaderProtocol-resume_writing">resume_writing</a>()&nbsp;is&nbsp;called&nbsp;once&nbsp;when&nbsp;the<br>
buffer&nbsp;size&nbsp;reaches&nbsp;the&nbsp;low-water&nbsp;mark.<br>
&nbsp;<br>
Note&nbsp;that&nbsp;if&nbsp;the&nbsp;buffer&nbsp;size&nbsp;equals&nbsp;the&nbsp;high-water&nbsp;mark,<br>
<a href="#StreamReaderProtocol-pause_writing">pause_writing</a>()&nbsp;is&nbsp;not&nbsp;called&nbsp;--&nbsp;it&nbsp;must&nbsp;go&nbsp;strictly&nbsp;over.<br>
Conversely,&nbsp;<a href="#StreamReaderProtocol-resume_writing">resume_writing</a>()&nbsp;is&nbsp;called&nbsp;when&nbsp;the&nbsp;buffer&nbsp;size&nbsp;is<br>
equal&nbsp;or&nbsp;lower&nbsp;than&nbsp;the&nbsp;low-water&nbsp;mark.&nbsp;&nbsp;These&nbsp;end&nbsp;conditions<br>
are&nbsp;important&nbsp;to&nbsp;ensure&nbsp;that&nbsp;things&nbsp;go&nbsp;as&nbsp;expected&nbsp;when&nbsp;either<br>
mark&nbsp;is&nbsp;zero.<br>
&nbsp;<br>
NOTE:&nbsp;This&nbsp;is&nbsp;the&nbsp;only&nbsp;<a href="#Protocol">Protocol</a>&nbsp;callback&nbsp;that&nbsp;is&nbsp;not&nbsp;called<br>
through&nbsp;EventLoop.call_soon()&nbsp;--&nbsp;if&nbsp;it&nbsp;were,&nbsp;it&nbsp;would&nbsp;have&nbsp;no<br>
effect&nbsp;when&nbsp;it's&nbsp;most&nbsp;needed&nbsp;(when&nbsp;the&nbsp;app&nbsp;keeps&nbsp;writing<br>
without&nbsp;yielding&nbsp;until&nbsp;<a href="#StreamReaderProtocol-pause_writing">pause_writing</a>()&nbsp;is&nbsp;called).</tt></dd></dl>

<dl><dt><a name="StreamReaderProtocol-resume_writing"><strong>resume_writing</strong></a>(self)</dt><dd><tt>Called&nbsp;when&nbsp;the&nbsp;transport's&nbsp;buffer&nbsp;drains&nbsp;below&nbsp;the&nbsp;low-water&nbsp;mark.<br>
&nbsp;<br>
See&nbsp;<a href="#StreamReaderProtocol-pause_writing">pause_writing</a>()&nbsp;for&nbsp;details.</tt></dd></dl>

<hr>
Data descriptors inherited from <a href="asyncio.streams.html#FlowControlMixin">FlowControlMixin</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="StreamWriter">class <strong>StreamWriter</strong></a>(<a href="builtins.html#object">builtins.object</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#StreamWriter">StreamWriter</a>(transport,&nbsp;protocol,&nbsp;reader,&nbsp;loop)<br>
&nbsp;<br>
Wraps&nbsp;a&nbsp;<a href="#Transport">Transport</a>.<br>
&nbsp;<br>
This&nbsp;exposes&nbsp;<a href="#StreamWriter-write">write</a>(),&nbsp;<a href="#StreamWriter-writelines">writelines</a>(),&nbsp;[can_]<a href="#StreamWriter-write_eof">write_eof</a>(),<br>
<a href="#StreamWriter-get_extra_info">get_extra_info</a>()&nbsp;and&nbsp;<a href="#StreamWriter-close">close</a>().&nbsp;&nbsp;It&nbsp;adds&nbsp;<a href="#StreamWriter-drain">drain</a>()&nbsp;which&nbsp;returns&nbsp;an<br>
optional&nbsp;<a href="#Future">Future</a>&nbsp;on&nbsp;which&nbsp;you&nbsp;can&nbsp;wait&nbsp;for&nbsp;flow&nbsp;control.&nbsp;&nbsp;It&nbsp;also<br>
adds&nbsp;a&nbsp;transport&nbsp;property&nbsp;which&nbsp;references&nbsp;the&nbsp;<a href="#Transport">Transport</a><br>
directly.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%">Methods defined here:<br>
<dl><dt><a name="StreamWriter-__init__"><strong>__init__</strong></a>(self, transport, protocol, reader, loop)</dt><dd><tt>Initialize&nbsp;self.&nbsp;&nbsp;See&nbsp;help(type(self))&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<dl><dt><a name="StreamWriter-__repr__"><strong>__repr__</strong></a>(self)</dt><dd><tt>Return&nbsp;repr(self).</tt></dd></dl>

<dl><dt><a name="StreamWriter-can_write_eof"><strong>can_write_eof</strong></a>(self)</dt></dl>

<dl><dt><a name="StreamWriter-close"><strong>close</strong></a>(self)</dt></dl>

<dl><dt>async <a name="StreamWriter-drain"><strong>drain</strong></a>(self)</dt><dd><tt>Flush&nbsp;the&nbsp;write&nbsp;buffer.<br>
&nbsp;<br>
The&nbsp;intended&nbsp;use&nbsp;is&nbsp;to&nbsp;write<br>
&nbsp;<br>
&nbsp;&nbsp;w.<a href="#StreamWriter-write">write</a>(data)<br>
&nbsp;&nbsp;await&nbsp;w.<a href="#StreamWriter-drain">drain</a>()</tt></dd></dl>

<dl><dt><a name="StreamWriter-get_extra_info"><strong>get_extra_info</strong></a>(self, name, default=None)</dt></dl>

<dl><dt><a name="StreamWriter-is_closing"><strong>is_closing</strong></a>(self)</dt></dl>

<dl><dt>async <a name="StreamWriter-wait_closed"><strong>wait_closed</strong></a>(self)</dt></dl>

<dl><dt><a name="StreamWriter-write"><strong>write</strong></a>(self, data)</dt></dl>

<dl><dt><a name="StreamWriter-write_eof"><strong>write_eof</strong></a>(self)</dt></dl>

<dl><dt><a name="StreamWriter-writelines"><strong>writelines</strong></a>(self, data)</dt></dl>

<hr>
Readonly properties defined here:<br>
<dl><dt><strong>transport</strong></dt>
</dl>
<hr>
Data descriptors defined here:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="SubprocessProtocol">class <strong>SubprocessProtocol</strong></a>(<a href="asyncio.protocols.html#BaseProtocol">BaseProtocol</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt>Interface&nbsp;for&nbsp;protocol&nbsp;for&nbsp;subprocess&nbsp;calls.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="asyncio.protocols.html#SubprocessProtocol">SubprocessProtocol</a></dd>
<dd><a href="asyncio.protocols.html#BaseProtocol">BaseProtocol</a></dd>
<dd><a href="builtins.html#object">builtins.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="SubprocessProtocol-pipe_connection_lost"><strong>pipe_connection_lost</strong></a>(self, fd, exc)</dt><dd><tt>Called&nbsp;when&nbsp;a&nbsp;file&nbsp;descriptor&nbsp;associated&nbsp;with&nbsp;the&nbsp;child&nbsp;process&nbsp;is<br>
closed.<br>
&nbsp;<br>
fd&nbsp;is&nbsp;the&nbsp;int&nbsp;file&nbsp;descriptor&nbsp;that&nbsp;was&nbsp;closed.</tt></dd></dl>

<dl><dt><a name="SubprocessProtocol-pipe_data_received"><strong>pipe_data_received</strong></a>(self, fd, data)</dt><dd><tt>Called&nbsp;when&nbsp;the&nbsp;subprocess&nbsp;writes&nbsp;data&nbsp;into&nbsp;stdout/stderr&nbsp;pipe.<br>
&nbsp;<br>
fd&nbsp;is&nbsp;int&nbsp;file&nbsp;descriptor.<br>
data&nbsp;is&nbsp;bytes&nbsp;<a href="builtins.html#object">object</a>.</tt></dd></dl>

<dl><dt><a name="SubprocessProtocol-process_exited"><strong>process_exited</strong></a>(self)</dt><dd><tt>Called&nbsp;when&nbsp;subprocess&nbsp;has&nbsp;exited.</tt></dd></dl>

<hr>
Methods inherited from <a href="asyncio.protocols.html#BaseProtocol">BaseProtocol</a>:<br>
<dl><dt><a name="SubprocessProtocol-connection_lost"><strong>connection_lost</strong></a>(self, exc)</dt><dd><tt>Called&nbsp;when&nbsp;the&nbsp;connection&nbsp;is&nbsp;lost&nbsp;or&nbsp;closed.<br>
&nbsp;<br>
The&nbsp;argument&nbsp;is&nbsp;an&nbsp;exception&nbsp;<a href="builtins.html#object">object</a>&nbsp;or&nbsp;None&nbsp;(the&nbsp;latter<br>
meaning&nbsp;a&nbsp;regular&nbsp;EOF&nbsp;is&nbsp;received&nbsp;or&nbsp;the&nbsp;connection&nbsp;was<br>
aborted&nbsp;or&nbsp;closed).</tt></dd></dl>

<dl><dt><a name="SubprocessProtocol-connection_made"><strong>connection_made</strong></a>(self, transport)</dt><dd><tt>Called&nbsp;when&nbsp;a&nbsp;connection&nbsp;is&nbsp;made.<br>
&nbsp;<br>
The&nbsp;argument&nbsp;is&nbsp;the&nbsp;transport&nbsp;representing&nbsp;the&nbsp;pipe&nbsp;connection.<br>
To&nbsp;receive&nbsp;data,&nbsp;wait&nbsp;for&nbsp;data_received()&nbsp;calls.<br>
When&nbsp;the&nbsp;connection&nbsp;is&nbsp;closed,&nbsp;<a href="#SubprocessProtocol-connection_lost">connection_lost</a>()&nbsp;is&nbsp;called.</tt></dd></dl>

<dl><dt><a name="SubprocessProtocol-pause_writing"><strong>pause_writing</strong></a>(self)</dt><dd><tt>Called&nbsp;when&nbsp;the&nbsp;transport's&nbsp;buffer&nbsp;goes&nbsp;over&nbsp;the&nbsp;high-water&nbsp;mark.<br>
&nbsp;<br>
Pause&nbsp;and&nbsp;resume&nbsp;calls&nbsp;are&nbsp;paired&nbsp;--&nbsp;<a href="#SubprocessProtocol-pause_writing">pause_writing</a>()&nbsp;is&nbsp;called<br>
once&nbsp;when&nbsp;the&nbsp;buffer&nbsp;goes&nbsp;strictly&nbsp;over&nbsp;the&nbsp;high-water&nbsp;mark<br>
(even&nbsp;if&nbsp;subsequent&nbsp;writes&nbsp;increases&nbsp;the&nbsp;buffer&nbsp;size&nbsp;even<br>
more),&nbsp;and&nbsp;eventually&nbsp;<a href="#SubprocessProtocol-resume_writing">resume_writing</a>()&nbsp;is&nbsp;called&nbsp;once&nbsp;when&nbsp;the<br>
buffer&nbsp;size&nbsp;reaches&nbsp;the&nbsp;low-water&nbsp;mark.<br>
&nbsp;<br>
Note&nbsp;that&nbsp;if&nbsp;the&nbsp;buffer&nbsp;size&nbsp;equals&nbsp;the&nbsp;high-water&nbsp;mark,<br>
<a href="#SubprocessProtocol-pause_writing">pause_writing</a>()&nbsp;is&nbsp;not&nbsp;called&nbsp;--&nbsp;it&nbsp;must&nbsp;go&nbsp;strictly&nbsp;over.<br>
Conversely,&nbsp;<a href="#SubprocessProtocol-resume_writing">resume_writing</a>()&nbsp;is&nbsp;called&nbsp;when&nbsp;the&nbsp;buffer&nbsp;size&nbsp;is<br>
equal&nbsp;or&nbsp;lower&nbsp;than&nbsp;the&nbsp;low-water&nbsp;mark.&nbsp;&nbsp;These&nbsp;end&nbsp;conditions<br>
are&nbsp;important&nbsp;to&nbsp;ensure&nbsp;that&nbsp;things&nbsp;go&nbsp;as&nbsp;expected&nbsp;when&nbsp;either<br>
mark&nbsp;is&nbsp;zero.<br>
&nbsp;<br>
NOTE:&nbsp;This&nbsp;is&nbsp;the&nbsp;only&nbsp;<a href="#Protocol">Protocol</a>&nbsp;callback&nbsp;that&nbsp;is&nbsp;not&nbsp;called<br>
through&nbsp;EventLoop.call_soon()&nbsp;--&nbsp;if&nbsp;it&nbsp;were,&nbsp;it&nbsp;would&nbsp;have&nbsp;no<br>
effect&nbsp;when&nbsp;it's&nbsp;most&nbsp;needed&nbsp;(when&nbsp;the&nbsp;app&nbsp;keeps&nbsp;writing<br>
without&nbsp;yielding&nbsp;until&nbsp;<a href="#SubprocessProtocol-pause_writing">pause_writing</a>()&nbsp;is&nbsp;called).</tt></dd></dl>

<dl><dt><a name="SubprocessProtocol-resume_writing"><strong>resume_writing</strong></a>(self)</dt><dd><tt>Called&nbsp;when&nbsp;the&nbsp;transport's&nbsp;buffer&nbsp;drains&nbsp;below&nbsp;the&nbsp;low-water&nbsp;mark.<br>
&nbsp;<br>
See&nbsp;<a href="#SubprocessProtocol-pause_writing">pause_writing</a>()&nbsp;for&nbsp;details.</tt></dd></dl>

</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="SubprocessTransport">class <strong>SubprocessTransport</strong></a>(<a href="asyncio.transports.html#BaseTransport">BaseTransport</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#SubprocessTransport">SubprocessTransport</a>(extra=None)<br>
&nbsp;<br>
Base&nbsp;class&nbsp;for&nbsp;transports.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="asyncio.transports.html#SubprocessTransport">SubprocessTransport</a></dd>
<dd><a href="asyncio.transports.html#BaseTransport">BaseTransport</a></dd>
<dd><a href="builtins.html#object">builtins.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="SubprocessTransport-get_pid"><strong>get_pid</strong></a>(self)</dt><dd><tt>Get&nbsp;subprocess&nbsp;id.</tt></dd></dl>

<dl><dt><a name="SubprocessTransport-get_pipe_transport"><strong>get_pipe_transport</strong></a>(self, fd)</dt><dd><tt>Get&nbsp;transport&nbsp;for&nbsp;pipe&nbsp;with&nbsp;number&nbsp;fd.</tt></dd></dl>

<dl><dt><a name="SubprocessTransport-get_returncode"><strong>get_returncode</strong></a>(self)</dt><dd><tt>Get&nbsp;subprocess&nbsp;returncode.<br>
&nbsp;<br>
See&nbsp;also<br>
<a href="http://docs.python.org/3/library/subprocess#subprocess.Popen.returncode">http://docs.python.org/3/library/subprocess#subprocess.Popen.returncode</a></tt></dd></dl>

<dl><dt><a name="SubprocessTransport-kill"><strong>kill</strong></a>(self)</dt><dd><tt>Kill&nbsp;the&nbsp;subprocess.<br>
&nbsp;<br>
On&nbsp;Posix&nbsp;OSs&nbsp;the&nbsp;function&nbsp;sends&nbsp;SIGKILL&nbsp;to&nbsp;the&nbsp;subprocess.<br>
On&nbsp;Windows&nbsp;<a href="#SubprocessTransport-kill">kill</a>()&nbsp;is&nbsp;an&nbsp;alias&nbsp;for&nbsp;<a href="#SubprocessTransport-terminate">terminate</a>().<br>
&nbsp;<br>
See&nbsp;also:<br>
<a href="http://docs.python.org/3/library/subprocess#subprocess.Popen.kill">http://docs.python.org/3/library/subprocess#subprocess.Popen.kill</a></tt></dd></dl>

<dl><dt><a name="SubprocessTransport-send_signal"><strong>send_signal</strong></a>(self, signal)</dt><dd><tt>Send&nbsp;signal&nbsp;to&nbsp;subprocess.<br>
&nbsp;<br>
See&nbsp;also:<br>
docs.python.org/3/library/subprocess#subprocess.Popen.send_signal</tt></dd></dl>

<dl><dt><a name="SubprocessTransport-terminate"><strong>terminate</strong></a>(self)</dt><dd><tt>Stop&nbsp;the&nbsp;subprocess.<br>
&nbsp;<br>
Alias&nbsp;for&nbsp;<a href="#SubprocessTransport-close">close</a>()&nbsp;method.<br>
&nbsp;<br>
On&nbsp;Posix&nbsp;OSs&nbsp;the&nbsp;method&nbsp;sends&nbsp;SIGTERM&nbsp;to&nbsp;the&nbsp;subprocess.<br>
On&nbsp;Windows&nbsp;the&nbsp;Win32&nbsp;API&nbsp;function&nbsp;TerminateProcess()<br>
&nbsp;is&nbsp;called&nbsp;to&nbsp;stop&nbsp;the&nbsp;subprocess.<br>
&nbsp;<br>
See&nbsp;also:<br>
<a href="http://docs.python.org/3/library/subprocess#subprocess.Popen.terminate">http://docs.python.org/3/library/subprocess#subprocess.Popen.terminate</a></tt></dd></dl>

<hr>
Methods inherited from <a href="asyncio.transports.html#BaseTransport">BaseTransport</a>:<br>
<dl><dt><a name="SubprocessTransport-__init__"><strong>__init__</strong></a>(self, extra=None)</dt><dd><tt>Initialize&nbsp;self.&nbsp;&nbsp;See&nbsp;help(type(self))&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<dl><dt><a name="SubprocessTransport-close"><strong>close</strong></a>(self)</dt><dd><tt>Close&nbsp;the&nbsp;transport.<br>
&nbsp;<br>
Buffered&nbsp;data&nbsp;will&nbsp;be&nbsp;flushed&nbsp;asynchronously.&nbsp;&nbsp;No&nbsp;more&nbsp;data<br>
will&nbsp;be&nbsp;received.&nbsp;&nbsp;After&nbsp;all&nbsp;buffered&nbsp;data&nbsp;is&nbsp;flushed,&nbsp;the<br>
protocol's&nbsp;connection_lost()&nbsp;method&nbsp;will&nbsp;(eventually)&nbsp;be<br>
called&nbsp;with&nbsp;None&nbsp;as&nbsp;its&nbsp;argument.</tt></dd></dl>

<dl><dt><a name="SubprocessTransport-get_extra_info"><strong>get_extra_info</strong></a>(self, name, default=None)</dt><dd><tt>Get&nbsp;optional&nbsp;transport&nbsp;information.</tt></dd></dl>

<dl><dt><a name="SubprocessTransport-get_protocol"><strong>get_protocol</strong></a>(self)</dt><dd><tt>Return&nbsp;the&nbsp;current&nbsp;protocol.</tt></dd></dl>

<dl><dt><a name="SubprocessTransport-is_closing"><strong>is_closing</strong></a>(self)</dt><dd><tt>Return&nbsp;True&nbsp;if&nbsp;the&nbsp;transport&nbsp;is&nbsp;closing&nbsp;or&nbsp;closed.</tt></dd></dl>

<dl><dt><a name="SubprocessTransport-set_protocol"><strong>set_protocol</strong></a>(self, protocol)</dt><dd><tt>Set&nbsp;a&nbsp;new&nbsp;protocol.</tt></dd></dl>

</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="Task">class <strong>Task</strong></a>(<a href="_asyncio.html#Future">Future</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#Task">Task</a>(coro,&nbsp;*,&nbsp;loop=None,&nbsp;name=None)<br>
&nbsp;<br>
A&nbsp;coroutine&nbsp;wrapped&nbsp;in&nbsp;a&nbsp;<a href="#Future">Future</a>.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="_asyncio.html#Task">Task</a></dd>
<dd><a href="_asyncio.html#Future">Future</a></dd>
<dd><a href="builtins.html#object">builtins.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="Task-__await__"><strong>__await__</strong></a>(self, /)</dt><dd><tt>Return&nbsp;an&nbsp;iterator&nbsp;to&nbsp;be&nbsp;used&nbsp;in&nbsp;await&nbsp;expression.</tt></dd></dl>

<dl><dt><a name="Task-__del__"><strong>__del__</strong></a>(...)</dt></dl>

<dl><dt><a name="Task-__init__"><strong>__init__</strong></a>(self, /, *args, **kwargs)</dt><dd><tt>Initialize&nbsp;self.&nbsp;&nbsp;See&nbsp;help(type(self))&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<dl><dt><a name="Task-__iter__"><strong>__iter__</strong></a>(self, /)</dt><dd><tt>Implement&nbsp;iter(self).</tt></dd></dl>

<dl><dt><a name="Task-__repr__"><strong>__repr__</strong></a>(self, /)</dt><dd><tt>Return&nbsp;repr(self).</tt></dd></dl>

<dl><dt><a name="Task-add_done_callback"><strong>add_done_callback</strong></a>(...)</dt><dd><tt>Add&nbsp;a&nbsp;callback&nbsp;to&nbsp;be&nbsp;run&nbsp;when&nbsp;the&nbsp;future&nbsp;becomes&nbsp;done.<br>
&nbsp;<br>
The&nbsp;callback&nbsp;is&nbsp;called&nbsp;with&nbsp;a&nbsp;single&nbsp;argument&nbsp;-&nbsp;the&nbsp;future&nbsp;<a href="builtins.html#object">object</a>.&nbsp;If<br>
the&nbsp;future&nbsp;is&nbsp;already&nbsp;done&nbsp;when&nbsp;this&nbsp;is&nbsp;called,&nbsp;the&nbsp;callback&nbsp;is<br>
scheduled&nbsp;with&nbsp;call_soon.</tt></dd></dl>

<dl><dt><a name="Task-cancel"><strong>cancel</strong></a>(self, /)</dt><dd><tt>Request&nbsp;that&nbsp;this&nbsp;task&nbsp;cancel&nbsp;itself.<br>
&nbsp;<br>
This&nbsp;arranges&nbsp;for&nbsp;a&nbsp;<a href="#CancelledError">CancelledError</a>&nbsp;to&nbsp;be&nbsp;thrown&nbsp;into&nbsp;the<br>
wrapped&nbsp;coroutine&nbsp;on&nbsp;the&nbsp;next&nbsp;cycle&nbsp;through&nbsp;the&nbsp;event&nbsp;loop.<br>
The&nbsp;coroutine&nbsp;then&nbsp;has&nbsp;a&nbsp;chance&nbsp;to&nbsp;clean&nbsp;up&nbsp;or&nbsp;even&nbsp;deny<br>
the&nbsp;request&nbsp;using&nbsp;try/except/finally.<br>
&nbsp;<br>
Unlike&nbsp;<a href="#Future">Future</a>.cancel,&nbsp;this&nbsp;does&nbsp;not&nbsp;guarantee&nbsp;that&nbsp;the<br>
task&nbsp;will&nbsp;be&nbsp;cancelled:&nbsp;the&nbsp;exception&nbsp;might&nbsp;be&nbsp;caught&nbsp;and<br>
acted&nbsp;upon,&nbsp;delaying&nbsp;cancellation&nbsp;of&nbsp;the&nbsp;task&nbsp;or&nbsp;preventing<br>
cancellation&nbsp;completely.&nbsp;&nbsp;The&nbsp;task&nbsp;may&nbsp;also&nbsp;return&nbsp;a&nbsp;value&nbsp;or<br>
raise&nbsp;a&nbsp;different&nbsp;exception.<br>
&nbsp;<br>
Immediately&nbsp;after&nbsp;this&nbsp;method&nbsp;is&nbsp;called,&nbsp;<a href="#Task">Task</a>.<a href="#Task-cancelled">cancelled</a>()&nbsp;will<br>
not&nbsp;return&nbsp;True&nbsp;(unless&nbsp;the&nbsp;task&nbsp;was&nbsp;already&nbsp;cancelled).&nbsp;&nbsp;A<br>
task&nbsp;will&nbsp;be&nbsp;marked&nbsp;as&nbsp;cancelled&nbsp;when&nbsp;the&nbsp;wrapped&nbsp;coroutine<br>
terminates&nbsp;with&nbsp;a&nbsp;<a href="#CancelledError">CancelledError</a>&nbsp;exception&nbsp;(even&nbsp;if&nbsp;<a href="#Task-cancel">cancel</a>()<br>
was&nbsp;not&nbsp;called).</tt></dd></dl>

<dl><dt><a name="Task-cancelled"><strong>cancelled</strong></a>(self, /)</dt><dd><tt>Return&nbsp;True&nbsp;if&nbsp;the&nbsp;future&nbsp;was&nbsp;cancelled.</tt></dd></dl>

<dl><dt><a name="Task-done"><strong>done</strong></a>(self, /)</dt><dd><tt>Return&nbsp;True&nbsp;if&nbsp;the&nbsp;future&nbsp;is&nbsp;done.<br>
&nbsp;<br>
Done&nbsp;means&nbsp;either&nbsp;that&nbsp;a&nbsp;result&nbsp;/&nbsp;exception&nbsp;are&nbsp;available,&nbsp;or&nbsp;that&nbsp;the<br>
future&nbsp;was&nbsp;cancelled.</tt></dd></dl>

<dl><dt><a name="Task-exception"><strong>exception</strong></a>(self, /)</dt><dd><tt>Return&nbsp;the&nbsp;exception&nbsp;that&nbsp;was&nbsp;set&nbsp;on&nbsp;this&nbsp;future.<br>
&nbsp;<br>
The&nbsp;exception&nbsp;(or&nbsp;None&nbsp;if&nbsp;no&nbsp;exception&nbsp;was&nbsp;set)&nbsp;is&nbsp;returned&nbsp;only&nbsp;if<br>
the&nbsp;future&nbsp;is&nbsp;done.&nbsp;&nbsp;If&nbsp;the&nbsp;future&nbsp;has&nbsp;been&nbsp;cancelled,&nbsp;raises<br>
<a href="#CancelledError">CancelledError</a>.&nbsp;&nbsp;If&nbsp;the&nbsp;future&nbsp;isn't&nbsp;done&nbsp;yet,&nbsp;raises<br>
<a href="#InvalidStateError">InvalidStateError</a>.</tt></dd></dl>

<dl><dt><a name="Task-get_coro"><strong>get_coro</strong></a>(self, /)</dt></dl>

<dl><dt><a name="Task-get_name"><strong>get_name</strong></a>(self, /)</dt></dl>

<dl><dt><a name="Task-get_stack"><strong>get_stack</strong></a>(self, /, *, limit=None)</dt><dd><tt>Return&nbsp;the&nbsp;list&nbsp;of&nbsp;stack&nbsp;frames&nbsp;for&nbsp;this&nbsp;task's&nbsp;coroutine.<br>
&nbsp;<br>
If&nbsp;the&nbsp;coroutine&nbsp;is&nbsp;not&nbsp;done,&nbsp;this&nbsp;returns&nbsp;the&nbsp;stack&nbsp;where&nbsp;it&nbsp;is<br>
suspended.&nbsp;&nbsp;If&nbsp;the&nbsp;coroutine&nbsp;has&nbsp;completed&nbsp;successfully&nbsp;or&nbsp;was<br>
cancelled,&nbsp;this&nbsp;returns&nbsp;an&nbsp;empty&nbsp;list.&nbsp;&nbsp;If&nbsp;the&nbsp;coroutine&nbsp;was<br>
terminated&nbsp;by&nbsp;an&nbsp;exception,&nbsp;this&nbsp;returns&nbsp;the&nbsp;list&nbsp;of&nbsp;traceback<br>
frames.<br>
&nbsp;<br>
The&nbsp;frames&nbsp;are&nbsp;always&nbsp;ordered&nbsp;from&nbsp;oldest&nbsp;to&nbsp;newest.<br>
&nbsp;<br>
The&nbsp;optional&nbsp;limit&nbsp;gives&nbsp;the&nbsp;maximum&nbsp;number&nbsp;of&nbsp;frames&nbsp;to<br>
return;&nbsp;by&nbsp;default&nbsp;all&nbsp;available&nbsp;frames&nbsp;are&nbsp;returned.&nbsp;&nbsp;Its<br>
meaning&nbsp;differs&nbsp;depending&nbsp;on&nbsp;whether&nbsp;a&nbsp;stack&nbsp;or&nbsp;a&nbsp;traceback&nbsp;is<br>
returned:&nbsp;the&nbsp;newest&nbsp;frames&nbsp;of&nbsp;a&nbsp;stack&nbsp;are&nbsp;returned,&nbsp;but&nbsp;the<br>
oldest&nbsp;frames&nbsp;of&nbsp;a&nbsp;traceback&nbsp;are&nbsp;returned.&nbsp;&nbsp;(This&nbsp;matches&nbsp;the<br>
behavior&nbsp;of&nbsp;the&nbsp;traceback&nbsp;module.)<br>
&nbsp;<br>
For&nbsp;reasons&nbsp;beyond&nbsp;our&nbsp;control,&nbsp;only&nbsp;one&nbsp;stack&nbsp;frame&nbsp;is<br>
returned&nbsp;for&nbsp;a&nbsp;suspended&nbsp;coroutine.</tt></dd></dl>

<dl><dt><a name="Task-print_stack"><strong>print_stack</strong></a>(self, /, *, limit=None, file=None)</dt><dd><tt>Print&nbsp;the&nbsp;stack&nbsp;or&nbsp;traceback&nbsp;for&nbsp;this&nbsp;task's&nbsp;coroutine.<br>
&nbsp;<br>
This&nbsp;produces&nbsp;output&nbsp;similar&nbsp;to&nbsp;that&nbsp;of&nbsp;the&nbsp;traceback&nbsp;module,<br>
for&nbsp;the&nbsp;frames&nbsp;retrieved&nbsp;by&nbsp;<a href="#Task-get_stack">get_stack</a>().&nbsp;&nbsp;The&nbsp;limit&nbsp;argument<br>
is&nbsp;passed&nbsp;to&nbsp;<a href="#Task-get_stack">get_stack</a>().&nbsp;&nbsp;The&nbsp;file&nbsp;argument&nbsp;is&nbsp;an&nbsp;I/O&nbsp;stream<br>
to&nbsp;which&nbsp;the&nbsp;output&nbsp;is&nbsp;written;&nbsp;by&nbsp;default&nbsp;output&nbsp;is&nbsp;written<br>
to&nbsp;sys.stderr.</tt></dd></dl>

<dl><dt><a name="Task-remove_done_callback"><strong>remove_done_callback</strong></a>(self, fn, /)</dt><dd><tt>Remove&nbsp;all&nbsp;instances&nbsp;of&nbsp;a&nbsp;callback&nbsp;from&nbsp;the&nbsp;"call&nbsp;when&nbsp;done"&nbsp;list.<br>
&nbsp;<br>
Returns&nbsp;the&nbsp;number&nbsp;of&nbsp;callbacks&nbsp;removed.</tt></dd></dl>

<dl><dt><a name="Task-result"><strong>result</strong></a>(self, /)</dt><dd><tt>Return&nbsp;the&nbsp;result&nbsp;this&nbsp;future&nbsp;represents.<br>
&nbsp;<br>
If&nbsp;the&nbsp;future&nbsp;has&nbsp;been&nbsp;cancelled,&nbsp;raises&nbsp;<a href="#CancelledError">CancelledError</a>.&nbsp;&nbsp;If&nbsp;the<br>
future's&nbsp;result&nbsp;isn't&nbsp;yet&nbsp;available,&nbsp;raises&nbsp;<a href="#InvalidStateError">InvalidStateError</a>.&nbsp;&nbsp;If<br>
the&nbsp;future&nbsp;is&nbsp;done&nbsp;and&nbsp;has&nbsp;an&nbsp;exception&nbsp;set,&nbsp;this&nbsp;exception&nbsp;is&nbsp;raised.</tt></dd></dl>

<dl><dt><a name="Task-set_exception"><strong>set_exception</strong></a>(self, exception, /)</dt><dd><tt>Mark&nbsp;the&nbsp;future&nbsp;done&nbsp;and&nbsp;set&nbsp;an&nbsp;exception.<br>
&nbsp;<br>
If&nbsp;the&nbsp;future&nbsp;is&nbsp;already&nbsp;done&nbsp;when&nbsp;this&nbsp;method&nbsp;is&nbsp;called,&nbsp;raises<br>
<a href="#InvalidStateError">InvalidStateError</a>.</tt></dd></dl>

<dl><dt><a name="Task-set_name"><strong>set_name</strong></a>(self, value, /)</dt></dl>

<dl><dt><a name="Task-set_result"><strong>set_result</strong></a>(self, result, /)</dt><dd><tt>Mark&nbsp;the&nbsp;future&nbsp;done&nbsp;and&nbsp;set&nbsp;its&nbsp;result.<br>
&nbsp;<br>
If&nbsp;the&nbsp;future&nbsp;is&nbsp;already&nbsp;done&nbsp;when&nbsp;this&nbsp;method&nbsp;is&nbsp;called,&nbsp;raises<br>
<a href="#InvalidStateError">InvalidStateError</a>.</tt></dd></dl>

<hr>
Class methods defined here:<br>
<dl><dt><a name="Task-all_tasks"><strong>all_tasks</strong></a>(loop=None)<font color="#909090"><font face="helvetica, arial"> from <a href="builtins.html#type">builtins.type</a></font></font></dt><dd><tt>Return&nbsp;a&nbsp;set&nbsp;of&nbsp;all&nbsp;tasks&nbsp;for&nbsp;an&nbsp;event&nbsp;loop.<br>
&nbsp;<br>
By&nbsp;default&nbsp;all&nbsp;tasks&nbsp;for&nbsp;the&nbsp;current&nbsp;event&nbsp;loop&nbsp;are&nbsp;returned.</tt></dd></dl>

<dl><dt><a name="Task-current_task"><strong>current_task</strong></a>(loop=None)<font color="#909090"><font face="helvetica, arial"> from <a href="builtins.html#type">builtins.type</a></font></font></dt><dd><tt>Return&nbsp;the&nbsp;currently&nbsp;running&nbsp;task&nbsp;in&nbsp;an&nbsp;event&nbsp;loop&nbsp;or&nbsp;None.<br>
&nbsp;<br>
By&nbsp;default&nbsp;the&nbsp;current&nbsp;task&nbsp;for&nbsp;the&nbsp;current&nbsp;event&nbsp;loop&nbsp;is&nbsp;returned.<br>
&nbsp;<br>
None&nbsp;is&nbsp;returned&nbsp;when&nbsp;called&nbsp;not&nbsp;in&nbsp;the&nbsp;context&nbsp;of&nbsp;a&nbsp;<a href="#Task">Task</a>.</tt></dd></dl>

<hr>
Static methods defined here:<br>
<dl><dt><a name="Task-__new__"><strong>__new__</strong></a>(*args, **kwargs)<font color="#909090"><font face="helvetica, arial"> from <a href="builtins.html#type">builtins.type</a></font></font></dt><dd><tt>Create&nbsp;and&nbsp;return&nbsp;a&nbsp;new&nbsp;<a href="builtins.html#object">object</a>.&nbsp;&nbsp;See&nbsp;help(type)&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<hr>
Methods inherited from <a href="_asyncio.html#Future">Future</a>:<br>
<dl><dt><a name="Task-get_loop"><strong>get_loop</strong></a>(self, /)</dt><dd><tt>Return&nbsp;the&nbsp;event&nbsp;loop&nbsp;the&nbsp;<a href="#Future">Future</a>&nbsp;is&nbsp;bound&nbsp;to.</tt></dd></dl>

</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="TimeoutError">class <strong>TimeoutError</strong></a>(<a href="builtins.html#Exception">builtins.Exception</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt>The&nbsp;operation&nbsp;exceeded&nbsp;the&nbsp;given&nbsp;deadline.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="asyncio.exceptions.html#TimeoutError">TimeoutError</a></dd>
<dd><a href="builtins.html#Exception">builtins.Exception</a></dd>
<dd><a href="builtins.html#BaseException">builtins.BaseException</a></dd>
<dd><a href="builtins.html#object">builtins.object</a></dd>
</dl>
<hr>
Data descriptors defined here:<br>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<hr>
Methods inherited from <a href="builtins.html#Exception">builtins.Exception</a>:<br>
<dl><dt><a name="TimeoutError-__init__"><strong>__init__</strong></a>(self, /, *args, **kwargs)</dt><dd><tt>Initialize&nbsp;self.&nbsp;&nbsp;See&nbsp;help(type(self))&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<hr>
Static methods inherited from <a href="builtins.html#Exception">builtins.Exception</a>:<br>
<dl><dt><a name="TimeoutError-__new__"><strong>__new__</strong></a>(*args, **kwargs)<font color="#909090"><font face="helvetica, arial"> from <a href="builtins.html#type">builtins.type</a></font></font></dt><dd><tt>Create&nbsp;and&nbsp;return&nbsp;a&nbsp;new&nbsp;<a href="builtins.html#object">object</a>.&nbsp;&nbsp;See&nbsp;help(type)&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<hr>
Methods inherited from <a href="builtins.html#BaseException">builtins.BaseException</a>:<br>
<dl><dt><a name="TimeoutError-__delattr__"><strong>__delattr__</strong></a>(self, name, /)</dt><dd><tt>Implement&nbsp;delattr(self,&nbsp;name).</tt></dd></dl>

<dl><dt><a name="TimeoutError-__getattribute__"><strong>__getattribute__</strong></a>(self, name, /)</dt><dd><tt>Return&nbsp;getattr(self,&nbsp;name).</tt></dd></dl>

<dl><dt><a name="TimeoutError-__reduce__"><strong>__reduce__</strong></a>(...)</dt><dd><tt>Helper&nbsp;for&nbsp;pickle.</tt></dd></dl>

<dl><dt><a name="TimeoutError-__repr__"><strong>__repr__</strong></a>(self, /)</dt><dd><tt>Return&nbsp;repr(self).</tt></dd></dl>

<dl><dt><a name="TimeoutError-__setattr__"><strong>__setattr__</strong></a>(self, name, value, /)</dt><dd><tt>Implement&nbsp;setattr(self,&nbsp;name,&nbsp;value).</tt></dd></dl>

<dl><dt><a name="TimeoutError-__setstate__"><strong>__setstate__</strong></a>(...)</dt></dl>

<dl><dt><a name="TimeoutError-__str__"><strong>__str__</strong></a>(self, /)</dt><dd><tt>Return&nbsp;str(self).</tt></dd></dl>

<dl><dt><a name="TimeoutError-with_traceback"><strong>with_traceback</strong></a>(...)</dt><dd><tt><a href="builtins.html#Exception">Exception</a>.<a href="#TimeoutError-with_traceback">with_traceback</a>(tb)&nbsp;--<br>
set&nbsp;self.<strong>__traceback__</strong>&nbsp;to&nbsp;tb&nbsp;and&nbsp;return&nbsp;self.</tt></dd></dl>

<hr>
Data descriptors inherited from <a href="builtins.html#BaseException">builtins.BaseException</a>:<br>
<dl><dt><strong>__cause__</strong></dt>
<dd><tt>exception&nbsp;cause</tt></dd>
</dl>
<dl><dt><strong>__context__</strong></dt>
<dd><tt>exception&nbsp;context</tt></dd>
</dl>
<dl><dt><strong>__dict__</strong></dt>
</dl>
<dl><dt><strong>__suppress_context__</strong></dt>
</dl>
<dl><dt><strong>__traceback__</strong></dt>
</dl>
<dl><dt><strong>args</strong></dt>
</dl>
</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="TimerHandle">class <strong>TimerHandle</strong></a>(<a href="asyncio.events.html#Handle">Handle</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#TimerHandle">TimerHandle</a>(when,&nbsp;callback,&nbsp;args,&nbsp;loop,&nbsp;context=None)<br>
&nbsp;<br>
Object&nbsp;returned&nbsp;by&nbsp;timed&nbsp;callback&nbsp;registration&nbsp;methods.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="asyncio.events.html#TimerHandle">TimerHandle</a></dd>
<dd><a href="asyncio.events.html#Handle">Handle</a></dd>
<dd><a href="builtins.html#object">builtins.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="TimerHandle-__eq__"><strong>__eq__</strong></a>(self, other)</dt><dd><tt>Return&nbsp;self==value.</tt></dd></dl>

<dl><dt><a name="TimerHandle-__ge__"><strong>__ge__</strong></a>(self, other)</dt><dd><tt>Return&nbsp;self&gt;=value.</tt></dd></dl>

<dl><dt><a name="TimerHandle-__gt__"><strong>__gt__</strong></a>(self, other)</dt><dd><tt>Return&nbsp;self&gt;value.</tt></dd></dl>

<dl><dt><a name="TimerHandle-__hash__"><strong>__hash__</strong></a>(self)</dt><dd><tt>Return&nbsp;hash(self).</tt></dd></dl>

<dl><dt><a name="TimerHandle-__init__"><strong>__init__</strong></a>(self, when, callback, args, loop, context=None)</dt><dd><tt>Initialize&nbsp;self.&nbsp;&nbsp;See&nbsp;help(type(self))&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<dl><dt><a name="TimerHandle-__le__"><strong>__le__</strong></a>(self, other)</dt><dd><tt>Return&nbsp;self&lt;=value.</tt></dd></dl>

<dl><dt><a name="TimerHandle-__lt__"><strong>__lt__</strong></a>(self, other)</dt><dd><tt>Return&nbsp;self&lt;value.</tt></dd></dl>

<dl><dt><a name="TimerHandle-__ne__"><strong>__ne__</strong></a>(self, other)</dt><dd><tt>Return&nbsp;self!=value.</tt></dd></dl>

<dl><dt><a name="TimerHandle-cancel"><strong>cancel</strong></a>(self)</dt></dl>

<dl><dt><a name="TimerHandle-when"><strong>when</strong></a>(self)</dt><dd><tt>Return&nbsp;a&nbsp;scheduled&nbsp;callback&nbsp;time.<br>
&nbsp;<br>
The&nbsp;time&nbsp;is&nbsp;an&nbsp;absolute&nbsp;timestamp,&nbsp;using&nbsp;the&nbsp;same&nbsp;time<br>
reference&nbsp;as&nbsp;loop.time().</tt></dd></dl>

<hr>
Methods inherited from <a href="asyncio.events.html#Handle">Handle</a>:<br>
<dl><dt><a name="TimerHandle-__repr__"><strong>__repr__</strong></a>(self)</dt><dd><tt>Return&nbsp;repr(self).</tt></dd></dl>

<dl><dt><a name="TimerHandle-cancelled"><strong>cancelled</strong></a>(self)</dt></dl>

<hr>
Data descriptors inherited from <a href="asyncio.events.html#Handle">Handle</a>:<br>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="Transport">class <strong>Transport</strong></a>(<a href="asyncio.transports.html#ReadTransport">ReadTransport</a>, <a href="asyncio.transports.html#WriteTransport">WriteTransport</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#Transport">Transport</a>(extra=None)<br>
&nbsp;<br>
Interface&nbsp;representing&nbsp;a&nbsp;bidirectional&nbsp;transport.<br>
&nbsp;<br>
There&nbsp;may&nbsp;be&nbsp;several&nbsp;implementations,&nbsp;but&nbsp;typically,&nbsp;the&nbsp;user&nbsp;does<br>
not&nbsp;implement&nbsp;new&nbsp;transports;&nbsp;rather,&nbsp;the&nbsp;platform&nbsp;provides&nbsp;some<br>
useful&nbsp;transports&nbsp;that&nbsp;are&nbsp;implemented&nbsp;using&nbsp;the&nbsp;platform's&nbsp;best<br>
practices.<br>
&nbsp;<br>
The&nbsp;user&nbsp;never&nbsp;instantiates&nbsp;a&nbsp;transport&nbsp;directly;&nbsp;they&nbsp;call&nbsp;a<br>
utility&nbsp;function,&nbsp;passing&nbsp;it&nbsp;a&nbsp;protocol&nbsp;factory&nbsp;and&nbsp;other<br>
information&nbsp;necessary&nbsp;to&nbsp;create&nbsp;the&nbsp;transport&nbsp;and&nbsp;protocol.&nbsp;&nbsp;(E.g.<br>
EventLoop.create_connection()&nbsp;or&nbsp;EventLoop.create_server().)<br>
&nbsp;<br>
The&nbsp;utility&nbsp;function&nbsp;will&nbsp;asynchronously&nbsp;create&nbsp;a&nbsp;transport&nbsp;and&nbsp;a<br>
protocol&nbsp;and&nbsp;hook&nbsp;them&nbsp;up&nbsp;by&nbsp;calling&nbsp;the&nbsp;protocol's<br>
connection_made()&nbsp;method,&nbsp;passing&nbsp;it&nbsp;the&nbsp;transport.<br>
&nbsp;<br>
The&nbsp;implementation&nbsp;here&nbsp;raises&nbsp;NotImplemented&nbsp;for&nbsp;every&nbsp;method<br>
except&nbsp;<a href="#Transport-writelines">writelines</a>(),&nbsp;which&nbsp;calls&nbsp;<a href="#Transport-write">write</a>()&nbsp;in&nbsp;a&nbsp;loop.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="asyncio.transports.html#Transport">Transport</a></dd>
<dd><a href="asyncio.transports.html#ReadTransport">ReadTransport</a></dd>
<dd><a href="asyncio.transports.html#WriteTransport">WriteTransport</a></dd>
<dd><a href="asyncio.transports.html#BaseTransport">BaseTransport</a></dd>
<dd><a href="builtins.html#object">builtins.object</a></dd>
</dl>
<hr>
Methods inherited from <a href="asyncio.transports.html#ReadTransport">ReadTransport</a>:<br>
<dl><dt><a name="Transport-is_reading"><strong>is_reading</strong></a>(self)</dt><dd><tt>Return&nbsp;True&nbsp;if&nbsp;the&nbsp;transport&nbsp;is&nbsp;receiving.</tt></dd></dl>

<dl><dt><a name="Transport-pause_reading"><strong>pause_reading</strong></a>(self)</dt><dd><tt>Pause&nbsp;the&nbsp;receiving&nbsp;end.<br>
&nbsp;<br>
No&nbsp;data&nbsp;will&nbsp;be&nbsp;passed&nbsp;to&nbsp;the&nbsp;protocol's&nbsp;data_received()<br>
method&nbsp;until&nbsp;<a href="#Transport-resume_reading">resume_reading</a>()&nbsp;is&nbsp;called.</tt></dd></dl>

<dl><dt><a name="Transport-resume_reading"><strong>resume_reading</strong></a>(self)</dt><dd><tt>Resume&nbsp;the&nbsp;receiving&nbsp;end.<br>
&nbsp;<br>
Data&nbsp;received&nbsp;will&nbsp;once&nbsp;again&nbsp;be&nbsp;passed&nbsp;to&nbsp;the&nbsp;protocol's<br>
data_received()&nbsp;method.</tt></dd></dl>

<hr>
Methods inherited from <a href="asyncio.transports.html#WriteTransport">WriteTransport</a>:<br>
<dl><dt><a name="Transport-abort"><strong>abort</strong></a>(self)</dt><dd><tt>Close&nbsp;the&nbsp;transport&nbsp;immediately.<br>
&nbsp;<br>
Buffered&nbsp;data&nbsp;will&nbsp;be&nbsp;lost.&nbsp;&nbsp;No&nbsp;more&nbsp;data&nbsp;will&nbsp;be&nbsp;received.<br>
The&nbsp;protocol's&nbsp;connection_lost()&nbsp;method&nbsp;will&nbsp;(eventually)&nbsp;be<br>
called&nbsp;with&nbsp;None&nbsp;as&nbsp;its&nbsp;argument.</tt></dd></dl>

<dl><dt><a name="Transport-can_write_eof"><strong>can_write_eof</strong></a>(self)</dt><dd><tt>Return&nbsp;True&nbsp;if&nbsp;this&nbsp;transport&nbsp;supports&nbsp;<a href="#Transport-write_eof">write_eof</a>(),&nbsp;False&nbsp;if&nbsp;not.</tt></dd></dl>

<dl><dt><a name="Transport-get_write_buffer_size"><strong>get_write_buffer_size</strong></a>(self)</dt><dd><tt>Return&nbsp;the&nbsp;current&nbsp;size&nbsp;of&nbsp;the&nbsp;write&nbsp;buffer.</tt></dd></dl>

<dl><dt><a name="Transport-set_write_buffer_limits"><strong>set_write_buffer_limits</strong></a>(self, high=None, low=None)</dt><dd><tt>Set&nbsp;the&nbsp;high-&nbsp;and&nbsp;low-water&nbsp;limits&nbsp;for&nbsp;write&nbsp;flow&nbsp;control.<br>
&nbsp;<br>
These&nbsp;two&nbsp;values&nbsp;control&nbsp;when&nbsp;to&nbsp;call&nbsp;the&nbsp;protocol's<br>
pause_writing()&nbsp;and&nbsp;resume_writing()&nbsp;methods.&nbsp;&nbsp;If&nbsp;specified,<br>
the&nbsp;low-water&nbsp;limit&nbsp;must&nbsp;be&nbsp;less&nbsp;than&nbsp;or&nbsp;equal&nbsp;to&nbsp;the<br>
high-water&nbsp;limit.&nbsp;&nbsp;Neither&nbsp;value&nbsp;can&nbsp;be&nbsp;negative.<br>
&nbsp;<br>
The&nbsp;defaults&nbsp;are&nbsp;implementation-specific.&nbsp;&nbsp;If&nbsp;only&nbsp;the<br>
high-water&nbsp;limit&nbsp;is&nbsp;given,&nbsp;the&nbsp;low-water&nbsp;limit&nbsp;defaults&nbsp;to&nbsp;an<br>
implementation-specific&nbsp;value&nbsp;less&nbsp;than&nbsp;or&nbsp;equal&nbsp;to&nbsp;the<br>
high-water&nbsp;limit.&nbsp;&nbsp;Setting&nbsp;high&nbsp;to&nbsp;zero&nbsp;forces&nbsp;low&nbsp;to&nbsp;zero&nbsp;as<br>
well,&nbsp;and&nbsp;causes&nbsp;pause_writing()&nbsp;to&nbsp;be&nbsp;called&nbsp;whenever&nbsp;the<br>
buffer&nbsp;becomes&nbsp;non-empty.&nbsp;&nbsp;Setting&nbsp;low&nbsp;to&nbsp;zero&nbsp;causes<br>
resume_writing()&nbsp;to&nbsp;be&nbsp;called&nbsp;only&nbsp;once&nbsp;the&nbsp;buffer&nbsp;is&nbsp;empty.<br>
Use&nbsp;of&nbsp;zero&nbsp;for&nbsp;either&nbsp;limit&nbsp;is&nbsp;generally&nbsp;sub-optimal&nbsp;as&nbsp;it<br>
reduces&nbsp;opportunities&nbsp;for&nbsp;doing&nbsp;I/O&nbsp;and&nbsp;computation<br>
concurrently.</tt></dd></dl>

<dl><dt><a name="Transport-write"><strong>write</strong></a>(self, data)</dt><dd><tt>Write&nbsp;some&nbsp;data&nbsp;bytes&nbsp;to&nbsp;the&nbsp;transport.<br>
&nbsp;<br>
This&nbsp;does&nbsp;not&nbsp;block;&nbsp;it&nbsp;buffers&nbsp;the&nbsp;data&nbsp;and&nbsp;arranges&nbsp;for&nbsp;it<br>
to&nbsp;be&nbsp;sent&nbsp;out&nbsp;asynchronously.</tt></dd></dl>

<dl><dt><a name="Transport-write_eof"><strong>write_eof</strong></a>(self)</dt><dd><tt>Close&nbsp;the&nbsp;write&nbsp;end&nbsp;after&nbsp;flushing&nbsp;buffered&nbsp;data.<br>
&nbsp;<br>
(This&nbsp;is&nbsp;like&nbsp;typing&nbsp;^D&nbsp;into&nbsp;a&nbsp;UNIX&nbsp;program&nbsp;reading&nbsp;from&nbsp;stdin.)<br>
&nbsp;<br>
Data&nbsp;may&nbsp;still&nbsp;be&nbsp;received.</tt></dd></dl>

<dl><dt><a name="Transport-writelines"><strong>writelines</strong></a>(self, list_of_data)</dt><dd><tt>Write&nbsp;a&nbsp;list&nbsp;(or&nbsp;any&nbsp;iterable)&nbsp;of&nbsp;data&nbsp;bytes&nbsp;to&nbsp;the&nbsp;transport.<br>
&nbsp;<br>
The&nbsp;default&nbsp;implementation&nbsp;concatenates&nbsp;the&nbsp;arguments&nbsp;and<br>
calls&nbsp;<a href="#Transport-write">write</a>()&nbsp;on&nbsp;the&nbsp;result.</tt></dd></dl>

<hr>
Methods inherited from <a href="asyncio.transports.html#BaseTransport">BaseTransport</a>:<br>
<dl><dt><a name="Transport-__init__"><strong>__init__</strong></a>(self, extra=None)</dt><dd><tt>Initialize&nbsp;self.&nbsp;&nbsp;See&nbsp;help(type(self))&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<dl><dt><a name="Transport-close"><strong>close</strong></a>(self)</dt><dd><tt>Close&nbsp;the&nbsp;transport.<br>
&nbsp;<br>
Buffered&nbsp;data&nbsp;will&nbsp;be&nbsp;flushed&nbsp;asynchronously.&nbsp;&nbsp;No&nbsp;more&nbsp;data<br>
will&nbsp;be&nbsp;received.&nbsp;&nbsp;After&nbsp;all&nbsp;buffered&nbsp;data&nbsp;is&nbsp;flushed,&nbsp;the<br>
protocol's&nbsp;connection_lost()&nbsp;method&nbsp;will&nbsp;(eventually)&nbsp;be<br>
called&nbsp;with&nbsp;None&nbsp;as&nbsp;its&nbsp;argument.</tt></dd></dl>

<dl><dt><a name="Transport-get_extra_info"><strong>get_extra_info</strong></a>(self, name, default=None)</dt><dd><tt>Get&nbsp;optional&nbsp;transport&nbsp;information.</tt></dd></dl>

<dl><dt><a name="Transport-get_protocol"><strong>get_protocol</strong></a>(self)</dt><dd><tt>Return&nbsp;the&nbsp;current&nbsp;protocol.</tt></dd></dl>

<dl><dt><a name="Transport-is_closing"><strong>is_closing</strong></a>(self)</dt><dd><tt>Return&nbsp;True&nbsp;if&nbsp;the&nbsp;transport&nbsp;is&nbsp;closing&nbsp;or&nbsp;closed.</tt></dd></dl>

<dl><dt><a name="Transport-set_protocol"><strong>set_protocol</strong></a>(self, protocol)</dt><dd><tt>Set&nbsp;a&nbsp;new&nbsp;protocol.</tt></dd></dl>

</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="WindowsProactorEventLoopPolicy">class <strong>WindowsProactorEventLoopPolicy</strong></a>(<a href="asyncio.events.html#BaseDefaultEventLoopPolicy">asyncio.events.BaseDefaultEventLoopPolicy</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt>Default&nbsp;policy&nbsp;implementation&nbsp;for&nbsp;accessing&nbsp;the&nbsp;event&nbsp;loop.<br>
&nbsp;<br>
In&nbsp;this&nbsp;policy,&nbsp;each&nbsp;thread&nbsp;has&nbsp;its&nbsp;own&nbsp;event&nbsp;loop.&nbsp;&nbsp;However,&nbsp;we<br>
only&nbsp;automatically&nbsp;create&nbsp;an&nbsp;event&nbsp;loop&nbsp;by&nbsp;default&nbsp;for&nbsp;the&nbsp;main<br>
thread;&nbsp;other&nbsp;threads&nbsp;by&nbsp;default&nbsp;have&nbsp;no&nbsp;event&nbsp;loop.<br>
&nbsp;<br>
Other&nbsp;policies&nbsp;may&nbsp;have&nbsp;different&nbsp;rules&nbsp;(e.g.&nbsp;a&nbsp;single&nbsp;global<br>
event&nbsp;loop,&nbsp;or&nbsp;automatically&nbsp;creating&nbsp;an&nbsp;event&nbsp;loop&nbsp;per&nbsp;thread,&nbsp;or<br>
using&nbsp;some&nbsp;other&nbsp;notion&nbsp;of&nbsp;context&nbsp;to&nbsp;which&nbsp;an&nbsp;event&nbsp;loop&nbsp;is<br>
associated).<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="asyncio.windows_events.html#WindowsProactorEventLoopPolicy">WindowsProactorEventLoopPolicy</a></dd>
<dd><a href="asyncio.events.html#BaseDefaultEventLoopPolicy">asyncio.events.BaseDefaultEventLoopPolicy</a></dd>
<dd><a href="asyncio.events.html#AbstractEventLoopPolicy">asyncio.events.AbstractEventLoopPolicy</a></dd>
<dd><a href="builtins.html#object">builtins.object</a></dd>
</dl>
<hr>
Methods inherited from <a href="asyncio.events.html#BaseDefaultEventLoopPolicy">asyncio.events.BaseDefaultEventLoopPolicy</a>:<br>
<dl><dt><a name="WindowsProactorEventLoopPolicy-__init__"><strong>__init__</strong></a>(self)</dt><dd><tt>Initialize&nbsp;self.&nbsp;&nbsp;See&nbsp;help(type(self))&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<dl><dt><a name="WindowsProactorEventLoopPolicy-get_event_loop"><strong>get_event_loop</strong></a>(self)</dt><dd><tt>Get&nbsp;the&nbsp;event&nbsp;loop&nbsp;for&nbsp;the&nbsp;current&nbsp;context.<br>
&nbsp;<br>
Returns&nbsp;an&nbsp;instance&nbsp;of&nbsp;EventLoop&nbsp;or&nbsp;raises&nbsp;an&nbsp;exception.</tt></dd></dl>

<dl><dt><a name="WindowsProactorEventLoopPolicy-new_event_loop"><strong>new_event_loop</strong></a>(self)</dt><dd><tt>Create&nbsp;a&nbsp;new&nbsp;event&nbsp;loop.<br>
&nbsp;<br>
You&nbsp;must&nbsp;call&nbsp;<a href="#WindowsProactorEventLoopPolicy-set_event_loop">set_event_loop</a>()&nbsp;to&nbsp;make&nbsp;this&nbsp;the&nbsp;current&nbsp;event<br>
loop.</tt></dd></dl>

<dl><dt><a name="WindowsProactorEventLoopPolicy-set_event_loop"><strong>set_event_loop</strong></a>(self, loop)</dt><dd><tt>Set&nbsp;the&nbsp;event&nbsp;loop.</tt></dd></dl>

<hr>
Methods inherited from <a href="asyncio.events.html#AbstractEventLoopPolicy">asyncio.events.AbstractEventLoopPolicy</a>:<br>
<dl><dt><a name="WindowsProactorEventLoopPolicy-get_child_watcher"><strong>get_child_watcher</strong></a>(self)</dt><dd><tt>Get&nbsp;the&nbsp;watcher&nbsp;for&nbsp;child&nbsp;processes.</tt></dd></dl>

<dl><dt><a name="WindowsProactorEventLoopPolicy-set_child_watcher"><strong>set_child_watcher</strong></a>(self, watcher)</dt><dd><tt>Set&nbsp;the&nbsp;watcher&nbsp;for&nbsp;child&nbsp;processes.</tt></dd></dl>

<hr>
Data descriptors inherited from <a href="asyncio.events.html#AbstractEventLoopPolicy">asyncio.events.AbstractEventLoopPolicy</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="WindowsSelectorEventLoopPolicy">class <strong>WindowsSelectorEventLoopPolicy</strong></a>(<a href="asyncio.events.html#BaseDefaultEventLoopPolicy">asyncio.events.BaseDefaultEventLoopPolicy</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt>Default&nbsp;policy&nbsp;implementation&nbsp;for&nbsp;accessing&nbsp;the&nbsp;event&nbsp;loop.<br>
&nbsp;<br>
In&nbsp;this&nbsp;policy,&nbsp;each&nbsp;thread&nbsp;has&nbsp;its&nbsp;own&nbsp;event&nbsp;loop.&nbsp;&nbsp;However,&nbsp;we<br>
only&nbsp;automatically&nbsp;create&nbsp;an&nbsp;event&nbsp;loop&nbsp;by&nbsp;default&nbsp;for&nbsp;the&nbsp;main<br>
thread;&nbsp;other&nbsp;threads&nbsp;by&nbsp;default&nbsp;have&nbsp;no&nbsp;event&nbsp;loop.<br>
&nbsp;<br>
Other&nbsp;policies&nbsp;may&nbsp;have&nbsp;different&nbsp;rules&nbsp;(e.g.&nbsp;a&nbsp;single&nbsp;global<br>
event&nbsp;loop,&nbsp;or&nbsp;automatically&nbsp;creating&nbsp;an&nbsp;event&nbsp;loop&nbsp;per&nbsp;thread,&nbsp;or<br>
using&nbsp;some&nbsp;other&nbsp;notion&nbsp;of&nbsp;context&nbsp;to&nbsp;which&nbsp;an&nbsp;event&nbsp;loop&nbsp;is<br>
associated).<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="asyncio.windows_events.html#WindowsSelectorEventLoopPolicy">WindowsSelectorEventLoopPolicy</a></dd>
<dd><a href="asyncio.events.html#BaseDefaultEventLoopPolicy">asyncio.events.BaseDefaultEventLoopPolicy</a></dd>
<dd><a href="asyncio.events.html#AbstractEventLoopPolicy">asyncio.events.AbstractEventLoopPolicy</a></dd>
<dd><a href="builtins.html#object">builtins.object</a></dd>
</dl>
<hr>
Methods inherited from <a href="asyncio.events.html#BaseDefaultEventLoopPolicy">asyncio.events.BaseDefaultEventLoopPolicy</a>:<br>
<dl><dt><a name="WindowsSelectorEventLoopPolicy-__init__"><strong>__init__</strong></a>(self)</dt><dd><tt>Initialize&nbsp;self.&nbsp;&nbsp;See&nbsp;help(type(self))&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<dl><dt><a name="WindowsSelectorEventLoopPolicy-get_event_loop"><strong>get_event_loop</strong></a>(self)</dt><dd><tt>Get&nbsp;the&nbsp;event&nbsp;loop&nbsp;for&nbsp;the&nbsp;current&nbsp;context.<br>
&nbsp;<br>
Returns&nbsp;an&nbsp;instance&nbsp;of&nbsp;EventLoop&nbsp;or&nbsp;raises&nbsp;an&nbsp;exception.</tt></dd></dl>

<dl><dt><a name="WindowsSelectorEventLoopPolicy-new_event_loop"><strong>new_event_loop</strong></a>(self)</dt><dd><tt>Create&nbsp;a&nbsp;new&nbsp;event&nbsp;loop.<br>
&nbsp;<br>
You&nbsp;must&nbsp;call&nbsp;<a href="#WindowsSelectorEventLoopPolicy-set_event_loop">set_event_loop</a>()&nbsp;to&nbsp;make&nbsp;this&nbsp;the&nbsp;current&nbsp;event<br>
loop.</tt></dd></dl>

<dl><dt><a name="WindowsSelectorEventLoopPolicy-set_event_loop"><strong>set_event_loop</strong></a>(self, loop)</dt><dd><tt>Set&nbsp;the&nbsp;event&nbsp;loop.</tt></dd></dl>

<hr>
Methods inherited from <a href="asyncio.events.html#AbstractEventLoopPolicy">asyncio.events.AbstractEventLoopPolicy</a>:<br>
<dl><dt><a name="WindowsSelectorEventLoopPolicy-get_child_watcher"><strong>get_child_watcher</strong></a>(self)</dt><dd><tt>Get&nbsp;the&nbsp;watcher&nbsp;for&nbsp;child&nbsp;processes.</tt></dd></dl>

<dl><dt><a name="WindowsSelectorEventLoopPolicy-set_child_watcher"><strong>set_child_watcher</strong></a>(self, watcher)</dt><dd><tt>Set&nbsp;the&nbsp;watcher&nbsp;for&nbsp;child&nbsp;processes.</tt></dd></dl>

<hr>
Data descriptors inherited from <a href="asyncio.events.html#AbstractEventLoopPolicy">asyncio.events.AbstractEventLoopPolicy</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="WriteTransport">class <strong>WriteTransport</strong></a>(<a href="asyncio.transports.html#BaseTransport">BaseTransport</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#WriteTransport">WriteTransport</a>(extra=None)<br>
&nbsp;<br>
Interface&nbsp;for&nbsp;write-only&nbsp;transports.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="asyncio.transports.html#WriteTransport">WriteTransport</a></dd>
<dd><a href="asyncio.transports.html#BaseTransport">BaseTransport</a></dd>
<dd><a href="builtins.html#object">builtins.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="WriteTransport-abort"><strong>abort</strong></a>(self)</dt><dd><tt>Close&nbsp;the&nbsp;transport&nbsp;immediately.<br>
&nbsp;<br>
Buffered&nbsp;data&nbsp;will&nbsp;be&nbsp;lost.&nbsp;&nbsp;No&nbsp;more&nbsp;data&nbsp;will&nbsp;be&nbsp;received.<br>
The&nbsp;protocol's&nbsp;connection_lost()&nbsp;method&nbsp;will&nbsp;(eventually)&nbsp;be<br>
called&nbsp;with&nbsp;None&nbsp;as&nbsp;its&nbsp;argument.</tt></dd></dl>

<dl><dt><a name="WriteTransport-can_write_eof"><strong>can_write_eof</strong></a>(self)</dt><dd><tt>Return&nbsp;True&nbsp;if&nbsp;this&nbsp;transport&nbsp;supports&nbsp;<a href="#WriteTransport-write_eof">write_eof</a>(),&nbsp;False&nbsp;if&nbsp;not.</tt></dd></dl>

<dl><dt><a name="WriteTransport-get_write_buffer_size"><strong>get_write_buffer_size</strong></a>(self)</dt><dd><tt>Return&nbsp;the&nbsp;current&nbsp;size&nbsp;of&nbsp;the&nbsp;write&nbsp;buffer.</tt></dd></dl>

<dl><dt><a name="WriteTransport-set_write_buffer_limits"><strong>set_write_buffer_limits</strong></a>(self, high=None, low=None)</dt><dd><tt>Set&nbsp;the&nbsp;high-&nbsp;and&nbsp;low-water&nbsp;limits&nbsp;for&nbsp;write&nbsp;flow&nbsp;control.<br>
&nbsp;<br>
These&nbsp;two&nbsp;values&nbsp;control&nbsp;when&nbsp;to&nbsp;call&nbsp;the&nbsp;protocol's<br>
pause_writing()&nbsp;and&nbsp;resume_writing()&nbsp;methods.&nbsp;&nbsp;If&nbsp;specified,<br>
the&nbsp;low-water&nbsp;limit&nbsp;must&nbsp;be&nbsp;less&nbsp;than&nbsp;or&nbsp;equal&nbsp;to&nbsp;the<br>
high-water&nbsp;limit.&nbsp;&nbsp;Neither&nbsp;value&nbsp;can&nbsp;be&nbsp;negative.<br>
&nbsp;<br>
The&nbsp;defaults&nbsp;are&nbsp;implementation-specific.&nbsp;&nbsp;If&nbsp;only&nbsp;the<br>
high-water&nbsp;limit&nbsp;is&nbsp;given,&nbsp;the&nbsp;low-water&nbsp;limit&nbsp;defaults&nbsp;to&nbsp;an<br>
implementation-specific&nbsp;value&nbsp;less&nbsp;than&nbsp;or&nbsp;equal&nbsp;to&nbsp;the<br>
high-water&nbsp;limit.&nbsp;&nbsp;Setting&nbsp;high&nbsp;to&nbsp;zero&nbsp;forces&nbsp;low&nbsp;to&nbsp;zero&nbsp;as<br>
well,&nbsp;and&nbsp;causes&nbsp;pause_writing()&nbsp;to&nbsp;be&nbsp;called&nbsp;whenever&nbsp;the<br>
buffer&nbsp;becomes&nbsp;non-empty.&nbsp;&nbsp;Setting&nbsp;low&nbsp;to&nbsp;zero&nbsp;causes<br>
resume_writing()&nbsp;to&nbsp;be&nbsp;called&nbsp;only&nbsp;once&nbsp;the&nbsp;buffer&nbsp;is&nbsp;empty.<br>
Use&nbsp;of&nbsp;zero&nbsp;for&nbsp;either&nbsp;limit&nbsp;is&nbsp;generally&nbsp;sub-optimal&nbsp;as&nbsp;it<br>
reduces&nbsp;opportunities&nbsp;for&nbsp;doing&nbsp;I/O&nbsp;and&nbsp;computation<br>
concurrently.</tt></dd></dl>

<dl><dt><a name="WriteTransport-write"><strong>write</strong></a>(self, data)</dt><dd><tt>Write&nbsp;some&nbsp;data&nbsp;bytes&nbsp;to&nbsp;the&nbsp;transport.<br>
&nbsp;<br>
This&nbsp;does&nbsp;not&nbsp;block;&nbsp;it&nbsp;buffers&nbsp;the&nbsp;data&nbsp;and&nbsp;arranges&nbsp;for&nbsp;it<br>
to&nbsp;be&nbsp;sent&nbsp;out&nbsp;asynchronously.</tt></dd></dl>

<dl><dt><a name="WriteTransport-write_eof"><strong>write_eof</strong></a>(self)</dt><dd><tt>Close&nbsp;the&nbsp;write&nbsp;end&nbsp;after&nbsp;flushing&nbsp;buffered&nbsp;data.<br>
&nbsp;<br>
(This&nbsp;is&nbsp;like&nbsp;typing&nbsp;^D&nbsp;into&nbsp;a&nbsp;UNIX&nbsp;program&nbsp;reading&nbsp;from&nbsp;stdin.)<br>
&nbsp;<br>
Data&nbsp;may&nbsp;still&nbsp;be&nbsp;received.</tt></dd></dl>

<dl><dt><a name="WriteTransport-writelines"><strong>writelines</strong></a>(self, list_of_data)</dt><dd><tt>Write&nbsp;a&nbsp;list&nbsp;(or&nbsp;any&nbsp;iterable)&nbsp;of&nbsp;data&nbsp;bytes&nbsp;to&nbsp;the&nbsp;transport.<br>
&nbsp;<br>
The&nbsp;default&nbsp;implementation&nbsp;concatenates&nbsp;the&nbsp;arguments&nbsp;and<br>
calls&nbsp;<a href="#WriteTransport-write">write</a>()&nbsp;on&nbsp;the&nbsp;result.</tt></dd></dl>

<hr>
Methods inherited from <a href="asyncio.transports.html#BaseTransport">BaseTransport</a>:<br>
<dl><dt><a name="WriteTransport-__init__"><strong>__init__</strong></a>(self, extra=None)</dt><dd><tt>Initialize&nbsp;self.&nbsp;&nbsp;See&nbsp;help(type(self))&nbsp;for&nbsp;accurate&nbsp;signature.</tt></dd></dl>

<dl><dt><a name="WriteTransport-close"><strong>close</strong></a>(self)</dt><dd><tt>Close&nbsp;the&nbsp;transport.<br>
&nbsp;<br>
Buffered&nbsp;data&nbsp;will&nbsp;be&nbsp;flushed&nbsp;asynchronously.&nbsp;&nbsp;No&nbsp;more&nbsp;data<br>
will&nbsp;be&nbsp;received.&nbsp;&nbsp;After&nbsp;all&nbsp;buffered&nbsp;data&nbsp;is&nbsp;flushed,&nbsp;the<br>
protocol's&nbsp;connection_lost()&nbsp;method&nbsp;will&nbsp;(eventually)&nbsp;be<br>
called&nbsp;with&nbsp;None&nbsp;as&nbsp;its&nbsp;argument.</tt></dd></dl>

<dl><dt><a name="WriteTransport-get_extra_info"><strong>get_extra_info</strong></a>(self, name, default=None)</dt><dd><tt>Get&nbsp;optional&nbsp;transport&nbsp;information.</tt></dd></dl>

<dl><dt><a name="WriteTransport-get_protocol"><strong>get_protocol</strong></a>(self)</dt><dd><tt>Return&nbsp;the&nbsp;current&nbsp;protocol.</tt></dd></dl>

<dl><dt><a name="WriteTransport-is_closing"><strong>is_closing</strong></a>(self)</dt><dd><tt>Return&nbsp;True&nbsp;if&nbsp;the&nbsp;transport&nbsp;is&nbsp;closing&nbsp;or&nbsp;closed.</tt></dd></dl>

<dl><dt><a name="WriteTransport-set_protocol"><strong>set_protocol</strong></a>(self, protocol)</dt><dd><tt>Set&nbsp;a&nbsp;new&nbsp;protocol.</tt></dd></dl>

</td></tr></table></td></tr></table><p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#eeaa77">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial"><big><strong>Functions</strong></big></font></td></tr>
    
<tr><td bgcolor="#eeaa77"><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>
<td width="100%"><dl><dt><a name="-_enter_task"><strong>_enter_task</strong></a>(loop, task)</dt><dd><tt>Enter&nbsp;into&nbsp;task&nbsp;execution&nbsp;or&nbsp;resume&nbsp;suspended&nbsp;task.<br>
&nbsp;<br>
<a href="#Task">Task</a>&nbsp;belongs&nbsp;to&nbsp;loop.<br>
&nbsp;<br>
Returns&nbsp;None.</tt></dd></dl>
 <dl><dt><a name="-_get_running_loop"><strong>_get_running_loop</strong></a>()</dt><dd><tt>Return&nbsp;the&nbsp;running&nbsp;event&nbsp;loop&nbsp;or&nbsp;None.<br>
&nbsp;<br>
This&nbsp;is&nbsp;a&nbsp;low-level&nbsp;function&nbsp;intended&nbsp;to&nbsp;be&nbsp;used&nbsp;by&nbsp;event&nbsp;loops.<br>
This&nbsp;function&nbsp;is&nbsp;thread-specific.</tt></dd></dl>
 <dl><dt><a name="-_leave_task"><strong>_leave_task</strong></a>(loop, task)</dt><dd><tt>Leave&nbsp;task&nbsp;execution&nbsp;or&nbsp;suspend&nbsp;a&nbsp;task.<br>
&nbsp;<br>
<a href="#Task">Task</a>&nbsp;belongs&nbsp;to&nbsp;loop.<br>
&nbsp;<br>
Returns&nbsp;None.</tt></dd></dl>
 <dl><dt><a name="-_register_task"><strong>_register_task</strong></a>(task)</dt><dd><tt>Register&nbsp;a&nbsp;new&nbsp;task&nbsp;in&nbsp;asyncio&nbsp;as&nbsp;executed&nbsp;by&nbsp;loop.<br>
&nbsp;<br>
Returns&nbsp;None.</tt></dd></dl>
 <dl><dt><a name="-_set_running_loop"><strong>_set_running_loop</strong></a>(loop, /)</dt><dd><tt>Set&nbsp;the&nbsp;running&nbsp;event&nbsp;loop.<br>
&nbsp;<br>
This&nbsp;is&nbsp;a&nbsp;low-level&nbsp;function&nbsp;intended&nbsp;to&nbsp;be&nbsp;used&nbsp;by&nbsp;event&nbsp;loops.<br>
This&nbsp;function&nbsp;is&nbsp;thread-specific.</tt></dd></dl>
 <dl><dt><a name="-_unregister_task"><strong>_unregister_task</strong></a>(task)</dt><dd><tt>Unregister&nbsp;a&nbsp;task.<br>
&nbsp;<br>
Returns&nbsp;None.</tt></dd></dl>
 <dl><dt><a name="-all_tasks"><strong>all_tasks</strong></a>(loop=None)</dt><dd><tt>Return&nbsp;a&nbsp;set&nbsp;of&nbsp;all&nbsp;tasks&nbsp;for&nbsp;the&nbsp;loop.</tt></dd></dl>
 <dl><dt><a name="-as_completed"><strong>as_completed</strong></a>(fs, *, loop=None, timeout=None)</dt><dd><tt>Return&nbsp;an&nbsp;iterator&nbsp;whose&nbsp;values&nbsp;are&nbsp;coroutines.<br>
&nbsp;<br>
When&nbsp;waiting&nbsp;for&nbsp;the&nbsp;yielded&nbsp;coroutines&nbsp;you'll&nbsp;get&nbsp;the&nbsp;results&nbsp;(or<br>
exceptions!)&nbsp;of&nbsp;the&nbsp;original&nbsp;Futures&nbsp;(or&nbsp;coroutines),&nbsp;in&nbsp;the&nbsp;order<br>
in&nbsp;which&nbsp;and&nbsp;as&nbsp;soon&nbsp;as&nbsp;they&nbsp;complete.<br>
&nbsp;<br>
This&nbsp;differs&nbsp;from&nbsp;<a href="http://www.python.org/dev/peps/pep-3148/">PEP&nbsp;3148</a>;&nbsp;the&nbsp;proper&nbsp;way&nbsp;to&nbsp;use&nbsp;this&nbsp;is:<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;f&nbsp;in&nbsp;<a href="#-as_completed">as_completed</a>(fs):<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;await&nbsp;f&nbsp;&nbsp;#&nbsp;The&nbsp;'await'&nbsp;may&nbsp;raise.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;Use&nbsp;result.<br>
&nbsp;<br>
If&nbsp;a&nbsp;timeout&nbsp;is&nbsp;specified,&nbsp;the&nbsp;'await'&nbsp;will&nbsp;raise<br>
<a href="#TimeoutError">TimeoutError</a>&nbsp;when&nbsp;the&nbsp;timeout&nbsp;occurs&nbsp;before&nbsp;all&nbsp;Futures&nbsp;are&nbsp;done.<br>
&nbsp;<br>
Note:&nbsp;The&nbsp;futures&nbsp;'f'&nbsp;are&nbsp;not&nbsp;necessarily&nbsp;members&nbsp;of&nbsp;fs.</tt></dd></dl>
 <dl><dt><a name="-coroutine"><strong>coroutine</strong></a>(func)</dt><dd><tt>Decorator&nbsp;to&nbsp;mark&nbsp;coroutines.<br>
&nbsp;<br>
If&nbsp;the&nbsp;coroutine&nbsp;is&nbsp;not&nbsp;yielded&nbsp;from&nbsp;before&nbsp;it&nbsp;is&nbsp;destroyed,<br>
an&nbsp;error&nbsp;message&nbsp;is&nbsp;logged.</tt></dd></dl>
 <dl><dt>async <a name="-create_subprocess_exec"><strong>create_subprocess_exec</strong></a>(program, *args, stdin=None, stdout=None, stderr=None, loop=None, limit=65536, **kwds)</dt></dl>
 <dl><dt>async <a name="-create_subprocess_shell"><strong>create_subprocess_shell</strong></a>(cmd, stdin=None, stdout=None, stderr=None, loop=None, limit=65536, **kwds)</dt></dl>
 <dl><dt><a name="-create_task"><strong>create_task</strong></a>(coro, *, name=None)</dt><dd><tt>Schedule&nbsp;the&nbsp;execution&nbsp;of&nbsp;a&nbsp;coroutine&nbsp;<a href="builtins.html#object">object</a>&nbsp;in&nbsp;a&nbsp;spawn&nbsp;task.<br>
&nbsp;<br>
Return&nbsp;a&nbsp;<a href="#Task">Task</a>&nbsp;<a href="builtins.html#object">object</a>.</tt></dd></dl>
 <dl><dt><a name="-current_task"><strong>current_task</strong></a>(loop=None)</dt><dd><tt>Return&nbsp;a&nbsp;currently&nbsp;executed&nbsp;task.</tt></dd></dl>
 <dl><dt><a name="-ensure_future"><strong>ensure_future</strong></a>(coro_or_future, *, loop=None)</dt><dd><tt>Wrap&nbsp;a&nbsp;coroutine&nbsp;or&nbsp;an&nbsp;awaitable&nbsp;in&nbsp;a&nbsp;future.<br>
&nbsp;<br>
If&nbsp;the&nbsp;argument&nbsp;is&nbsp;a&nbsp;<a href="#Future">Future</a>,&nbsp;it&nbsp;is&nbsp;returned&nbsp;directly.</tt></dd></dl>
 <dl><dt><a name="-gather"><strong>gather</strong></a>(*coros_or_futures, loop=None, return_exceptions=False)</dt><dd><tt>Return&nbsp;a&nbsp;future&nbsp;aggregating&nbsp;results&nbsp;from&nbsp;the&nbsp;given&nbsp;coroutines/futures.<br>
&nbsp;<br>
Coroutines&nbsp;will&nbsp;be&nbsp;wrapped&nbsp;in&nbsp;a&nbsp;future&nbsp;and&nbsp;scheduled&nbsp;in&nbsp;the&nbsp;event<br>
loop.&nbsp;They&nbsp;will&nbsp;not&nbsp;necessarily&nbsp;be&nbsp;scheduled&nbsp;in&nbsp;the&nbsp;same&nbsp;order&nbsp;as<br>
passed&nbsp;in.<br>
&nbsp;<br>
All&nbsp;futures&nbsp;must&nbsp;share&nbsp;the&nbsp;same&nbsp;event&nbsp;loop.&nbsp;&nbsp;If&nbsp;all&nbsp;the&nbsp;tasks&nbsp;are<br>
done&nbsp;successfully,&nbsp;the&nbsp;returned&nbsp;future's&nbsp;result&nbsp;is&nbsp;the&nbsp;list&nbsp;of<br>
results&nbsp;(in&nbsp;the&nbsp;order&nbsp;of&nbsp;the&nbsp;original&nbsp;sequence,&nbsp;not&nbsp;necessarily<br>
the&nbsp;order&nbsp;of&nbsp;results&nbsp;arrival).&nbsp;&nbsp;If&nbsp;*return_exceptions*&nbsp;is&nbsp;True,<br>
exceptions&nbsp;in&nbsp;the&nbsp;tasks&nbsp;are&nbsp;treated&nbsp;the&nbsp;same&nbsp;as&nbsp;successful<br>
results,&nbsp;and&nbsp;gathered&nbsp;in&nbsp;the&nbsp;result&nbsp;list;&nbsp;otherwise,&nbsp;the&nbsp;first<br>
raised&nbsp;exception&nbsp;will&nbsp;be&nbsp;immediately&nbsp;propagated&nbsp;to&nbsp;the&nbsp;returned<br>
future.<br>
&nbsp;<br>
Cancellation:&nbsp;if&nbsp;the&nbsp;outer&nbsp;<a href="#Future">Future</a>&nbsp;is&nbsp;cancelled,&nbsp;all&nbsp;children&nbsp;(that<br>
have&nbsp;not&nbsp;completed&nbsp;yet)&nbsp;are&nbsp;also&nbsp;cancelled.&nbsp;&nbsp;If&nbsp;any&nbsp;child&nbsp;is<br>
cancelled,&nbsp;this&nbsp;is&nbsp;treated&nbsp;as&nbsp;if&nbsp;it&nbsp;raised&nbsp;<a href="#CancelledError">CancelledError</a>&nbsp;--<br>
the&nbsp;outer&nbsp;<a href="#Future">Future</a>&nbsp;is&nbsp;*not*&nbsp;cancelled&nbsp;in&nbsp;this&nbsp;case.&nbsp;&nbsp;(This&nbsp;is&nbsp;to<br>
prevent&nbsp;the&nbsp;cancellation&nbsp;of&nbsp;one&nbsp;child&nbsp;to&nbsp;cause&nbsp;other&nbsp;children&nbsp;to<br>
be&nbsp;cancelled.)<br>
&nbsp;<br>
If&nbsp;*return_exceptions*&nbsp;is&nbsp;False,&nbsp;cancelling&nbsp;<a href="#-gather">gather</a>()&nbsp;after&nbsp;it<br>
has&nbsp;been&nbsp;marked&nbsp;done&nbsp;won't&nbsp;cancel&nbsp;any&nbsp;submitted&nbsp;awaitables.<br>
For&nbsp;instance,&nbsp;gather&nbsp;can&nbsp;be&nbsp;marked&nbsp;done&nbsp;after&nbsp;propagating&nbsp;an<br>
exception&nbsp;to&nbsp;the&nbsp;caller,&nbsp;therefore,&nbsp;calling&nbsp;``gather.cancel()``<br>
after&nbsp;catching&nbsp;an&nbsp;exception&nbsp;(raised&nbsp;by&nbsp;one&nbsp;of&nbsp;the&nbsp;awaitables)&nbsp;from<br>
gather&nbsp;won't&nbsp;cancel&nbsp;any&nbsp;other&nbsp;awaitables.</tt></dd></dl>
 <dl><dt><a name="-get_child_watcher"><strong>get_child_watcher</strong></a>()</dt><dd><tt>Equivalent&nbsp;to&nbsp;calling&nbsp;<a href="#-get_event_loop_policy">get_event_loop_policy</a>().<a href="#-get_child_watcher">get_child_watcher</a>().</tt></dd></dl>
 <dl><dt><a name="-get_event_loop"><strong>get_event_loop</strong></a>()</dt><dd><tt>Return&nbsp;an&nbsp;asyncio&nbsp;event&nbsp;loop.<br>
&nbsp;<br>
When&nbsp;called&nbsp;from&nbsp;a&nbsp;coroutine&nbsp;or&nbsp;a&nbsp;callback&nbsp;(e.g.&nbsp;scheduled&nbsp;with<br>
call_soon&nbsp;or&nbsp;similar&nbsp;API),&nbsp;this&nbsp;function&nbsp;will&nbsp;always&nbsp;return&nbsp;the<br>
running&nbsp;event&nbsp;loop.<br>
&nbsp;<br>
If&nbsp;there&nbsp;is&nbsp;no&nbsp;running&nbsp;event&nbsp;loop&nbsp;set,&nbsp;the&nbsp;function&nbsp;will&nbsp;return<br>
the&nbsp;result&nbsp;of&nbsp;`<a href="#-get_event_loop_policy">get_event_loop_policy</a>().<a href="#-get_event_loop">get_event_loop</a>()`&nbsp;call.</tt></dd></dl>
 <dl><dt><a name="-get_event_loop_policy"><strong>get_event_loop_policy</strong></a>()</dt><dd><tt>Get&nbsp;the&nbsp;current&nbsp;event&nbsp;loop&nbsp;policy.</tt></dd></dl>
 <dl><dt><a name="-get_running_loop"><strong>get_running_loop</strong></a>()</dt><dd><tt>Return&nbsp;the&nbsp;running&nbsp;event&nbsp;loop.&nbsp;&nbsp;Raise&nbsp;a&nbsp;<a href="builtins.html#RuntimeError">RuntimeError</a>&nbsp;if&nbsp;there&nbsp;is&nbsp;none.<br>
&nbsp;<br>
This&nbsp;function&nbsp;is&nbsp;thread-specific.</tt></dd></dl>
 <dl><dt><a name="-iscoroutine"><strong>iscoroutine</strong></a>(obj)</dt><dd><tt>Return&nbsp;True&nbsp;if&nbsp;obj&nbsp;is&nbsp;a&nbsp;coroutine&nbsp;<a href="builtins.html#object">object</a>.</tt></dd></dl>
 <dl><dt><a name="-iscoroutinefunction"><strong>iscoroutinefunction</strong></a>(func)</dt><dd><tt>Return&nbsp;True&nbsp;if&nbsp;func&nbsp;is&nbsp;a&nbsp;decorated&nbsp;coroutine&nbsp;function.</tt></dd></dl>
 <dl><dt><a name="-isfuture"><strong>isfuture</strong></a>(obj)</dt><dd><tt>Check&nbsp;for&nbsp;a&nbsp;<a href="#Future">Future</a>.<br>
&nbsp;<br>
This&nbsp;returns&nbsp;True&nbsp;when&nbsp;obj&nbsp;is&nbsp;a&nbsp;<a href="#Future">Future</a>&nbsp;instance&nbsp;or&nbsp;is&nbsp;advertising<br>
itself&nbsp;as&nbsp;duck-type&nbsp;compatible&nbsp;by&nbsp;setting&nbsp;_asyncio_future_blocking.<br>
See&nbsp;comment&nbsp;in&nbsp;<a href="#Future">Future</a>&nbsp;for&nbsp;more&nbsp;details.</tt></dd></dl>
 <dl><dt><a name="-new_event_loop"><strong>new_event_loop</strong></a>()</dt><dd><tt>Equivalent&nbsp;to&nbsp;calling&nbsp;<a href="#-get_event_loop_policy">get_event_loop_policy</a>().<a href="#-new_event_loop">new_event_loop</a>().</tt></dd></dl>
 <dl><dt>async <a name="-open_connection"><strong>open_connection</strong></a>(host=None, port=None, *, loop=None, limit=65536, **kwds)</dt><dd><tt>A&nbsp;wrapper&nbsp;for&nbsp;create_connection()&nbsp;returning&nbsp;a&nbsp;(reader,&nbsp;writer)&nbsp;pair.<br>
&nbsp;<br>
The&nbsp;reader&nbsp;returned&nbsp;is&nbsp;a&nbsp;<a href="#StreamReader">StreamReader</a>&nbsp;instance;&nbsp;the&nbsp;writer&nbsp;is&nbsp;a<br>
<a href="#StreamWriter">StreamWriter</a>&nbsp;instance.<br>
&nbsp;<br>
The&nbsp;arguments&nbsp;are&nbsp;all&nbsp;the&nbsp;usual&nbsp;arguments&nbsp;to&nbsp;create_connection()<br>
except&nbsp;protocol_factory;&nbsp;most&nbsp;common&nbsp;are&nbsp;positional&nbsp;host&nbsp;and&nbsp;port,<br>
with&nbsp;various&nbsp;optional&nbsp;keyword&nbsp;arguments&nbsp;following.<br>
&nbsp;<br>
Additional&nbsp;optional&nbsp;keyword&nbsp;arguments&nbsp;are&nbsp;loop&nbsp;(to&nbsp;set&nbsp;the&nbsp;event&nbsp;loop<br>
instance&nbsp;to&nbsp;use)&nbsp;and&nbsp;limit&nbsp;(to&nbsp;set&nbsp;the&nbsp;buffer&nbsp;limit&nbsp;passed&nbsp;to&nbsp;the<br>
<a href="#StreamReader">StreamReader</a>).<br>
&nbsp;<br>
(If&nbsp;you&nbsp;want&nbsp;to&nbsp;customize&nbsp;the&nbsp;<a href="#StreamReader">StreamReader</a>&nbsp;and/or<br>
<a href="#StreamReaderProtocol">StreamReaderProtocol</a>&nbsp;classes,&nbsp;just&nbsp;copy&nbsp;the&nbsp;code&nbsp;--&nbsp;there's<br>
really&nbsp;nothing&nbsp;special&nbsp;here&nbsp;except&nbsp;some&nbsp;convenience.)</tt></dd></dl>
 <dl><dt><a name="-run"><strong>run</strong></a>(main, *, debug=None)</dt><dd><tt>Execute&nbsp;the&nbsp;coroutine&nbsp;and&nbsp;return&nbsp;the&nbsp;result.<br>
&nbsp;<br>
This&nbsp;function&nbsp;runs&nbsp;the&nbsp;passed&nbsp;coroutine,&nbsp;taking&nbsp;care&nbsp;of<br>
managing&nbsp;the&nbsp;asyncio&nbsp;event&nbsp;loop&nbsp;and&nbsp;finalizing&nbsp;asynchronous<br>
generators.<br>
&nbsp;<br>
This&nbsp;function&nbsp;cannot&nbsp;be&nbsp;called&nbsp;when&nbsp;another&nbsp;asyncio&nbsp;event&nbsp;loop&nbsp;is<br>
running&nbsp;in&nbsp;the&nbsp;same&nbsp;thread.<br>
&nbsp;<br>
If&nbsp;debug&nbsp;is&nbsp;True,&nbsp;the&nbsp;event&nbsp;loop&nbsp;will&nbsp;be&nbsp;run&nbsp;in&nbsp;debug&nbsp;mode.<br>
&nbsp;<br>
This&nbsp;function&nbsp;always&nbsp;creates&nbsp;a&nbsp;new&nbsp;event&nbsp;loop&nbsp;and&nbsp;closes&nbsp;it&nbsp;at&nbsp;the&nbsp;end.<br>
It&nbsp;should&nbsp;be&nbsp;used&nbsp;as&nbsp;a&nbsp;main&nbsp;entry&nbsp;point&nbsp;for&nbsp;asyncio&nbsp;programs,&nbsp;and&nbsp;should<br>
ideally&nbsp;only&nbsp;be&nbsp;called&nbsp;once.<br>
&nbsp;<br>
Example:<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;async&nbsp;def&nbsp;main():<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;await&nbsp;asyncio.<a href="#-sleep">sleep</a>(1)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('hello')<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;asyncio.<a href="#-run">run</a>(main())</tt></dd></dl>
 <dl><dt><a name="-run_coroutine_threadsafe"><strong>run_coroutine_threadsafe</strong></a>(coro, loop)</dt><dd><tt>Submit&nbsp;a&nbsp;coroutine&nbsp;<a href="builtins.html#object">object</a>&nbsp;to&nbsp;a&nbsp;given&nbsp;event&nbsp;loop.<br>
&nbsp;<br>
Return&nbsp;a&nbsp;concurrent.futures.<a href="#Future">Future</a>&nbsp;to&nbsp;access&nbsp;the&nbsp;result.</tt></dd></dl>
 <dl><dt><a name="-set_child_watcher"><strong>set_child_watcher</strong></a>(watcher)</dt><dd><tt>Equivalent&nbsp;to&nbsp;calling<br>
<a href="#-get_event_loop_policy">get_event_loop_policy</a>().<a href="#-set_child_watcher">set_child_watcher</a>(watcher).</tt></dd></dl>
 <dl><dt><a name="-set_event_loop"><strong>set_event_loop</strong></a>(loop)</dt><dd><tt>Equivalent&nbsp;to&nbsp;calling&nbsp;<a href="#-get_event_loop_policy">get_event_loop_policy</a>().<a href="#-set_event_loop">set_event_loop</a>(loop).</tt></dd></dl>
 <dl><dt><a name="-set_event_loop_policy"><strong>set_event_loop_policy</strong></a>(policy)</dt><dd><tt>Set&nbsp;the&nbsp;current&nbsp;event&nbsp;loop&nbsp;policy.<br>
&nbsp;<br>
If&nbsp;policy&nbsp;is&nbsp;None,&nbsp;the&nbsp;default&nbsp;policy&nbsp;is&nbsp;restored.</tt></dd></dl>
 <dl><dt><a name="-shield"><strong>shield</strong></a>(arg, *, loop=None)</dt><dd><tt>Wait&nbsp;for&nbsp;a&nbsp;future,&nbsp;shielding&nbsp;it&nbsp;from&nbsp;cancellation.<br>
&nbsp;<br>
The&nbsp;statement<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;res&nbsp;=&nbsp;await&nbsp;<a href="#-shield">shield</a>(something())<br>
&nbsp;<br>
is&nbsp;exactly&nbsp;equivalent&nbsp;to&nbsp;the&nbsp;statement<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;res&nbsp;=&nbsp;await&nbsp;something()<br>
&nbsp;<br>
*except*&nbsp;that&nbsp;if&nbsp;the&nbsp;coroutine&nbsp;containing&nbsp;it&nbsp;is&nbsp;cancelled,&nbsp;the<br>
task&nbsp;running&nbsp;in&nbsp;something()&nbsp;is&nbsp;not&nbsp;cancelled.&nbsp;&nbsp;From&nbsp;the&nbsp;POV&nbsp;of<br>
something(),&nbsp;the&nbsp;cancellation&nbsp;did&nbsp;not&nbsp;happen.&nbsp;&nbsp;But&nbsp;its&nbsp;caller&nbsp;is<br>
still&nbsp;cancelled,&nbsp;so&nbsp;the&nbsp;yield-from&nbsp;expression&nbsp;still&nbsp;raises<br>
<a href="#CancelledError">CancelledError</a>.&nbsp;&nbsp;Note:&nbsp;If&nbsp;something()&nbsp;is&nbsp;cancelled&nbsp;by&nbsp;other&nbsp;means<br>
this&nbsp;will&nbsp;still&nbsp;cancel&nbsp;<a href="#-shield">shield</a>().<br>
&nbsp;<br>
If&nbsp;you&nbsp;want&nbsp;to&nbsp;completely&nbsp;ignore&nbsp;cancellation&nbsp;(not&nbsp;recommended)<br>
you&nbsp;can&nbsp;combine&nbsp;<a href="#-shield">shield</a>()&nbsp;with&nbsp;a&nbsp;try/except&nbsp;clause,&nbsp;as&nbsp;follows:<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;try:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res&nbsp;=&nbsp;await&nbsp;<a href="#-shield">shield</a>(something())<br>
&nbsp;&nbsp;&nbsp;&nbsp;except&nbsp;<a href="#CancelledError">CancelledError</a>:<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res&nbsp;=&nbsp;None</tt></dd></dl>
 <dl><dt>async <a name="-sleep"><strong>sleep</strong></a>(delay, result=None, *, loop=None)</dt><dd><tt>Coroutine&nbsp;that&nbsp;completes&nbsp;after&nbsp;a&nbsp;given&nbsp;time&nbsp;(in&nbsp;seconds).</tt></dd></dl>
 <dl><dt>async <a name="-start_server"><strong>start_server</strong></a>(client_connected_cb, host=None, port=None, *, loop=None, limit=65536, **kwds)</dt><dd><tt>Start&nbsp;a&nbsp;socket&nbsp;server,&nbsp;call&nbsp;back&nbsp;for&nbsp;each&nbsp;client&nbsp;connected.<br>
&nbsp;<br>
The&nbsp;first&nbsp;parameter,&nbsp;`client_connected_cb`,&nbsp;takes&nbsp;two&nbsp;parameters:<br>
client_reader,&nbsp;client_writer.&nbsp;&nbsp;client_reader&nbsp;is&nbsp;a&nbsp;<a href="#StreamReader">StreamReader</a><br>
<a href="builtins.html#object">object</a>,&nbsp;while&nbsp;client_writer&nbsp;is&nbsp;a&nbsp;<a href="#StreamWriter">StreamWriter</a>&nbsp;<a href="builtins.html#object">object</a>.&nbsp;&nbsp;This<br>
parameter&nbsp;can&nbsp;either&nbsp;be&nbsp;a&nbsp;plain&nbsp;callback&nbsp;function&nbsp;or&nbsp;a&nbsp;coroutine;<br>
if&nbsp;it&nbsp;is&nbsp;a&nbsp;coroutine,&nbsp;it&nbsp;will&nbsp;be&nbsp;automatically&nbsp;converted&nbsp;into&nbsp;a<br>
<a href="#Task">Task</a>.<br>
&nbsp;<br>
The&nbsp;rest&nbsp;of&nbsp;the&nbsp;arguments&nbsp;are&nbsp;all&nbsp;the&nbsp;usual&nbsp;arguments&nbsp;to<br>
loop.create_server()&nbsp;except&nbsp;protocol_factory;&nbsp;most&nbsp;common&nbsp;are<br>
positional&nbsp;host&nbsp;and&nbsp;port,&nbsp;with&nbsp;various&nbsp;optional&nbsp;keyword&nbsp;arguments<br>
following.&nbsp;&nbsp;The&nbsp;return&nbsp;value&nbsp;is&nbsp;the&nbsp;same&nbsp;as&nbsp;loop.create_server().<br>
&nbsp;<br>
Additional&nbsp;optional&nbsp;keyword&nbsp;arguments&nbsp;are&nbsp;loop&nbsp;(to&nbsp;set&nbsp;the&nbsp;event&nbsp;loop<br>
instance&nbsp;to&nbsp;use)&nbsp;and&nbsp;limit&nbsp;(to&nbsp;set&nbsp;the&nbsp;buffer&nbsp;limit&nbsp;passed&nbsp;to&nbsp;the<br>
<a href="#StreamReader">StreamReader</a>).<br>
&nbsp;<br>
The&nbsp;return&nbsp;value&nbsp;is&nbsp;the&nbsp;same&nbsp;as&nbsp;loop.create_server(),&nbsp;i.e.&nbsp;a<br>
Server&nbsp;<a href="builtins.html#object">object</a>&nbsp;which&nbsp;can&nbsp;be&nbsp;used&nbsp;to&nbsp;stop&nbsp;the&nbsp;service.</tt></dd></dl>
 <dl><dt>async <a name="-wait"><strong>wait</strong></a>(fs, *, loop=None, timeout=None, return_when='ALL_COMPLETED')</dt><dd><tt>Wait&nbsp;for&nbsp;the&nbsp;Futures&nbsp;and&nbsp;coroutines&nbsp;given&nbsp;by&nbsp;fs&nbsp;to&nbsp;complete.<br>
&nbsp;<br>
The&nbsp;sequence&nbsp;futures&nbsp;must&nbsp;not&nbsp;be&nbsp;empty.<br>
&nbsp;<br>
Coroutines&nbsp;will&nbsp;be&nbsp;wrapped&nbsp;in&nbsp;Tasks.<br>
&nbsp;<br>
Returns&nbsp;two&nbsp;sets&nbsp;of&nbsp;<a href="#Future">Future</a>:&nbsp;(done,&nbsp;pending).<br>
&nbsp;<br>
Usage:<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;done,&nbsp;pending&nbsp;=&nbsp;await&nbsp;asyncio.<a href="#-wait">wait</a>(fs)<br>
&nbsp;<br>
Note:&nbsp;This&nbsp;does&nbsp;not&nbsp;raise&nbsp;<a href="#TimeoutError">TimeoutError</a>!&nbsp;Futures&nbsp;that&nbsp;aren't&nbsp;done<br>
when&nbsp;the&nbsp;timeout&nbsp;occurs&nbsp;are&nbsp;returned&nbsp;in&nbsp;the&nbsp;second&nbsp;set.</tt></dd></dl>
 <dl><dt>async <a name="-wait_for"><strong>wait_for</strong></a>(fut, timeout, *, loop=None)</dt><dd><tt>Wait&nbsp;for&nbsp;the&nbsp;single&nbsp;<a href="#Future">Future</a>&nbsp;or&nbsp;coroutine&nbsp;to&nbsp;complete,&nbsp;with&nbsp;timeout.<br>
&nbsp;<br>
Coroutine&nbsp;will&nbsp;be&nbsp;wrapped&nbsp;in&nbsp;<a href="#Task">Task</a>.<br>
&nbsp;<br>
Returns&nbsp;result&nbsp;of&nbsp;the&nbsp;<a href="#Future">Future</a>&nbsp;or&nbsp;coroutine.&nbsp;&nbsp;When&nbsp;a&nbsp;timeout&nbsp;occurs,<br>
it&nbsp;cancels&nbsp;the&nbsp;task&nbsp;and&nbsp;raises&nbsp;<a href="#TimeoutError">TimeoutError</a>.&nbsp;&nbsp;To&nbsp;avoid&nbsp;the&nbsp;task<br>
cancellation,&nbsp;wrap&nbsp;it&nbsp;in&nbsp;<a href="#-shield">shield</a>().<br>
&nbsp;<br>
If&nbsp;the&nbsp;wait&nbsp;is&nbsp;cancelled,&nbsp;the&nbsp;task&nbsp;is&nbsp;also&nbsp;cancelled.<br>
&nbsp;<br>
This&nbsp;function&nbsp;is&nbsp;a&nbsp;coroutine.</tt></dd></dl>
 <dl><dt><a name="-wrap_future"><strong>wrap_future</strong></a>(future, *, loop=None)</dt><dd><tt>Wrap&nbsp;concurrent.futures.<a href="#Future">Future</a>&nbsp;<a href="builtins.html#object">object</a>.</tt></dd></dl>
</td></tr></table><p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#55aa55">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial"><big><strong>Data</strong></big></font></td></tr>
    
<tr><td bgcolor="#55aa55"><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>
<td width="100%"><strong>ALL_COMPLETED</strong> = 'ALL_COMPLETED'<br>
<strong>FIRST_COMPLETED</strong> = 'FIRST_COMPLETED'<br>
<strong>FIRST_EXCEPTION</strong> = 'FIRST_EXCEPTION'<br>
<strong>__all__</strong> = ('BaseEventLoop', 'coroutine', 'iscoroutinefunction', 'iscoroutine', 'AbstractEventLoopPolicy', 'AbstractEventLoop', 'AbstractServer', 'Handle', 'TimerHandle', 'get_event_loop_policy', 'set_event_loop_policy', 'get_event_loop', 'set_event_loop', 'new_event_loop', 'get_child_watcher', 'set_child_watcher', '_set_running_loop', 'get_running_loop', '_get_running_loop', 'CancelledError', ...)</td></tr></table>
</body></html>